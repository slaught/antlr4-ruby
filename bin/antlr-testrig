#!/usr/bin/env ruby

#alias grun "java -cp $CLASSPATH org.antlr.v4.runtime.misc.TestRig"

# java org.antlr.v4.runtime.misc.TestRig GrammarName startRuleName
#   [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]
#   [-trace] [-diagnostics] [-SLL]
#   [input-filename(s)]
# Use startRuleName='tokens' if GrammarName is a lexer grammar.

require 'yaml'
require 'pathname'
#require "rubygems"

require "bundler/setup"
#require "bundler"
#Bundler.setup

def app_dir
  (Pathname.new(File.dirname($0)) + "..").realpath
end
$: << (Pathname.new(app_dir()) +"lib" ).realpath
$: << (Pathname.new(app_dir()) +"vendor/bundle/rbx/2.1/gems/getopt-declare-1.32/lib" ).realpath



$: << 'lib'
$: << '.'

require 'Getopt/Declare'
require 'antlr4'

$DEBUG = false
$TRACE = false
ARG_DEF= <<EOF
         -g <grammar_name>         Grammar Name as declared in .g4 file 
                                   [required]
         -s <start_rule>           Start rule to use
                                   [required]
         -i <input_file>           Example file to parser 
                                   [required]
         -tokens                   Print Tokens 
         
         -trace                    enable trace output
                                    {$TRACE = true }
         -debug                    enable debug output
                                    {$DEBUG = true }

EOF
class TreeShapeListener < ParseTreeListener
  def visitTerminal(node)
  end
  def visitErrorNode(node)
  end
  def exitEveryRule(ctx)
  end
  def enterEveryRule(ctx)
			for child in ctx.getChildren() 
					parent = child.parentCtx
				  if not parent.kind_of? RuleNode or parent.getRuleContext() != ctx then
						 raise IllegalStateException.new("Invalid parse tree shape detected.")
          end
      end
  end
end


def print_tokens(parser)
  atn = parser.interp.atn
  puts "ATN States"
  atn.states.each {|s| 
      puts "(#{s}) : #{s.class}"
  }
  puts "Tokens"
  atn.states.each {|s| 
      nexttokens = atn.nextTokens(s).toString(parser.tokenNames)
      n = parser.tokenNames[s]
      puts "(#{s}) : #{nexttokens}"
  }
end
def create_token_stream(fn)
  input = File.open(fn) 
  inputstream = InputStream.new(input.read)
  lexer = Lexer.new(inputstream)
  stream = CommonTokenStream.new(lexer)
end
#def test1(fn)
#  input = File.open(fn)
#  inputstream = InputStream.new(input.read)
#  lexer = PjmInvoiceLexer.new(inputstream)
#  stream = CommonTokenStream.new(lexer)
#
#	parser = PjmInvoiceParser.new(stream)
# # parser.setTrace(true)
#  parser.buildParseTrees = true 
#  tree = parser.main() 
#
#  ParseTreeWalker.DEFAULT.walk(TreeShapeListener.new(), tree)
#end

def parse_example(grammar_name, start_rule, input) 
  parserClass, lexerClass = load_grammar(grammar_name)
  inputstream = InputStream.new(input.read)
  lexer = lexerClass.new(inputstream)

  stream = CommonTokenStream.new(lexer)
  parser = parserClass.new(stream)
  parser.setTrace($TRACE)
  parser.buildParseTrees = true 
  tree = parser.send(start_rule.to_sym) 
  ParseTreeWalker.DEFAULT.walk(TreeShapeListener.new(), tree)
end

def load_grammar(grammar_name)
 [ load_grammar_file(grammar_name, 'Parser'), load_grammar_file(grammar_name, 'Lexer') ]
end
def load_grammar_file(grammar_name, suffix)
    n = "#{grammar_name}#{suffix}"
    require n
    puts "#{n.inspect} -> #{n.to_sym.inspect}"
    kls = Object.const_get n.to_sym
end

def main(args)
  grammar_name = args['-g']
  in_file = args['-i']
  start_rule = args['-s']

  puts "#{grammar_name}: #{in_file}"
  
  input = File.open(in_file)
  puts parse_example(grammar_name, start_rule, input) 
  input.close
end

main(Getopt::Declare.new(ARG_DEF))
