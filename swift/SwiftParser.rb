# encoding: binary
# Generated from java-escape by ANTLR 4.4
require 'antlr4'
# how to handle package names?
# package = globals().get("__package__", None)
ischild = true # len(package)>0 if package is not None else False
if ischild then 
    require 'SwiftListener'
else
    require 'SwiftListener'
end

class SwiftParser < Parser 
    attr_accessor :grammarFileName 
    attr_accessor :atn, :decisionsToDFA,:sharedContextCache 
    attr_accessor :predicates, :interp
    attr_accessor :ruleNames, :tokenNames

      def self.serializedATN()
      "\x00\x03\x04\x30\xd6\xd1\x82\x06\xad\x2d\x44\x17\xae\xf1\x8d\x80\xaa\xdd"\
      "\x00\x03\x00\x6b\x07\x10\x00\x04\x00\x02\x00\x09\x00\x02\x00\x04\x00\x03"\
      "\x00\x09\x00\x03\x00\x04\x00\x04\x00\x09\x00\x04\x00\x04\x00\x05\x00\x09"\
      "\x00\x05\x00\x04\x00\x06\x00\x09\x00\x06\x00\x04\x00\x07\x00\x09\x00\x07"\
      "\x00\x04\x00\x08\x00\x09\x00\x08\x00\x04\x00\x09\x00\x09\x00\x09\x00\x04"\
      "\x00\x0a\x00\x09\x00\x0a\x00\x04\x00\x0b\x00\x09\x00\x0b\x00\x04\x00\x0c"\
      "\x00\x09\x00\x0c\x00\x04\x00\x0d\x00\x09\x00\x0d\x00\x04\x00\x0e\x00\x09"\
      "\x00\x0e\x00\x04\x00\x0f\x00\x09\x00\x0f\x00\x04\x00\x10\x00\x09\x00\x10"\
      "\x00\x04\x00\x11\x00\x09\x00\x11\x00\x04\x00\x12\x00\x09\x00\x12\x00\x04"\
      "\x00\x13\x00\x09\x00\x13\x00\x04\x00\x14\x00\x09\x00\x14\x00\x04\x00\x15"\
      "\x00\x09\x00\x15\x00\x04\x00\x16\x00\x09\x00\x16\x00\x04\x00\x17\x00\x09"\
      "\x00\x17\x00\x04\x00\x18\x00\x09\x00\x18\x00\x04\x00\x19\x00\x09\x00\x19"\
      "\x00\x04\x00\x1a\x00\x09\x00\x1a\x00\x04\x00\x1b\x00\x09\x00\x1b\x00\x04"\
      "\x00\x1c\x00\x09\x00\x1c\x00\x04\x00\x1d\x00\x09\x00\x1d\x00\x04\x00\x1e"\
      "\x00\x09\x00\x1e\x00\x04\x00\x1f\x00\x09\x00\x1f\x00\x04\x00\x20\x00\x09"\
      "\x00\x20\x00\x04\x00\x21\x00\x09\x00\x21\x00\x04\x00\x22\x00\x09\x00\x22"\
      "\x00\x04\x00\x23\x00\x09\x00\x23\x00\x04\x00\x24\x00\x09\x00\x24\x00\x04"\
      "\x00\x25\x00\x09\x00\x25\x00\x04\x00\x26\x00\x09\x00\x26\x00\x04\x00\x27"\
      "\x00\x09\x00\x27\x00\x04\x00\x28\x00\x09\x00\x28\x00\x04\x00\x29\x00\x09"\
      "\x00\x29\x00\x04\x00\x2a\x00\x09\x00\x2a\x00\x04\x00\x2b\x00\x09\x00\x2b"\
      "\x00\x04\x00\x2c\x00\x09\x00\x2c\x00\x04\x00\x2d\x00\x09\x00\x2d\x00\x04"\
      "\x00\x2e\x00\x09\x00\x2e\x00\x04\x00\x2f\x00\x09\x00\x2f\x00\x04\x00\x30"\
      "\x00\x09\x00\x30\x00\x04\x00\x31\x00\x09\x00\x31\x00\x04\x00\x32\x00\x09"\
      "\x00\x32\x00\x04\x00\x33\x00\x09\x00\x33\x00\x04\x00\x34\x00\x09\x00\x34"\
      "\x00\x04\x00\x35\x00\x09\x00\x35\x00\x04\x00\x36\x00\x09\x00\x36\x00\x04"\
      "\x00\x37\x00\x09\x00\x37\x00\x04\x00\x38\x00\x09\x00\x38\x00\x04\x00\x39"\
      "\x00\x09\x00\x39\x00\x04\x00\x3a\x00\x09\x00\x3a\x00\x04\x00\x3b\x00\x09"\
      "\x00\x3b\x00\x04\x00\x3c\x00\x09\x00\x3c\x00\x04\x00\x3d\x00\x09\x00\x3d"\
      "\x00\x04\x00\x3e\x00\x09\x00\x3e\x00\x04\x00\x3f\x00\x09\x00\x3f\x00\x04"\
      "\x00\x40\x00\x09\x00\x40\x00\x04\x00\x41\x00\x09\x00\x41\x00\x04\x00\x42"\
      "\x00\x09\x00\x42\x00\x04\x00\x43\x00\x09\x00\x43\x00\x04\x00\x44\x00\x09"\
      "\x00\x44\x00\x04\x00\x45\x00\x09\x00\x45\x00\x04\x00\x46\x00\x09\x00\x46"\
      "\x00\x04\x00\x47\x00\x09\x00\x47\x00\x04\x00\x48\x00\x09\x00\x48\x00\x04"\
      "\x00\x49\x00\x09\x00\x49\x00\x04\x00\x4a\x00\x09\x00\x4a\x00\x04\x00\x4b"\
      "\x00\x09\x00\x4b\x00\x04\x00\x4c\x00\x09\x00\x4c\x00\x04\x00\x4d\x00\x09"\
      "\x00\x4d\x00\x04\x00\x4e\x00\x09\x00\x4e\x00\x04\x00\x4f\x00\x09\x00\x4f"\
      "\x00\x04\x00\x50\x00\x09\x00\x50\x00\x04\x00\x51\x00\x09\x00\x51\x00\x04"\
      "\x00\x52\x00\x09\x00\x52\x00\x04\x00\x53\x00\x09\x00\x53\x00\x04\x00\x54"\
      "\x00\x09\x00\x54\x00\x04\x00\x55\x00\x09\x00\x55\x00\x04\x00\x56\x00\x09"\
      "\x00\x56\x00\x04\x00\x57\x00\x09\x00\x57\x00\x04\x00\x58\x00\x09\x00\x58"\
      "\x00\x04\x00\x59\x00\x09\x00\x59\x00\x04\x00\x5a\x00\x09\x00\x5a\x00\x04"\
      "\x00\x5b\x00\x09\x00\x5b\x00\x04\x00\x5c\x00\x09\x00\x5c\x00\x04\x00\x5d"\
      "\x00\x09\x00\x5d\x00\x04\x00\x5e\x00\x09\x00\x5e\x00\x04\x00\x5f\x00\x09"\
      "\x00\x5f\x00\x04\x00\x60\x00\x09\x00\x60\x00\x04\x00\x61\x00\x09\x00\x61"\
      "\x00\x04\x00\x62\x00\x09\x00\x62\x00\x04\x00\x63\x00\x09\x00\x63\x00\x04"\
      "\x00\x64\x00\x09\x00\x64\x00\x04\x00\x65\x00\x09\x00\x65\x00\x04\x00\x66"\
      "\x00\x09\x00\x66\x00\x04\x00\x67\x00\x09\x00\x67\x00\x04\x00\x68\x00\x09"\
      "\x00\x68\x00\x04\x00\x69\x00\x09\x00\x69\x00\x04\x00\x6a\x00\x09\x00\x6a"\
      "\x00\x04\x00\x6b\x00\x09\x00\x6b\x00\x04\x00\x6c\x00\x09\x00\x6c\x00\x04"\
      "\x00\x6d\x00\x09\x00\x6d\x00\x04\x00\x6e\x00\x09\x00\x6e\x00\x04\x00\x6f"\
      "\x00\x09\x00\x6f\x00\x04\x00\x70\x00\x09\x00\x70\x00\x04\x00\x71\x00\x09"\
      "\x00\x71\x00\x04\x00\x72\x00\x09\x00\x72\x00\x04\x00\x73\x00\x09\x00\x73"\
      "\x00\x04\x00\x74\x00\x09\x00\x74\x00\x04\x00\x75\x00\x09\x00\x75\x00\x04"\
      "\x00\x76\x00\x09\x00\x76\x00\x04\x00\x77\x00\x09\x00\x77\x00\x04\x00\x78"\
      "\x00\x09\x00\x78\x00\x04\x00\x79\x00\x09\x00\x79\x00\x04\x00\x7a\x00\x09"\
      "\x00\x7a\x00\x04\x00\x7b\x00\x09\x00\x7b\x00\x04\x00\x7c\x00\x09\x00\x7c"\
      "\x00\x04\x00\x7d\x00\x09\x00\x7d\x00\x04\x00\x7e\x00\x09\x00\x7e\x00\x04"\
      "\x00\x7f\x00\x09\x00\x7f\x00\x04\x00\x80\x00\x09\x00\x80\x00\x04\x00\x81"\
      "\x00\x09\x00\x81\x00\x04\x00\x82\x00\x09\x00\x82\x00\x04\x00\x83\x00\x09"\
      "\x00\x83\x00\x04\x00\x84\x00\x09\x00\x84\x00\x04\x00\x85\x00\x09\x00\x85"\
      "\x00\x04\x00\x86\x00\x09\x00\x86\x00\x04\x00\x87\x00\x09\x00\x87\x00\x04"\
      "\x00\x88\x00\x09\x00\x88\x00\x04\x00\x89\x00\x09\x00\x89\x00\x04\x00\x8a"\
      "\x00\x09\x00\x8a\x00\x04\x00\x8b\x00\x09\x00\x8b\x00\x04\x00\x8c\x00\x09"\
      "\x00\x8c\x00\x04\x00\x8d\x00\x09\x00\x8d\x00\x04\x00\x8e\x00\x09\x00\x8e"\
      "\x00\x04\x00\x8f\x00\x09\x00\x8f\x00\x04\x00\x90\x00\x09\x00\x90\x00\x04"\
      "\x00\x91\x00\x09\x00\x91\x00\x04\x00\x92\x00\x09\x00\x92\x00\x04\x00\x93"\
      "\x00\x09\x00\x93\x00\x04\x00\x94\x00\x09\x00\x94\x00\x04\x00\x95\x00\x09"\
      "\x00\x95\x00\x04\x00\x96\x00\x09\x00\x96\x00\x04\x00\x97\x00\x09\x00\x97"\
      "\x00\x04\x00\x98\x00\x09\x00\x98\x00\x04\x00\x99\x00\x09\x00\x99\x00\x04"\
      "\x00\x9a\x00\x09\x00\x9a\x00\x04\x00\x9b\x00\x09\x00\x9b\x00\x04\x00\x9c"\
      "\x00\x09\x00\x9c\x00\x04\x00\x9d\x00\x09\x00\x9d\x00\x04\x00\x9e\x00\x09"\
      "\x00\x9e\x00\x04\x00\x9f\x00\x09\x00\x9f\x00\x04\x00\xa0\x00\x09\x00\xa0"\
      "\x00\x04\x00\xa1\x00\x09\x00\xa1\x00\x04\x00\xa2\x00\x09\x00\xa2\x00\x04"\
      "\x00\xa3\x00\x09\x00\xa3\x00\x04\x00\xa4\x00\x09\x00\xa4\x00\x04\x00\xa5"\
      "\x00\x09\x00\xa5\x00\x04\x00\xa6\x00\x09\x00\xa6\x00\x04\x00\xa7\x00\x09"\
      "\x00\xa7\x00\x04\x00\xa8\x00\x09\x00\xa8\x00\x04\x00\xa9\x00\x09\x00\xa9"\
      "\x00\x04\x00\xaa\x00\x09\x00\xaa\x00\x04\x00\xab\x00\x09\x00\xab\x00\x04"\
      "\x00\xac\x00\x09\x00\xac\x00\x04\x00\xad\x00\x09\x00\xad\x00\x04\x00\xae"\
      "\x00\x09\x00\xae\x00\x04\x00\xaf\x00\x09\x00\xaf\x00\x04\x00\xb0\x00\x09"\
      "\x00\xb0\x00\x04\x00\xb1\x00\x09\x00\xb1\x00\x04\x00\xb2\x00\x09\x00\xb2"\
      "\x00\x04\x00\xb3\x00\x09\x00\xb3\x00\x04\x00\xb4\x00\x09\x00\xb4\x00\x04"\
      "\x00\xb5\x00\x09\x00\xb5\x00\x04\x00\xb6\x00\x09\x00\xb6\x00\x04\x00\xb7"\
      "\x00\x09\x00\xb7\x00\x04\x00\xb8\x00\x09\x00\xb8\x00\x04\x00\xb9\x00\x09"\
      "\x00\xb9\x00\x04\x00\xba\x00\x09\x00\xba\x00\x04\x00\xbb\x00\x09\x00\xbb"\
      "\x00\x04\x00\xbc\x00\x09\x00\xbc\x00\x04\x00\xbd\x00\x09\x00\xbd\x00\x04"\
      "\x00\xbe\x00\x09\x00\xbe\x00\x04\x00\xbf\x00\x09\x00\xbf\x00\x04\x00\xc0"\
      "\x00\x09\x00\xc0\x00\x04\x00\xc1\x00\x09\x00\xc1\x00\x04\x00\xc2\x00\x09"\
      "\x00\xc2\x00\x04\x00\xc3\x00\x09\x00\xc3\x00\x04\x00\xc4\x00\x09\x00\xc4"\
      "\x00\x04\x00\xc5\x00\x09\x00\xc5\x00\x04\x00\xc6\x00\x09\x00\xc6\x00\x04"\
      "\x00\xc7\x00\x09\x00\xc7\x00\x04\x00\xc8\x00\x09\x00\xc8\x00\x04\x00\xc9"\
      "\x00\x09\x00\xc9\x00\x04\x00\xca\x00\x09\x00\xca\x00\x04\x00\xcb\x00\x09"\
      "\x00\xcb\x00\x04\x00\xcc\x00\x09\x00\xcc\x00\x04\x00\xcd\x00\x09\x00\xcd"\
      "\x00\x04\x00\xce\x00\x09\x00\xce\x00\x04\x00\xcf\x00\x09\x00\xcf\x00\x03"\
      "\x00\x02\x00\x03\x00\x02\x00\x07\x00\x02\x01\xa1\x00\x0a\x00\x02\x00\x0c"\
      "\x00\x02\x00\x0e\x00\x02\x01\xa4\x00\x0b\x00\x02\x00\x03\x00\x02\x00\x03"\
      "\x00\x02\x00\x03\x00\x03\x00\x03\x00\x03\x00\x05\x00\x03\x01\xaa\x00\x0a"\
      "\x00\x03\x00\x03\x00\x03\x00\x03\x00\x03\x00\x05\x00\x03\x01\xae\x00\x0a"\
      "\x00\x03\x00\x03\x00\x03\x00\x03\x00\x03\x00\x05\x00\x03\x01\xb2\x00\x0a"\
      "\x00\x03\x00\x03\x00\x03\x00\x03\x00\x03\x00\x05\x00\x03\x01\xb6\x00\x0a"\
      "\x00\x03\x00\x03\x00\x03\x00\x03\x00\x03\x00\x03\x00\x03\x00\x05\x00\x03"\
      "\x01\xbb\x00\x0a\x00\x03\x00\x05\x00\x03\x01\xbd\x00\x0a\x00\x03\x00\x03"\
      "\x00\x04\x00\x06\x00\x04\x01\xc0\x00\x0a\x00\x04\x00\x0d\x00\x04\x00\x0e"\
      "\x00\x04\x01\xc1\x00\x03\x00\x05\x00\x03\x00\x05\x00\x03\x00\x05\x00\x03"\
      "\x00\x05\x00\x05\x00\x05\x01\xc8\x00\x0a\x00\x05\x00\x03\x00\x06\x00\x03"\
      "\x00\x06\x00\x05\x00\x06\x01\xcc\x00\x0a\x00\x06\x00\x03\x00\x06\x00\x03"\
      "\x00\x06\x00\x05\x00\x06\x01\xd0\x00\x0a\x00\x06\x00\x03\x00\x06\x00\x03"\
      "\x00\x06\x00\x05\x00\x06\x01\xd4\x00\x0a\x00\x06\x00\x03\x00\x06\x00\x03"\
      "\x00\x06\x00\x03\x00\x06\x00\x05\x00\x06\x01\xd9\x00\x0a\x00\x06\x00\x03"\
      "\x00\x06\x00\x03\x00\x06\x00\x05\x00\x06\x01\xdd\x00\x0a\x00\x06\x00\x03"\
      "\x00\x06\x00\x03\x00\x06\x00\x05\x00\x06\x01\xe1\x00\x0a\x00\x06\x00\x03"\
      "\x00\x06\x00\x05\x00\x06\x01\xe4\x00\x0a\x00\x06\x00\x03\x00\x07\x00\x03"\
      "\x00\x07\x00\x05\x00\x07\x01\xe8\x00\x0a\x00\x07\x00\x03\x00\x08\x00\x03"\
      "\x00\x08\x00\x03\x00\x08\x00\x03\x00\x08\x00\x03\x00\x08\x00\x03\x00\x08"\
      "\x00\x03\x00\x09\x00\x03\x00\x09\x00\x03\x00\x09\x00\x03\x00\x09\x00\x03"\
      "\x00\x0a\x00\x03\x00\x0a\x00\x05\x00\x0a\x01\xf6\x00\x0a\x00\x0a\x00\x03"\
      "\x00\x0b\x00\x03\x00\x0b\x00\x03\x00\x0b\x00\x03\x00\x0b\x00\x03\x00\x0b"\
      "\x00\x03\x00\x0c\x00\x03\x00\x0c\x00\x05\x00\x0c\x01\xff\x00\x0a\x00\x0c"\
      "\x00\x03\x00\x0d\x00\x03\x00\x0d\x00\x03\x00\x0d\x00\x03\x00\x0d\x00\x05"\
      "\x00\x0d\x02\x05\x00\x0a\x00\x0d\x00\x03\x00\x0e\x00\x03\x00\x0e\x00\x05"\
      "\x00\x0e\x02\x09\x00\x0a\x00\x0e\x00\x03\x00\x0f\x00\x03\x00\x0f\x00\x03"\
      "\x00\x0f\x00\x03\x00\x0f\x00\x05\x00\x0f\x02\x0f\x00\x0a\x00\x0f\x00\x03"\
      "\x00\x10\x00\x03\x00\x10\x00\x03\x00\x10\x00\x03\x00\x10\x00\x05\x00\x10"\
      "\x02\x15\x00\x0a\x00\x10\x00\x03\x00\x10\x00\x03\x00\x10\x00\x03\x00\x11"\
      "\x00\x03\x00\x11\x00\x05\x00\x11\x02\x1b\x00\x0a\x00\x11\x00\x03\x00\x12"\
      "\x00\x03\x00\x12\x00\x03\x00\x12\x00\x03\x00\x12\x00\x03\x00\x12\x00\x03"\
      "\x00\x12\x00\x03\x00\x12\x00\x03\x00\x12\x00\x03\x00\x12\x00\x03\x00\x12"\
      "\x00\x03\x00\x12\x00\x03\x00\x12\x00\x05\x00\x12\x02\x29\x00\x0a\x00\x12"\
      "\x00\x03\x00\x13\x00\x03\x00\x13\x00\x03\x00\x13\x00\x03\x00\x13\x00\x03"\
      "\x00\x14\x00\x03\x00\x14\x00\x05\x00\x14\x02\x31\x00\x0a\x00\x14\x00\x03"\
      "\x00\x14\x00\x03\x00\x14\x00\x05\x00\x14\x02\x35\x00\x0a\x00\x14\x00\x03"\
      "\x00\x14\x00\x03\x00\x14\x00\x03\x00\x14\x00\x03\x00\x15\x00\x03\x00\x15"\
      "\x00\x03\x00\x15\x00\x03\x00\x16\x00\x03\x00\x16\x00\x03\x00\x16\x00\x03"\
      "\x00\x17\x00\x03\x00\x17\x00\x03\x00\x18\x00\x03\x00\x18\x00\x03\x00\x18"\
      "\x00\x03\x00\x18\x00\x03\x00\x18\x00\x03\x00\x18\x00\x05\x00\x18\x02\x48"\
      "\x00\x0a\x00\x18\x00\x03\x00\x19\x00\x03\x00\x19\x00\x03\x00\x19\x00\x03"\
      "\x00\x1a\x00\x03\x00\x1a\x00\x03\x00\x1b\x00\x03\x00\x1b\x00\x03\x00\x1b"\
      "\x00\x03\x00\x1b\x00\x05\x00\x1b\x02\x53\x00\x0a\x00\x1b\x00\x03\x00\x1c"\
      "\x00\x03\x00\x1c\x00\x05\x00\x1c\x02\x57\x00\x0a\x00\x1c\x00\x03\x00\x1d"\
      "\x00\x03\x00\x1d\x00\x05\x00\x1d\x02\x5b\x00\x0a\x00\x1d\x00\x03\x00\x1e"\
      "\x00\x03\x00\x1e\x00\x03\x00\x1f\x00\x03\x00\x1f\x00\x05\x00\x1f\x02\x61"\
      "\x00\x0a\x00\x1f\x00\x03\x00\x20\x00\x03\x00\x20\x00\x03\x00\x20\x00\x05"\
      "\x00\x20\x02\x66\x00\x0a\x00\x20\x00\x03\x00\x20\x00\x03\x00\x20\x00\x03"\
      "\x00\x21\x00\x03\x00\x21\x00\x03\x00\x21\x00\x03\x00\x21\x00\x03\x00\x21"\
      "\x00\x05\x00\x21\x02\x6f\x00\x0a\x00\x21\x00\x03\x00\x22\x00\x03\x00\x22"\
      "\x00\x03\x00\x22\x00\x03\x00\x22\x00\x03\x00\x22\x00\x03\x00\x22\x00\x03"\
      "\x00\x22\x00\x03\x00\x22\x00\x03\x00\x22\x00\x05\x00\x22\x02\x7a\x00\x0a"\
      "\x00\x22\x00\x03\x00\x23\x00\x03\x00\x23\x00\x03\x00\x23\x00\x03\x00\x24"\
      "\x00\x03\x00\x24\x00\x03\x00\x24\x00\x03\x00\x24\x00\x03\x00\x24\x00\x05"\
      "\x00\x24\x02\x84\x00\x0a\x00\x24\x00\x03\x00\x25\x00\x03\x00\x25\x00\x05"\
      "\x00\x25\x02\x88\x00\x0a\x00\x25\x00\x03\x00\x26\x00\x03\x00\x26\x00\x03"\
      "\x00\x26\x00\x03\x00\x26\x00\x03\x00\x26\x00\x03\x00\x26\x00\x03\x00\x26"\
      "\x00\x03\x00\x26\x00\x05\x00\x26\x02\x92\x00\x0a\x00\x26\x00\x03\x00\x27"\
      "\x00\x03\x00\x27\x00\x03\x00\x27\x00\x03\x00\x27\x00\x03\x00\x28\x00\x03"\
      "\x00\x28\x00\x03\x00\x28\x00\x03\x00\x28\x00\x03\x00\x29\x00\x03\x00\x29"\
      "\x00\x03\x00\x29\x00\x07\x00\x29\x02\x9f\x00\x0a\x00\x29\x00\x0c\x00\x29"\
      "\x00\x0e\x00\x29\x02\xa2\x00\x0b\x00\x29\x00\x03\x00\x2a\x00\x03\x00\x2a"\
      "\x00\x03\x00\x2b\x00\x03\x00\x2b\x00\x03\x00\x2b\x00\x03\x00\x2b\x00\x03"\
      "\x00\x2b\x00\x03\x00\x2b\x00\x03\x00\x2b\x00\x03\x00\x2b\x00\x03\x00\x2b"\
      "\x00\x03\x00\x2b\x00\x03\x00\x2b\x00\x03\x00\x2b\x00\x03\x00\x2b\x00\x03"\
      "\x00\x2b\x00\x05\x00\x2b\x02\xb4\x00\x0a\x00\x2b\x00\x03\x00\x2c\x00\x03"\
      "\x00\x2c\x00\x05\x00\x2c\x02\xb8\x00\x0a\x00\x2c\x00\x03\x00\x2d\x00\x03"\
      "\x00\x2d\x00\x05\x00\x2d\x02\xbc\x00\x0a\x00\x2d\x00\x03\x00\x2e\x00\x03"\
      "\x00\x2e\x00\x03\x00\x2f\x00\x03\x00\x2f\x00\x05\x00\x2f\x02\xc2\x00\x0a"\
      "\x00\x2f\x00\x03\x00\x2f\x00\x03\x00\x2f\x00\x03\x00\x30\x00\x05\x00\x30"\
      "\x02\xc7\x00\x0a\x00\x30\x00\x03\x00\x30\x00\x03\x00\x30\x00\x05\x00\x30"\
      "\x02\xcb\x00\x0a\x00\x30\x00\x03\x00\x30\x00\x03\x00\x30\x00\x03\x00\x31"\
      "\x00\x03\x00\x31\x00\x03\x00\x32\x00\x03\x00\x32\x00\x03\x00\x32\x00\x03"\
      "\x00\x32\x00\x03\x00\x32\x00\x05\x00\x32\x02\xd6\x00\x0a\x00\x32\x00\x03"\
      "\x00\x33\x00\x03\x00\x33\x00\x05\x00\x33\x02\xda\x00\x0a\x00\x33\x00\x03"\
      "\x00\x34\x00\x05\x00\x34\x02\xdd\x00\x0a\x00\x34\x00\x03\x00\x34\x00\x05"\
      "\x00\x34\x02\xe0\x00\x0a\x00\x34\x00\x03\x00\x34\x00\x03\x00\x34\x00\x03"\
      "\x00\x34\x00\x03\x00\x35\x00\x03\x00\x35\x00\x03\x00\x35\x00\x07\x00\x35"\
      "\x02\xe8\x00\x0a\x00\x35\x00\x0c\x00\x35\x00\x0e\x00\x35\x02\xeb\x00\x0b"\
      "\x00\x35\x00\x03\x00\x36\x00\x03\x00\x36\x00\x05\x00\x36\x02\xef\x00\x0a"\
      "\x00\x36\x00\x03\x00\x37\x00\x03\x00\x37\x00\x03\x00\x37\x00\x03\x00\x38"\
      "\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03"\
      "\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38"\
      "\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03"\
      "\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38"\
      "\x00\x03\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x05\x00\x38\x03\x0a"\
      "\x00\x0a\x00\x38\x00\x03\x00\x38\x00\x03\x00\x38\x00\x05\x00\x38\x03\x0e"\
      "\x00\x0a\x00\x38\x00\x03\x00\x39\x00\x05\x00\x39\x03\x11\x00\x0a\x00\x39"\
      "\x00\x03\x00\x39\x00\x05\x00\x39\x03\x14\x00\x0a\x00\x39\x00\x03\x00\x39"\
      "\x00\x03\x00\x39\x00\x03\x00\x3a\x00\x03\x00\x3a\x00\x03\x00\x3b\x00\x03"\
      "\x00\x3b\x00\x03\x00\x3b\x00\x05\x00\x3b\x03\x1d\x00\x0a\x00\x3b\x00\x03"\
      "\x00\x3b\x00\x03\x00\x3b\x00\x03\x00\x3b\x00\x03\x00\x3b\x00\x03\x00\x3b"\
      "\x00\x03\x00\x3b\x00\x03\x00\x3b\x00\x05\x00\x3b\x03\x26\x00\x0a\x00\x3b"\
      "\x00\x03\x00\x3c\x00\x05\x00\x3c\x03\x29\x00\x0a\x00\x3c\x00\x03\x00\x3c"\
      "\x00\x03\x00\x3c\x00\x03\x00\x3c\x00\x03\x00\x3d\x00\x05\x00\x3d\x03\x2f"\
      "\x00\x0a\x00\x3d\x00\x03\x00\x3d\x00\x03\x00\x3d\x00\x05\x00\x3d\x03\x33"\
      "\x00\x0a\x00\x3d\x00\x03\x00\x3d\x00\x03\x00\x3d\x00\x03\x00\x3e\x00\x03"\
      "\x00\x3e\x00\x03\x00\x3f\x00\x03\x00\x3f\x00\x03\x00\x3f\x00\x05\x00\x3f"\
      "\x03\x3c\x00\x0a\x00\x3f\x00\x03\x00\x3f\x00\x03\x00\x3f\x00\x03\x00\x3f"\
      "\x00\x03\x00\x3f\x00\x03\x00\x3f\x00\x03\x00\x3f\x00\x03\x00\x3f\x00\x05"\
      "\x00\x3f\x03\x45\x00\x0a\x00\x3f\x00\x03\x00\x40\x00\x05\x00\x40\x03\x48"\
      "\x00\x0a\x00\x40\x00\x03\x00\x40\x00\x03\x00\x40\x00\x03\x00\x41\x00\x05"\
      "\x00\x41\x03\x4d\x00\x0a\x00\x41\x00\x03\x00\x41\x00\x03\x00\x41\x00\x03"\
      "\x00\x42\x00\x03\x00\x42\x00\x03\x00\x42\x00\x05\x00\x42\x03\x54\x00\x0a"\
      "\x00\x42\x00\x03\x00\x42\x00\x03\x00\x42\x00\x03\x00\x42\x00\x03\x00\x42"\
      "\x00\x03\x00\x42\x00\x03\x00\x42\x00\x03\x00\x42\x00\x05\x00\x42\x03\x5d"\
      "\x00\x0a\x00\x42\x00\x03\x00\x43\x00\x05\x00\x43\x03\x60\x00\x0a\x00\x43"\
      "\x00\x03\x00\x43\x00\x03\x00\x43\x00\x05\x00\x43\x03\x64\x00\x0a\x00\x43"\
      "\x00\x03\x00\x43\x00\x03\x00\x43\x00\x03\x00\x44\x00\x05\x00\x44\x03\x69"\
      "\x00\x0a\x00\x44\x00\x03\x00\x44\x00\x03\x00\x44\x00\x05\x00\x44\x03\x6d"\
      "\x00\x0a\x00\x44\x00\x03\x00\x44\x00\x03\x00\x44\x00\x03\x00\x45\x00\x03"\
      "\x00\x45\x00\x03\x00\x45\x00\x03\x00\x46\x00\x03\x00\x46\x00\x03\x00\x46"\
      "\x00\x03\x00\x47\x00\x03\x00\x47\x00\x03\x00\x48\x00\x03\x00\x48\x00\x03"\
      "\x00\x48\x00\x03\x00\x49\x00\x03\x00\x49\x00\x03\x00\x49\x00\x05\x00\x49"\
      "\x03\x7f\x00\x0a\x00\x49\x00\x03\x00\x49\x00\x03\x00\x49\x00\x03\x00\x49"\
      "\x00\x03\x00\x4a\x00\x05\x00\x4a\x03\x85\x00\x0a\x00\x4a\x00\x03\x00\x4a"\
      "\x00\x05\x00\x4a\x03\x88\x00\x0a\x00\x4a\x00\x03\x00\x4a\x00\x03\x00\x4a"\
      "\x00\x03\x00\x4b\x00\x03\x00\x4b\x00\x05\x00\x4b\x03\x8e\x00\x0a\x00\x4b"\
      "\x00\x03\x00\x4c\x00\x03\x00\x4c\x00\x05\x00\x4c\x03\x92\x00\x0a\x00\x4c"\
      "\x00\x03\x00\x4d\x00\x03\x00\x4d\x00\x05\x00\x4d\x03\x96\x00\x0a\x00\x4d"\
      "\x00\x03\x00\x4d\x00\x03\x00\x4d\x00\x03\x00\x4e\x00\x03\x00\x4e\x00\x03"\
      "\x00\x4f\x00\x03\x00\x4f\x00\x05\x00\x4f\x03\x9e\x00\x0a\x00\x4f\x00\x03"\
      "\x00\x50\x00\x03\x00\x50\x00\x03\x00\x50\x00\x03\x00\x50\x00\x03\x00\x50"\
      "\x00\x05\x00\x50\x03\xa5\x00\x0a\x00\x50\x00\x03\x00\x50\x00\x03\x00\x50"\
      "\x00\x05\x00\x50\x03\xa9\x00\x0a\x00\x50\x00\x03\x00\x51\x00\x03\x00\x51"\
      "\x00\x03\x00\x51\x00\x03\x00\x51\x00\x03\x00\x51\x00\x05\x00\x51\x03\xb0"\
      "\x00\x0a\x00\x51\x00\x03\x00\x52\x00\x05\x00\x52\x03\xb3\x00\x0a\x00\x52"\
      "\x00\x03\x00\x52\x00\x05\x00\x52\x03\xb6\x00\x0a\x00\x52\x00\x03\x00\x52"\
      "\x00\x05\x00\x52\x03\xb9\x00\x0a\x00\x52\x00\x03\x00\x52\x00\x03\x00\x52"\
      "\x00\x05\x00\x52\x03\xbd\x00\x0a\x00\x52\x00\x03\x00\x52\x00\x03\x00\x52"\
      "\x00\x05\x00\x52\x03\xc1\x00\x0a\x00\x52\x00\x03\x00\x52\x00\x05\x00\x52"\
      "\x03\xc4\x00\x0a\x00\x52\x00\x03\x00\x52\x00\x03\x00\x52\x00\x05\x00\x52"\
      "\x03\xc8\x00\x0a\x00\x52\x00\x03\x00\x52\x00\x03\x00\x52\x00\x05\x00\x52"\
      "\x03\xcc\x00\x0a\x00\x52\x00\x03\x00\x52\x00\x03\x00\x52\x00\x05\x00\x52"\
      "\x03\xd0\x00\x0a\x00\x52\x00\x03\x00\x52\x00\x05\x00\x52\x03\xd3\x00\x0a"\
      "\x00\x52\x00\x03\x00\x52\x00\x05\x00\x52\x03\xd6\x00\x0a\x00\x52\x00\x03"\
      "\x00\x53\x00\x03\x00\x53\x00\x05\x00\x53\x03\xda\x00\x0a\x00\x53\x00\x03"\
      "\x00\x54\x00\x03\x00\x54\x00\x05\x00\x54\x03\xde\x00\x0a\x00\x54\x00\x03"\
      "\x00\x55\x00\x03\x00\x55\x00\x03\x00\x55\x00\x03\x00\x56\x00\x05\x00\x56"\
      "\x03\xe4\x00\x0a\x00\x56\x00\x03\x00\x56\x00\x03\x00\x56\x00\x05\x00\x56"\
      "\x03\xe8\x00\x0a\x00\x56\x00\x03\x00\x56\x00\x05\x00\x56\x03\xeb\x00\x0a"\
      "\x00\x56\x00\x03\x00\x57\x00\x03\x00\x57\x00\x05\x00\x57\x03\xef\x00\x0a"\
      "\x00\x57\x00\x03\x00\x57\x00\x03\x00\x57\x00\x05\x00\x57\x03\xf3\x00\x0a"\
      "\x00\x57\x00\x03\x00\x57\x00\x03\x00\x57\x00\x03\x00\x58\x00\x03\x00\x58"\
      "\x00\x05\x00\x58\x03\xf9\x00\x0a\x00\x58\x00\x03\x00\x59\x00\x03\x00\x59"\
      "\x00\x05\x00\x59\x03\xfd\x00\x0a\x00\x59\x00\x03\x00\x5a\x00\x05\x00\x5a"\
      "\x04\x00\x00\x0a\x00\x5a\x00\x03\x00\x5a\x00\x03\x00\x5a\x00\x03\x00\x5a"\
      "\x00\x03\x00\x5b\x00\x03\x00\x5b\x00\x03\x00\x5b\x00\x03\x00\x5b\x00\x03"\
      "\x00\x5b\x00\x05\x00\x5b\x04\x0a\x00\x0a\x00\x5b\x00\x03\x00\x5c\x00\x03"\
      "\x00\x5c\x00\x05\x00\x5c\x04\x0e\x00\x0a\x00\x5c\x00\x03\x00\x5d\x00\x03"\
      "\x00\x5d\x00\x03\x00\x5e\x00\x03\x00\x5e\x00\x03\x00\x5f\x00\x03\x00\x5f"\
      "\x00\x05\x00\x5f\x04\x16\x00\x0a\x00\x5f\x00\x03\x00\x5f\x00\x03\x00\x5f"\
      "\x00\x03\x00\x5f\x00\x03\x00\x5f\x00\x05\x00\x5f\x04\x1c\x00\x0a\x00\x5f"\
      "\x00\x03\x00\x5f\x00\x03\x00\x5f\x00\x03\x00\x60\x00\x03\x00\x60\x00\x05"\
      "\x00\x60\x04\x22\x00\x0a\x00\x60\x00\x03\x00\x61\x00\x03\x00\x61\x00\x05"\
      "\x00\x61\x04\x26\x00\x0a\x00\x61\x00\x03\x00\x62\x00\x05\x00\x62\x04\x29"\
      "\x00\x0a\x00\x62\x00\x03\x00\x62\x00\x03\x00\x62\x00\x03\x00\x62\x00\x03"\
      "\x00\x63\x00\x03\x00\x63\x00\x03\x00\x63\x00\x03\x00\x63\x00\x03\x00\x63"\
      "\x00\x05\x00\x63\x04\x33\x00\x0a\x00\x63\x00\x03\x00\x64\x00\x03\x00\x64"\
      "\x00\x05\x00\x64\x04\x37\x00\x0a\x00\x64\x00\x03\x00\x65\x00\x03\x00\x65"\
      "\x00\x03\x00\x65\x00\x03\x00\x66\x00\x05\x00\x66\x04\x3d\x00\x0a\x00\x66"\
      "\x00\x03\x00\x66\x00\x03\x00\x66\x00\x03\x00\x66\x00\x05\x00\x66\x04\x42"\
      "\x00\x0a\x00\x66\x00\x03\x00\x66\x00\x05\x00\x66\x04\x45\x00\x0a\x00\x66"\
      "\x00\x03\x00\x66\x00\x03\x00\x66\x00\x03\x00\x67\x00\x03\x00\x67\x00\x03"\
      "\x00\x68\x00\x03\x00\x68\x00\x05\x00\x68\x04\x4d\x00\x0a\x00\x68\x00\x03"\
      "\x00\x68\x00\x03\x00\x68\x00\x03\x00\x69\x00\x05\x00\x69\x04\x52\x00\x0a"\
      "\x00\x69\x00\x03\x00\x69\x00\x03\x00\x69\x00\x03\x00\x69\x00\x05\x00\x69"\
      "\x04\x57\x00\x0a\x00\x69\x00\x03\x00\x69\x00\x05\x00\x69\x04\x5a\x00\x0a"\
      "\x00\x69\x00\x03\x00\x69\x00\x03\x00\x69\x00\x03\x00\x6a\x00\x03\x00\x6a"\
      "\x00\x03\x00\x6b\x00\x03\x00\x6b\x00\x05\x00\x6b\x04\x62\x00\x0a\x00\x6b"\
      "\x00\x03\x00\x6b\x00\x03\x00\x6b\x00\x03\x00\x6c\x00\x05\x00\x6c\x04\x67"\
      "\x00\x0a\x00\x6c\x00\x03\x00\x6c\x00\x03\x00\x6c\x00\x03\x00\x6c\x00\x05"\
      "\x00\x6c\x04\x6c\x00\x0a\x00\x6c\x00\x03\x00\x6c\x00\x03\x00\x6c\x00\x03"\
      "\x00\x6d\x00\x03\x00\x6d\x00\x03\x00\x6e\x00\x03\x00\x6e\x00\x05\x00\x6e"\
      "\x04\x74\x00\x0a\x00\x6e\x00\x03\x00\x6e\x00\x03\x00\x6e\x00\x03\x00\x6f"\
      "\x00\x03\x00\x6f\x00\x03\x00\x6f\x00\x03\x00\x6f\x00\x03\x00\x6f\x00\x05"\
      "\x00\x6f\x04\x7d\x00\x0a\x00\x6f\x00\x03\x00\x70\x00\x03\x00\x70\x00\x05"\
      "\x00\x70\x04\x81\x00\x0a\x00\x70\x00\x03\x00\x71\x00\x03\x00\x71\x00\x03"\
      "\x00\x71\x00\x03\x00\x71\x00\x03\x00\x71\x00\x03\x00\x72\x00\x03\x00\x72"\
      "\x00\x03\x00\x72\x00\x05\x00\x72\x04\x8b\x00\x0a\x00\x72\x00\x03\x00\x72"\
      "\x00\x03\x00\x72\x00\x03\x00\x73\x00\x03\x00\x73\x00\x05\x00\x73\x04\x91"\
      "\x00\x0a\x00\x73\x00\x03\x00\x73\x00\x03\x00\x73\x00\x03\x00\x74\x00\x03"\
      "\x00\x74\x00\x03\x00\x74\x00\x03\x00\x74\x00\x03\x00\x75\x00\x03\x00\x75"\
      "\x00\x05\x00\x75\x04\x9b\x00\x0a\x00\x75\x00\x03\x00\x75\x00\x05\x00\x75"\
      "\x04\x9e\x00\x0a\x00\x75\x00\x03\x00\x76\x00\x03\x00\x76\x00\x05\x00\x76"\
      "\x04\xa2\x00\x0a\x00\x76\x00\x03\x00\x76\x00\x03\x00\x76\x00\x03\x00\x76"\
      "\x00\x03\x00\x77\x00\x05\x00\x77\x04\xa8\x00\x0a\x00\x77\x00\x03\x00\x77"\
      "\x00\x05\x00\x77\x04\xab\x00\x0a\x00\x77\x00\x03\x00\x77\x00\x03\x00\x77"\
      "\x00\x03\x00\x78\x00\x03\x00\x78\x00\x03\x00\x79\x00\x05\x00\x79\x04\xb2"\
      "\x00\x0a\x00\x79\x00\x03\x00\x79\x00\x03\x00\x79\x00\x03\x00\x79\x00\x03"\
      "\x00\x7a\x00\x03\x00\x7a\x00\x03\x00\x7a\x00\x05\x00\x7a\x04\xba\x00\x0a"\
      "\x00\x7a\x00\x03\x00\x7a\x00\x03\x00\x7a\x00\x03\x00\x7b\x00\x03\x00\x7b"\
      "\x00\x05\x00\x7b\x04\xc0\x00\x0a\x00\x7b\x00\x03\x00\x7b\x00\x03\x00\x7b"\
      "\x00\x03\x00\x7c\x00\x03\x00\x7c\x00\x03\x00\x7c\x00\x03\x00\x7c\x00\x03"\
      "\x00\x7c\x00\x03\x00\x7c\x00\x03\x00\x7c\x00\x03\x00\x7c\x00\x03\x00\x7c"\
      "\x00\x03\x00\x7c\x00\x03\x00\x7c\x00\x03\x00\x7c\x00\x05\x00\x7c\x04\xd0"\
      "\x00\x0a\x00\x7c\x00\x03\x00\x7d\x00\x05\x00\x7d\x04\xd3\x00\x0a\x00\x7d"\
      "\x00\x03\x00\x7d\x00\x03\x00\x7d\x00\x03\x00\x7d\x00\x03\x00\x7e\x00\x03"\
      "\x00\x7e\x00\x05\x00\x7e\x04\xda\x00\x0a\x00\x7e\x00\x03\x00\x7e\x00\x03"\
      "\x00\x7e\x00\x03\x00\x7f\x00\x03\x00\x7f\x00\x03\x00\x7f\x00\x05\x00\x7f"\
      "\x04\xe1\x00\x0a\x00\x7f\x00\x03\x00\x80\x00\x03\x00\x80\x00\x03\x00\x80"\
      "\x00\x03\x00\x80\x00\x03\x00\x80\x00\x03\x00\x80\x00\x03\x00\x81\x00\x03"\
      "\x00\x81\x00\x03\x00\x81\x00\x03\x00\x81\x00\x03\x00\x81\x00\x03\x00\x81"\
      "\x00\x03\x00\x82\x00\x03\x00\x82\x00\x03\x00\x82\x00\x03\x00\x82\x00\x03"\
      "\x00\x82\x00\x03\x00\x82\x00\x03\x00\x82\x00\x03\x00\x83\x00\x05\x00\x83"\
      "\x04\xf7\x00\x0a\x00\x83\x00\x03\x00\x83\x00\x05\x00\x83\x04\xfa\x00\x0a"\
      "\x00\x83\x00\x03\x00\x84\x00\x03\x00\x84\x00\x03\x00\x84\x00\x03\x00\x85"\
      "\x00\x03\x00\x85\x00\x03\x00\x86\x00\x03\x00\x86\x00\x03\x00\x86\x00\x03"\
      "\x00\x87\x00\x03\x00\x87\x00\x03\x00\x88\x00\x03\x00\x88\x00\x03\x00\x88"\
      "\x00\x05\x00\x88\x05\x09\x00\x0a\x00\x88\x00\x03\x00\x88\x00\x03\x00\x88"\
      "\x00\x05\x00\x88\x05\x0d\x00\x0a\x00\x88\x00\x03\x00\x88\x00\x03\x00\x88"\
      "\x00\x03\x00\x88\x00\x05\x00\x88\x05\x12\x00\x0a\x00\x88\x00\x03\x00\x88"\
      "\x00\x03\x00\x88\x00\x03\x00\x88\x00\x03\x00\x88\x00\x05\x00\x88\x05\x18"\
      "\x00\x0a\x00\x88\x00\x03\x00\x88\x00\x03\x00\x88\x00\x03\x00\x88\x00\x07"\
      "\x00\x88\x05\x1d\x00\x0a\x00\x88\x00\x0c\x00\x88\x00\x0e\x00\x88\x05\x20"\
      "\x00\x0b\x00\x88\x00\x03\x00\x89\x00\x03\x00\x89\x00\x03\x00\x8a\x00\x03"\
      "\x00\x8a\x00\x03\x00\x8b\x00\x03\x00\x8b\x00\x03\x00\x8b\x00\x03\x00\x8b"\
      "\x00\x05\x00\x8b\x05\x2a\x00\x0a\x00\x8b\x00\x03\x00\x8c\x00\x03\x00\x8c"\
      "\x00\x05\x00\x8c\x05\x2e\x00\x0a\x00\x8c\x00\x03\x00\x8c\x00\x03\x00\x8c"\
      "\x00\x03\x00\x8d\x00\x03\x00\x8d\x00\x03\x00\x8d\x00\x07\x00\x8d\x05\x35"\
      "\x00\x0a\x00\x8d\x00\x0c\x00\x8d\x00\x0e\x00\x8d\x05\x38\x00\x0b\x00\x8d"\
      "\x00\x03\x00\x8e\x00\x03\x00\x8e\x00\x03\x00\x8f\x00\x05\x00\x8f\x05\x3d"\
      "\x00\x0a\x00\x8f\x00\x03\x00\x8f\x00\x03\x00\x8f\x00\x03\x00\x8f\x00\x05"\
      "\x00\x8f\x05\x42\x00\x0a\x00\x8f\x00\x03\x00\x90\x00\x03\x00\x90\x00\x05"\
      "\x00\x90\x05\x46\x00\x0a\x00\x90\x00\x03\x00\x91\x00\x03\x00\x91\x00\x03"\
      "\x00\x91\x00\x03\x00\x92\x00\x03\x00\x92\x00\x03\x00\x92\x00\x03\x00\x92"\
      "\x00\x03\x00\x93\x00\x03\x00\x93\x00\x03\x00\x94\x00\x03\x00\x94\x00\x03"\
      "\x00\x94\x00\x05\x00\x94\x05\x54\x00\x0a\x00\x94\x00\x03\x00\x95\x00\x03"\
      "\x00\x95\x00\x03\x00\x96\x00\x03\x00\x96\x00\x05\x00\x96\x05\x5a\x00\x0a"\
      "\x00\x96\x00\x03\x00\x96\x00\x03\x00\x96\x00\x03\x00\x97\x00\x06\x00\x97"\
      "\x05\x5f\x00\x0a\x00\x97\x00\x0d\x00\x97\x00\x0e\x00\x97\x05\x60\x00\x03"\
      "\x00\x98\x00\x06\x00\x98\x05\x64\x00\x0a\x00\x98\x00\x0d\x00\x98\x00\x0e"\
      "\x00\x98\x05\x65\x00\x03\x00\x99\x00\x03\x00\x99\x00\x05\x00\x99\x05\x6a"\
      "\x00\x0a\x00\x99\x00\x03\x00\x99\x00\x03\x00\x99\x00\x03\x00\x99\x00\x05"\
      "\x00\x99\x05\x6f\x00\x0a\x00\x99\x00\x03\x00\x99\x00\x03\x00\x99\x00\x03"\
      "\x00\x99\x00\x05\x00\x99\x05\x74\x00\x0a\x00\x99\x00\x03\x00\x99\x00\x03"\
      "\x00\x99\x00\x03\x00\x99\x00\x03\x00\x99\x00\x03\x00\x99\x00\x03\x00\x99"\
      "\x00\x05\x00\x99\x05\x7c\x00\x0a\x00\x99\x00\x03\x00\x9a\x00\x03\x00\x9a"\
      "\x00\x03\x00\x9a\x00\x07\x00\x9a\x05\x81\x00\x0a\x00\x9a\x00\x0c\x00\x9a"\
      "\x00\x0e\x00\x9a\x05\x84\x00\x0b\x00\x9a\x00\x03\x00\x9b\x00\x03\x00\x9b"\
      "\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x05"\
      "\x00\x9b\x05\x8c\x00\x0a\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03"\
      "\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b"\
      "\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03"\
      "\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b"\
      "\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x05\x00\x9b\x05\xa1"\
      "\x00\x0a\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03"\
      "\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b"\
      "\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x05\x00\x9b\x05\xad\x00\x0a\x00\x9b"\
      "\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03"\
      "\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b"\
      "\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03\x00\x9b\x00\x03"\
      "\x00\x9b\x00\x03\x00\x9b\x00\x07\x00\x9b\x05\xbe\x00\x0a\x00\x9b\x00\x0c"\
      "\x00\x9b\x00\x0e\x00\x9b\x05\xc1\x00\x0b\x00\x9b\x00\x03\x00\x9c\x00\x03"\
      "\x00\x9c\x00\x03\x00\x9c\x00\x03\x00\x9d\x00\x03\x00\x9d\x00\x03\x00\x9e"\
      "\x00\x03\x00\x9e\x00\x03\x00\x9e\x00\x03\x00\x9e\x00\x03\x00\x9f\x00\x03"\
      "\x00\x9f\x00\x03\x00\x9f\x00\x03\x00\x9f\x00\x05\x00\x9f\x05\xd0\x00\x0a"\
      "\x00\x9f\x00\x03\x00\x9f\x00\x05\x00\x9f\x05\xd3\x00\x0a\x00\x9f\x00\x03"\
      "\x00\xa0\x00\x03\x00\xa0\x00\x03\x00\xa1\x00\x03\x00\xa1\x00\x05\x00\xa1"\
      "\x05\xd9\x00\x0a\x00\xa1\x00\x03\x00\xa1\x00\x03\x00\xa1\x00\x03\x00\xa1"\
      "\x00\x03\x00\xa1\x00\x03\x00\xa1\x00\x03\x00\xa1\x00\x03\x00\xa1\x00\x05"\
      "\x00\xa1\x05\xe2\x00\x0a\x00\xa1\x00\x03\x00\xa2\x00\x03\x00\xa2\x00\x03"\
      "\x00\xa2\x00\x03\x00\xa2\x00\x03\x00\xa2\x00\x03\x00\xa2\x00\x03\x00\xa2"\
      "\x00\x05\x00\xa2\x05\xeb\x00\x0a\x00\xa2\x00\x03\x00\xa3\x00\x03\x00\xa3"\
      "\x00\x05\x00\xa3\x05\xef\x00\x0a\x00\xa3\x00\x03\x00\xa3\x00\x03\x00\xa3"\
      "\x00\x03\x00\xa4\x00\x03\x00\xa4\x00\x05\x00\xa4\x05\xf5\x00\x0a\x00\xa4"\
      "\x00\x03\x00\xa4\x00\x03\x00\xa4\x00\x03\x00\xa4\x00\x03\x00\xa4\x00\x05"\
      "\x00\xa4\x05\xfb\x00\x0a\x00\xa4\x00\x03\x00\xa5\x00\x03\x00\xa5\x00\x03"\
      "\x00\xa6\x00\x03\x00\xa6\x00\x03\x00\xa6\x00\x03\x00\xa6\x00\x03\x00\xa6"\
      "\x00\x03\x00\xa6\x00\x03\x00\xa6\x00\x05\x00\xa6\x06\x06\x00\x0a\x00\xa6"\
      "\x00\x03\x00\xa7\x00\x03\x00\xa7\x00\x05\x00\xa7\x06\x0a\x00\x0a\x00\xa7"\
      "\x00\x03\x00\xa7\x00\x03\x00\xa7\x00\x03\x00\xa7\x00\x03\x00\xa7\x00\x03"\
      "\x00\xa8\x00\x03\x00\xa8\x00\x03\x00\xa8\x00\x03\x00\xa8\x00\x03\x00\xa9"\
      "\x00\x03\x00\xa9\x00\x03\x00\xa9\x00\x03\x00\xa9\x00\x03\x00\xa9\x00\x03"\
      "\x00\xa9\x00\x03\x00\xa9\x00\x03\x00\xa9\x00\x03\x00\xa9\x00\x03\x00\xa9"\
      "\x00\x03\x00\xa9\x00\x03\x00\xa9\x00\x05\x00\xa9\x06\x20\x00\x0a\x00\xa9"\
      "\x00\x03\x00\xaa\x00\x03\x00\xaa\x00\x03\x00\xaa\x00\x03\x00\xaa\x00\x05"\
      "\x00\xaa\x06\x26\x00\x0a\x00\xaa\x00\x03\x00\xab\x00\x03\x00\xab\x00\x03"\
      "\x00\xab\x00\x03\x00\xab\x00\x03\x00\xac\x00\x03\x00\xac\x00\x03\x00\xac"\
      "\x00\x03\x00\xac\x00\x03\x00\xac\x00\x03\x00\xad\x00\x03\x00\xad\x00\x03"\
      "\x00\xad\x00\x03\x00\xad\x00\x03\x00\xae\x00\x03\x00\xae\x00\x05\x00\xae"\
      "\x06\x37\x00\x0a\x00\xae\x00\x03\x00\xae\x00\x03\x00\xae\x00\x03\x00\xae"\
      "\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x05\x00\xaf\x06\x3e\x00\x0a\x00\xaf"\
      "\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x05"\
      "\x00\xaf\x06\x44\x00\x0a\x00\xaf\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x03"\
      "\x00\xaf\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x05\x00\xaf\x06\x4b\x00\x0a"\
      "\x00\xaf\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x03\x00\xaf"\
      "\x00\x03\x00\xaf\x00\x05\x00\xaf\x06\x52\x00\x0a\x00\xaf\x00\x03\x00\xaf"\
      "\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x03\x00\xaf\x00\x05"\
      "\x00\xaf\x06\x59\x00\x0a\x00\xaf\x00\x03\x00\xb0\x00\x03\x00\xb0\x00\x03"\
      "\x00\xb0\x00\x03\x00\xb0\x00\x03\x00\xb0\x00\x03\x00\xb1\x00\x03\x00\xb1"\
      "\x00\x03\x00\xb2\x00\x03\x00\xb2\x00\x03\x00\xb2\x00\x03\x00\xb3\x00\x03"\
      "\x00\xb3\x00\x05\x00\xb3\x06\x67\x00\x0a\x00\xb3\x00\x03\x00\xb3\x00\x03"\
      "\x00\xb3\x00\x03\x00\xb4\x00\x03\x00\xb4\x00\x03\x00\xb4\x00\x03\x00\xb4"\
      "\x00\x03\x00\xb4\x00\x05\x00\xb4\x06\x70\x00\x0a\x00\xb4\x00\x03\x00\xb5"\
      "\x00\x03\x00\xb5\x00\x03\x00\xb5\x00\x03\x00\xb5\x00\x03\x00\xb5\x00\x05"\
      "\x00\xb5\x06\x77\x00\x0a\x00\xb5\x00\x03\x00\xb6\x00\x03\x00\xb6\x00\x03"\
      "\x00\xb7\x00\x03\x00\xb7\x00\x03\x00\xb8\x00\x03\x00\xb8\x00\x03\x00\xb9"\
      "\x00\x03\x00\xb9\x00\x03\x00\xba\x00\x03\x00\xba\x00\x03\x00\xbb\x00\x03"\
      "\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x05\x00\xbb\x06\x87\x00\x0a"\
      "\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb"\
      "\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x03"\
      "\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb"\
      "\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x03\x00\xbb\x00\x07\x00\xbb\x06\x99"\
      "\x00\x0a\x00\xbb\x00\x0c\x00\xbb\x00\x0e\x00\xbb\x06\x9c\x00\x0b\x00\xbb"\
      "\x00\x03\x00\xbc\x00\x03\x00\xbc\x00\x05\x00\xbc\x06\xa0\x00\x0a\x00\xbc"\
      "\x00\x03\x00\xbc\x00\x03\x00\xbc\x00\x03\x00\xbd\x00\x03\x00\xbd\x00\x05"\
      "\x00\xbd\x06\xa6\x00\x0a\x00\xbd\x00\x03\x00\xbd\x00\x03\x00\xbd\x00\x05"\
      "\x00\xbd\x06\xaa\x00\x0a\x00\xbd\x00\x03\x00\xbd\x00\x03\x00\xbd\x00\x03"\
      "\x00\xbd\x00\x05\x00\xbd\x06\xaf\x00\x0a\x00\xbd\x00\x03\x00\xbe\x00\x03"\
      "\x00\xbe\x00\x03\x00\xbf\x00\x03\x00\xbf\x00\x05\x00\xbf\x06\xb5\x00\x0a"\
      "\x00\xbf\x00\x03\x00\xbf\x00\x03\x00\xbf\x00\x03\x00\xc0\x00\x03\x00\xc0"\
      "\x00\x05\x00\xc0\x06\xbb\x00\x0a\x00\xc0\x00\x03\x00\xc1\x00\x03\x00\xc1"\
      "\x00\x03\x00\xc1\x00\x03\x00\xc1\x00\x03\x00\xc1\x00\x05\x00\xc1\x06\xc2"\
      "\x00\x0a\x00\xc1\x00\x03\x00\xc2\x00\x05\x00\xc2\x06\xc5\x00\x0a\x00\xc2"\
      "\x00\x03\x00\xc2\x00\x05\x00\xc2\x06\xc8\x00\x0a\x00\xc2\x00\x03\x00\xc2"\
      "\x00\x03\x00\xc2\x00\x05\x00\xc2\x06\xcc\x00\x0a\x00\xc2\x00\x03\x00\xc2"\
      "\x00\x03\x00\xc2\x00\x03\x00\xc2\x00\x05\x00\xc2\x06\xd1\x00\x0a\x00\xc2"\
      "\x00\x03\x00\xc3\x00\x03\x00\xc3\x00\x03\x00\xc4\x00\x03\x00\xc4\x00\x03"\
      "\x00\xc4\x00\x05\x00\xc4\x06\xd8\x00\x0a\x00\xc4\x00\x03\x00\xc4\x00\x03"\
      "\x00\xc4\x00\x03\x00\xc5\x00\x03\x00\xc5\x00\x03\x00\xc5\x00\x03\x00\xc5"\
      "\x00\x03\x00\xc5\x00\x05\x00\xc5\x06\xe1\x00\x0a\x00\xc5\x00\x03\x00\xc6"\
      "\x00\x03\x00\xc6\x00\x03\x00\xc7\x00\x03\x00\xc7\x00\x03\x00\xc7\x00\x03"\
      "\x00\xc7\x00\x03\x00\xc7\x00\x03\x00\xc7\x00\x03\x00\xc7\x00\x03\x00\xc7"\
      "\x00\x05\x00\xc7\x06\xed\x00\x0a\x00\xc7\x00\x03\x00\xc8\x00\x03\x00\xc8"\
      "\x00\x03\x00\xc8\x00\x03\x00\xc9\x00\x03\x00\xc9\x00\x03\x00\xc9\x00\x07"\
      "\x00\xc9\x06\xf5\x00\x0a\x00\xc9\x00\x0c\x00\xc9\x00\x0e\x00\xc9\x06\xf8"\
      "\x00\x0b\x00\xc9\x00\x03\x00\xca\x00\x03\x00\xca\x00\x05\x00\xca\x06\xfc"\
      "\x00\x0a\x00\xca\x00\x03\x00\xcb\x00\x03\x00\xcb\x00\x03\x00\xcc\x00\x03"\
      "\x00\xcc\x00\x03\x00\xcd\x00\x03\x00\xcd\x00\x03\x00\xcd\x00\x03\x00\xcd"\
      "\x00\x03\x00\xcd\x00\x05\x00\xcd\x07\x07\x00\x0a\x00\xcd\x00\x03\x00\xce"\
      "\x00\x03\x00\xce\x00\x03\x00\xce\x00\x05\x00\xce\x07\x0c\x00\x0a\x00\xce"\
      "\x00\x03\x00\xcf\x00\x03\x00\xcf\x00\x03\x00\xcf\x00\x02\x00\x05\x01\x0e"\
      "\x01\x34\x01\x74\x00\xd0\x00\x02\x00\x04\x00\x06\x00\x08\x00\x0a\x00\x0c"\
      "\x00\x0e\x00\x10\x00\x12\x00\x14\x00\x16\x00\x18\x00\x1a\x00\x1c\x00\x1e"\
      "\x00\x20\x00\x22\x00\x24\x00\x26\x00\x28\x00\x2a\x00\x2c\x00\x2e\x00\x30"\
      "\x00\x32\x00\x34\x00\x36\x00\x38\x00\x3a\x00\x3c\x00\x3e\x00\x40\x00\x42"\
      "\x00\x44\x00\x46\x00\x48\x00\x4a\x00\x4c\x00\x4e\x00\x50\x00\x52\x00\x54"\
      "\x00\x56\x00\x58\x00\x5a\x00\x5c\x00\x5e\x00\x60\x00\x62\x00\x64\x00\x66"\
      "\x00\x68\x00\x6a\x00\x6c\x00\x6e\x00\x70\x00\x72\x00\x74\x00\x76\x00\x78"\
      "\x00\x7a\x00\x7c\x00\x7e\x00\x80\x00\x82\x00\x84\x00\x86\x00\x88\x00\x8a"\
      "\x00\x8c\x00\x8e\x00\x90\x00\x92\x00\x94\x00\x96\x00\x98\x00\x9a\x00\x9c"\
      "\x00\x9e\x00\xa0\x00\xa2\x00\xa4\x00\xa6\x00\xa8\x00\xaa\x00\xac\x00\xae"\
      "\x00\xb0\x00\xb2\x00\xb4\x00\xb6\x00\xb8\x00\xba\x00\xbc\x00\xbe\x00\xc0"\
      "\x00\xc2\x00\xc4\x00\xc6\x00\xc8\x00\xca\x00\xcc\x00\xce\x00\xd0\x00\xd2"\
      "\x00\xd4\x00\xd6\x00\xd8\x00\xda\x00\xdc\x00\xde\x00\xe0\x00\xe2\x00\xe4"\
      "\x00\xe6\x00\xe8\x00\xea\x00\xec\x00\xee\x00\xf0\x00\xf2\x00\xf4\x00\xf6"\
      "\x00\xf8\x00\xfa\x00\xfc\x00\xfe\x01\x00\x01\x02\x01\x04\x01\x06\x01\x08"\
      "\x01\x0a\x01\x0c\x01\x0e\x01\x10\x01\x12\x01\x14\x01\x16\x01\x18\x01\x1a"\
      "\x01\x1c\x01\x1e\x01\x20\x01\x22\x01\x24\x01\x26\x01\x28\x01\x2a\x01\x2c"\
      "\x01\x2e\x01\x30\x01\x32\x01\x34\x01\x36\x01\x38\x01\x3a\x01\x3c\x01\x3e"\
      "\x01\x40\x01\x42\x01\x44\x01\x46\x01\x48\x01\x4a\x01\x4c\x01\x4e\x01\x50"\
      "\x01\x52\x01\x54\x01\x56\x01\x58\x01\x5a\x01\x5c\x01\x5e\x01\x60\x01\x62"\
      "\x01\x64\x01\x66\x01\x68\x01\x6a\x01\x6c\x01\x6e\x01\x70\x01\x72\x01\x74"\
      "\x01\x76\x01\x78\x01\x7a\x01\x7c\x01\x7e\x01\x80\x01\x82\x01\x84\x01\x86"\
      "\x01\x88\x01\x8a\x01\x8c\x01\x8e\x01\x90\x01\x92\x01\x94\x01\x96\x01\x98"\
      "\x01\x9a\x01\x9c\x00\x02\x00\x0a\x00\x0a\x00\x02\x00\x13\x00\x13\x00\x19"\
      "\x00\x19\x00\x23\x00\x23\x00\x26\x00\x26\x00\x33\x00\x33\x00\x41\x00\x41"\
      "\x00\x49\x00\x4a\x00\x5b\x00\x5b\x00\x09\x00\x02\x00\x04\x00\x04\x00\x1b"\
      "\x00\x1b\x00\x29\x00\x29\x00\x2d\x00\x2d\x00\x33\x00\x33\x00\x39\x00\x39"\
      "\x00\x5e\x00\x5e\x00\x05\x00\x02\x00\x14\x00\x14\x00\x18\x00\x18\x00\x46"\
      "\x00\x46\x00\x06\x00\x02\x00\x19\x00\x19\x00\x23\x00\x23\x00\x41\x00\x41"\
      "\x00\x49\x00\x49\x00\x0f\x00\x02\x00\x0d\x00\x0e\x00\x1f\x00\x1f\x00\x27"\
      "\x00\x27\x00\x2c\x00\x2c\x00\x34\x00\x34\x00\x3b\x00\x3b\x00\x3f\x00\x3f"\
      "\x00\x42\x00\x42\x00\x4d\x00\x4d\x00\x4f\x00\x4f\x00\x53\x00\x53\x00\x55"\
      "\x00\x55\x00\x5c\x00\x5c\x00\x15\x00\x02\x00\x03\x00\x05\x00\x0c\x00\x0c"\
      "\x00\x0f\x00\x0f\x00\x16\x00\x16\x00\x1b\x00\x1e\x00\x25\x00\x26\x00\x29"\
      "\x00\x29\x00\x2b\x00\x2b\x00\x2d\x00\x33\x00\x37\x00\x37\x00\x39\x00\x3a"\
      "\x00\x3d\x00\x3e\x00\x40\x00\x40\x00\x44\x00\x44\x00\x47\x00\x47\x00\x52"\
      "\x00\x52\x00\x54\x00\x54\x00\x56\x00\x59\x00\x5e\x00\x5f\x00\x0f\x00\x02"\
      "\x00\x06\x00\x0a\x00\x10\x00\x11\x00\x13\x00\x14\x00\x18\x00\x19\x00\x23"\
      "\x00\x23\x00\x28\x00\x28\x00\x3c\x00\x3c\x00\x41\x00\x41\x00\x46\x00\x46"\
      "\x00\x49\x00\x4a\x00\x51\x00\x51\x00\x5b\x00\x5b\x00\x5d\x00\x5d\x00\x03"\
      "\x00\x02\x00\x62\x00\x65\x07\x5e\x00\x02\x01\xa2\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x04\x01\xbc\x00\x03\x00\x02\x00\x02\x00\x02\x00\x06\x01\xbf"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x08\x01\xc7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x0a\x01\xe3\x00\x03\x00\x02\x00\x02\x00\x02\x00\x0c\x01\xe7"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x0e\x01\xe9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x10\x01\xef\x00\x03\x00\x02\x00\x02\x00\x02\x00\x12\x01\xf5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x14\x01\xf7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x16\x01\xfe\x00\x03\x00\x02\x00\x02\x00\x02\x00\x18\x02\x00"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x1a\x02\x08\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x1c\x02\x0e\x00\x03\x00\x02\x00\x02\x00\x02\x00\x1e\x02\x10"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x20\x02\x18\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x22\x02\x28\x00\x03\x00\x02\x00\x02\x00\x02\x00\x24\x02\x2a"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x26\x02\x2e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x28\x02\x39\x00\x03\x00\x02\x00\x02\x00\x02\x00\x2a\x02\x3c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x2c\x02\x3f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x2e\x02\x47\x00\x03\x00\x02\x00\x02\x00\x02\x00\x30\x02\x49"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x32\x02\x4c\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x34\x02\x52\x00\x03\x00\x02\x00\x02\x00\x02\x00\x36\x02\x54"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x38\x02\x58\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x3a\x02\x5c\x00\x03\x00\x02\x00\x02\x00\x02\x00\x3c\x02\x5e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x3e\x02\x62\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x40\x02\x6e\x00\x03\x00\x02\x00\x02\x00\x02\x00\x42\x02\x79"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x44\x02\x7b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x46\x02\x83\x00\x03\x00\x02\x00\x02\x00\x02\x00\x48\x02\x87"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x4a\x02\x91\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x4c\x02\x93\x00\x03\x00\x02\x00\x02\x00\x02\x00\x4e\x02\x97"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x50\x02\x9b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x52\x02\xa3\x00\x03\x00\x02\x00\x02\x00\x02\x00\x54\x02\xb3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x56\x02\xb5\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x58\x02\xb9\x00\x03\x00\x02\x00\x02\x00\x02\x00\x5a\x02\xbd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x5c\x02\xbf\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x5e\x02\xc6\x00\x03\x00\x02\x00\x02\x00\x02\x00\x60\x02\xce"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x62\x02\xd5\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x64\x02\xd9\x00\x03\x00\x02\x00\x02\x00\x02\x00\x66\x02\xdc"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x68\x02\xe4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x6a\x02\xec\x00\x03\x00\x02\x00\x02\x00\x02\x00\x6c\x02\xf0"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x6e\x03\x0d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x70\x03\x10\x00\x03\x00\x02\x00\x02\x00\x02\x00\x72\x03\x17"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x74\x03\x25\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x76\x03\x28\x00\x03\x00\x02\x00\x02\x00\x02\x00\x78\x03\x2e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x7a\x03\x36\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x7c\x03\x44\x00\x03\x00\x02\x00\x02\x00\x02\x00\x7e\x03\x47"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x80\x03\x4c\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x82\x03\x5c\x00\x03\x00\x02\x00\x02\x00\x02\x00\x84\x03\x5f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x86\x03\x68\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x88\x03\x70\x00\x03\x00\x02\x00\x02\x00\x02\x00\x8a\x03\x73"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x8c\x03\x76\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x8e\x03\x78\x00\x03\x00\x02\x00\x02\x00\x02\x00\x90\x03\x7b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x92\x03\x84\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x94\x03\x8d\x00\x03\x00\x02\x00\x02\x00\x02\x00\x96\x03\x8f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x98\x03\x93\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\x9a\x03\x99\x00\x03\x00\x02\x00\x02\x00\x02\x00\x9c\x03\x9b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\x9e\x03\xa8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xa0\x03\xaf\x00\x03\x00\x02\x00\x02\x00\x02\x00\xa2\x03\xd5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xa4\x03\xd9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xa6\x03\xdd\x00\x03\x00\x02\x00\x02\x00\x02\x00\xa8\x03\xdf"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xaa\x03\xea\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xac\x03\xec\x00\x03\x00\x02\x00\x02\x00\x02\x00\xae\x03\xf6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xb0\x03\xfc\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xb2\x03\xff\x00\x03\x00\x02\x00\x02\x00\x02\x00\xb4\x04\x09"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xb6\x04\x0b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xb8\x04\x0f\x00\x03\x00\x02\x00\x02\x00\x02\x00\xba\x04\x11"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xbc\x04\x13\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xbe\x04\x1f\x00\x03\x00\x02\x00\x02\x00\x02\x00\xc0\x04\x25"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xc2\x04\x28\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xc4\x04\x32\x00\x03\x00\x02\x00\x02\x00\x02\x00\xc6\x04\x34"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xc8\x04\x38\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xca\x04\x3c\x00\x03\x00\x02\x00\x02\x00\x02\x00\xcc\x04\x48"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xce\x04\x4a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xd0\x04\x51\x00\x03\x00\x02\x00\x02\x00\x02\x00\xd2\x04\x5d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xd4\x04\x5f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xd6\x04\x66\x00\x03\x00\x02\x00\x02\x00\x02\x00\xd8\x04\x6f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xda\x04\x71\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xdc\x04\x7c\x00\x03\x00\x02\x00\x02\x00\x02\x00\xde\x04\x7e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xe0\x04\x82\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xe2\x04\x87\x00\x03\x00\x02\x00\x02\x00\x02\x00\xe4\x04\x8e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xe6\x04\x94\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xe8\x04\x98\x00\x03\x00\x02\x00\x02\x00\x02\x00\xea\x04\x9f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xec\x04\xa7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xee\x04\xae\x00\x03\x00\x02\x00\x02\x00\x02\x00\xf0\x04\xb1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xf2\x04\xb6\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xf4\x04\xbd\x00\x03\x00\x02\x00\x02\x00\x02\x00\xf6\x04\xcf"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xf8\x04\xd2\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x00\xfa\x04\xd7\x00\x03\x00\x02\x00\x02\x00\x02\x00\xfc\x04\xe0"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xfe\x04\xe2\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x00\x04\xe8\x00\x03\x00\x02\x00\x02\x00\x02\x01\x02\x04\xee"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x04\x04\xf6\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x06\x04\xfb\x00\x03\x00\x02\x00\x02\x00\x02\x01\x08\x04\xfe"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x0a\x05\x00\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x0c\x05\x03\x00\x03\x00\x02\x00\x02\x00\x02\x01\x0e\x05\x17"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x10\x05\x21\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x12\x05\x23\x00\x03\x00\x02\x00\x02\x00\x02\x01\x14\x05\x29"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x16\x05\x2b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x18\x05\x31\x00\x03\x00\x02\x00\x02\x00\x02\x01\x1a\x05\x39"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x1c\x05\x3c\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x1e\x05\x45\x00\x03\x00\x02\x00\x02\x00\x02\x01\x20\x05\x47"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x22\x05\x4a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x24\x05\x4e\x00\x03\x00\x02\x00\x02\x00\x02\x01\x26\x05\x50"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x28\x05\x55\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x2a\x05\x57\x00\x03\x00\x02\x00\x02\x00\x02\x01\x2c\x05\x5e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x2e\x05\x63\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x30\x05\x7b\x00\x03\x00\x02\x00\x02\x00\x02\x01\x32\x05\x7d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x34\x05\x8b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x36\x05\xc2\x00\x03\x00\x02\x00\x02\x00\x02\x01\x38\x05\xc5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x3a\x05\xc7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x3c\x05\xd2\x00\x03\x00\x02\x00\x02\x00\x02\x01\x3e\x05\xd4"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x40\x05\xe1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x42\x05\xea\x00\x03\x00\x02\x00\x02\x00\x02\x01\x44\x05\xec"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x46\x05\xfa\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x48\x05\xfc\x00\x03\x00\x02\x00\x02\x00\x02\x01\x4a\x06\x05"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x4c\x06\x07\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x4e\x06\x0f\x00\x03\x00\x02\x00\x02\x00\x02\x01\x50\x06\x1f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x52\x06\x25\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x54\x06\x27\x00\x03\x00\x02\x00\x02\x00\x02\x01\x56\x06\x2b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x58\x06\x30\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x5a\x06\x34\x00\x03\x00\x02\x00\x02\x00\x02\x01\x5c\x06\x58"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x5e\x06\x5a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x60\x06\x5f\x00\x03\x00\x02\x00\x02\x00\x02\x01\x62\x06\x61"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x64\x06\x64\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x66\x06\x6f\x00\x03\x00\x02\x00\x02\x00\x02\x01\x68\x06\x76"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x6a\x06\x78\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x6c\x06\x7a\x00\x03\x00\x02\x00\x02\x00\x02\x01\x6e\x06\x7c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x70\x06\x7e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x72\x06\x80\x00\x03\x00\x02\x00\x02\x00\x02\x01\x74\x06\x86"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x76\x06\x9d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x78\x06\xae\x00\x03\x00\x02\x00\x02\x00\x02\x01\x7a\x06\xb0"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x7c\x06\xb2\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x7e\x06\xb8\x00\x03\x00\x02\x00\x02\x00\x02\x01\x80\x06\xc1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x82\x06\xd0\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x84\x06\xd2\x00\x03\x00\x02\x00\x02\x00\x02\x01\x86\x06\xd4"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x88\x06\xe0\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x8a\x06\xe2\x00\x03\x00\x02\x00\x02\x00\x02\x01\x8c\x06\xec"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x8e\x06\xee\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x90\x06\xf1\x00\x03\x00\x02\x00\x02\x00\x02\x01\x92\x06\xfb"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x94\x06\xfd\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x96\x06\xff\x00\x03\x00\x02\x00\x02\x00\x02\x01\x98\x07\x06"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\x9a\x07\x0b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\x9c\x07\x0d\x00\x03\x00\x02\x00\x02\x00\x02\x01\x9e\x01\xa1"\
      "\x00\x05\x00\x04\x00\x03\x00\x02\x01\x9f\x01\xa1\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x01\xa0\x01\x9e\x00\x03\x00\x02\x00\x02\x00\x02\x01\xa0\x01\x9f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xa1\x01\xa4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xa2\x01\xa0\x00\x03\x00\x02\x00\x02\x00\x02\x01\xa2\x01\xa3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xa3\x01\xa5\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xa4\x01\xa2\x00\x03\x00\x02\x00\x02\x00\x02\x01\xa5\x01\xa6"\
      "\x00\x07\x00\x02\x00\x02\x00\x03\x01\xa6\x00\x03\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xa7\x01\xa9\x00\x05\x01\x34\x00\x9b\x00\x02\x01\xa8\x01\xaa"\
      "\x00\x07\x00\x35\x00\x02\x00\x02\x01\xa9\x01\xa8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xa9\x01\xaa\x00\x03\x00\x02\x00\x02\x00\x02\x01\xaa\x01\xbd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xab\x01\xad\x00\x05\x00\x54\x00\x2b"\
      "\x00\x02\x01\xac\x01\xae\x00\x07\x00\x35\x00\x02\x00\x02\x01\xad\x01\xac"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xad\x01\xae\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xae\x01\xbd\x00\x03\x00\x02\x00\x02\x00\x02\x01\xaf\x01\xb1"\
      "\x00\x05\x00\x08\x00\x05\x00\x02\x01\xb0\x01\xb2\x00\x07\x00\x35\x00\x02"\
      "\x00\x02\x01\xb1\x01\xb0\x00\x03\x00\x02\x00\x02\x00\x02\x01\xb1\x01\xb2"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xb2\x01\xbd\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xb3\x01\xb5\x00\x05\x00\x16\x00\x0c\x00\x02\x01\xb4\x01\xb6"\
      "\x00\x07\x00\x35\x00\x02\x00\x02\x01\xb5\x01\xb4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xb5\x01\xb6\x00\x03\x00\x02\x00\x02\x00\x02\x01\xb6\x01\xbd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xb7\x01\xbd\x00\x05\x00\x2e\x00\x18"\
      "\x00\x02\x01\xb8\x01\xba\x00\x05\x00\x34\x00\x1b\x00\x02\x01\xb9\x01\xbb"\
      "\x00\x07\x00\x35\x00\x02\x00\x02\x01\xba\x01\xb9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xba\x01\xbb\x00\x03\x00\x02\x00\x02\x00\x02\x01\xbb\x01\xbd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xbc\x01\xa7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xbc\x01\xab\x00\x03\x00\x02\x00\x02\x00\x02\x01\xbc\x01\xaf"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xbc\x01\xb3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xbc\x01\xb7\x00\x03\x00\x02\x00\x02\x00\x02\x01\xbc\x01\xb8"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xbd\x00\x05\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xbe\x01\xc0\x00\x05\x00\x04\x00\x03\x00\x02\x01\xbf\x01\xbe"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xc0\x01\xc1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xc1\x01\xbf\x00\x03\x00\x02\x00\x02\x00\x02\x01\xc1\x01\xc2"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xc2\x00\x07\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xc3\x01\xc8\x00\x05\x00\x0a\x00\x06\x00\x02\x01\xc4\x01\xc8"\
      "\x00\x05\x00\x0e\x00\x08\x00\x02\x01\xc5\x01\xc8\x00\x05\x00\x10\x00\x09"\
      "\x00\x02\x01\xc6\x01\xc8\x00\x05\x00\x14\x00\x0b\x00\x02\x01\xc7\x01\xc3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xc7\x01\xc4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xc7\x01\xc5\x00\x03\x00\x02\x00\x02\x00\x02\x01\xc7\x01\xc6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xc8\x00\x09\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xc9\x01\xcb\x00\x07\x00\x0f\x00\x02\x00\x02\x01\xca\x01\xcc"\
      "\x00\x05\x00\x0c\x00\x07\x00\x02\x01\xcb\x01\xca\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xcb\x01\xcc\x00\x03\x00\x02\x00\x02\x00\x02\x01\xcc\x01\xcd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xcd\x01\xcf\x00\x07\x00\x35\x00\x02"\
      "\x00\x02\x01\xce\x01\xd0\x00\x05\x01\x34\x00\x9b\x00\x02\x01\xcf\x01\xce"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xcf\x01\xd0\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xd0\x01\xd1\x00\x03\x00\x02\x00\x02\x00\x02\x01\xd1\x01\xd3"\
      "\x00\x07\x00\x35\x00\x02\x00\x02\x01\xd2\x01\xd4\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x01\xd3\x01\xd2\x00\x03\x00\x02\x00\x02\x00\x02\x01\xd3\x01\xd4"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xd4\x01\xd5\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xd5\x01\xe4\x00\x05\x00\x5c\x00\x2f\x00\x02\x01\xd6\x01\xd8"\
      "\x00\x07\x00\x0f\x00\x02\x00\x02\x01\xd7\x01\xd9\x00\x05\x00\x0c\x00\x07"\
      "\x00\x02\x01\xd8\x01\xd7\x00\x03\x00\x02\x00\x02\x00\x02\x01\xd8\x01\xd9"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xd9\x01\xda\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xda\x01\xdc\x00\x07\x00\x35\x00\x02\x00\x02\x01\xdb\x01\xdd"\
      "\x00\x05\x01\x34\x00\x9b\x00\x02\x01\xdc\x01\xdb\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xdc\x01\xdd\x00\x03\x00\x02\x00\x02\x00\x02\x01\xdd\x01\xde"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xde\x01\xe0\x00\x07\x00\x35\x00\x02"\
      "\x00\x02\x01\xdf\x01\xe1\x00\x05\x01\x34\x00\x9b\x00\x02\x01\xe0\x01\xdf"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xe0\x01\xe1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xe1\x01\xe2\x00\x03\x00\x02\x00\x02\x00\x02\x01\xe2\x01\xe4"\
      "\x00\x05\x00\x5c\x00\x2f\x00\x02\x01\xe3\x01\xc9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xe3\x01\xd6\x00\x03\x00\x02\x00\x02\x00\x02\x01\xe4\x00\x0b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xe5\x01\xe8\x00\x05\x00\x6e\x00\x38"\
      "\x00\x02\x01\xe6\x01\xe8\x00\x05\x01\x32\x00\x9a\x00\x02\x01\xe7\x01\xe5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xe7\x01\xe6\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xe8\x00\x0d\x00\x03\x00\x02\x00\x02\x00\x02\x01\xe9\x01\xea"\
      "\x00\x07\x00\x0f\x00\x02\x00\x02\x01\xea\x01\xeb\x00\x05\x01\x0e\x00\x88"\
      "\x00\x02\x01\xeb\x01\xec\x00\x07\x00\x57\x00\x02\x00\x02\x01\xec\x01\xed"\
      "\x00\x05\x01\x34\x00\x9b\x00\x02\x01\xed\x01\xee\x00\x05\x00\x5c\x00\x2f"\
      "\x00\x02\x01\xee\x00\x0f\x00\x03\x00\x02\x00\x02\x00\x02\x01\xef\x01\xf0"\
      "\x00\x07\x00\x0c\x00\x02\x00\x02\x01\xf0\x01\xf1\x00\x05\x00\x12\x00\x0a"\
      "\x00\x02\x01\xf1\x01\xf2\x00\x05\x00\x5c\x00\x2f\x00\x02\x01\xf2\x00\x11"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xf3\x01\xf6\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x01\xf4\x01\xf6\x00\x05\x00\x54\x00\x2b\x00\x02\x01\xf5\x01\xf3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x01\xf5\x01\xf4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xf6\x00\x13\x00\x03\x00\x02\x00\x02\x00\x02\x01\xf7\x01\xf8"\
      "\x00\x07\x00\x16\x00\x02\x00\x02\x01\xf8\x01\xf9\x00\x05\x00\x5c\x00\x2f"\
      "\x00\x02\x01\xf9\x01\xfa\x00\x07\x00\x0c\x00\x02\x00\x02\x01\xfa\x01\xfb"\
      "\x00\x05\x00\x12\x00\x0a\x00\x02\x01\xfb\x00\x15\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xfc\x01\xff\x00\x05\x00\x18\x00\x0d\x00\x02\x01\xfd\x01\xff"\
      "\x00\x05\x00\x1e\x00\x10\x00\x02\x01\xfe\x01\xfc\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x01\xfe\x01\xfd\x00\x03\x00\x02\x00\x02\x00\x02\x01\xff\x00\x17"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x00\x02\x01\x00\x07\x00\x37\x00\x02"\
      "\x00\x02\x02\x01\x02\x02\x00\x05\x00\x1a\x00\x0e\x00\x02\x02\x02\x02\x04"\
      "\x00\x05\x00\x5c\x00\x2f\x00\x02\x02\x03\x02\x05\x00\x05\x00\x1c\x00\x0f"\
      "\x00\x02\x02\x04\x02\x03\x00\x03\x00\x02\x00\x02\x00\x02\x02\x04\x02\x05"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x05\x00\x19\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x06\x02\x09\x00\x05\x01\x34\x00\x9b\x00\x02\x02\x07\x02\x09"\
      "\x00\x05\x00\x54\x00\x2b\x00\x02\x02\x08\x02\x06\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x08\x02\x07\x00\x03\x00\x02\x00\x02\x00\x02\x02\x09\x00\x1b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x0a\x02\x0b\x00\x07\x00\x56\x00\x02"\
      "\x00\x02\x02\x0b\x02\x0f\x00\x05\x00\x5c\x00\x2f\x00\x02\x02\x0c\x02\x0d"\
      "\x00\x07\x00\x56\x00\x02\x00\x02\x02\x0d\x02\x0f\x00\x05\x00\x18\x00\x0d"\
      "\x00\x02\x02\x0e\x02\x0a\x00\x03\x00\x02\x00\x02\x00\x02\x02\x0e\x02\x0c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x0f\x00\x1d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x10\x02\x11\x00\x07\x00\x3e\x00\x02\x00\x02\x02\x11\x02\x12"\
      "\x00\x05\x01\x34\x00\x9b\x00\x02\x02\x12\x02\x14\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x02\x13\x02\x15\x00\x05\x00\x20\x00\x11\x00\x02\x02\x14\x02\x13"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x14\x02\x15\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x15\x02\x16\x00\x03\x00\x02\x00\x02\x00\x02\x02\x16\x02\x17"\
      "\x00\x07\x00\x36\x00\x02\x00\x02\x02\x17\x00\x1f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x18\x02\x1a\x00\x05\x00\x22\x00\x12\x00\x02\x02\x19\x02\x1b"\
      "\x00\x05\x00\x20\x00\x11\x00\x02\x02\x1a\x02\x19\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x1a\x02\x1b\x00\x03\x00\x02\x00\x02\x00\x02\x02\x1b\x00\x21"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x1c\x02\x1d\x00\x05\x00\x24\x00\x13"\
      "\x00\x02\x02\x1d\x02\x1e\x00\x05\x00\x06\x00\x04\x00\x02\x02\x1e\x02\x29"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x1f\x02\x20\x00\x05\x00\x28\x00\x15"\
      "\x00\x02\x02\x20\x02\x21\x00\x05\x00\x06\x00\x04\x00\x02\x02\x21\x02\x29"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x22\x02\x23\x00\x05\x00\x24\x00\x13"\
      "\x00\x02\x02\x23\x02\x24\x00\x07\x00\x35\x00\x02\x00\x02\x02\x24\x02\x29"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x25\x02\x26\x00\x05\x00\x28\x00\x15"\
      "\x00\x02\x02\x26\x02\x27\x00\x07\x00\x35\x00\x02\x00\x02\x02\x27\x02\x29"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x28\x02\x1c\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x28\x02\x1f\x00\x03\x00\x02\x00\x02\x00\x02\x02\x28\x02\x22"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x28\x02\x25\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x29\x00\x23\x00\x03\x00\x02\x00\x02\x00\x02\x02\x2a\x02\x2b"\
      "\x00\x07\x00\x44\x00\x02\x00\x02\x02\x2b\x02\x2c\x00\x05\x00\x26\x00\x14"\
      "\x00\x02\x02\x2c\x02\x2d\x00\x07\x00\x4b\x00\x02\x00\x02\x02\x2d\x00\x25"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x2e\x02\x30\x00\x05\x01\x0e\x00\x88"\
      "\x00\x02\x02\x2f\x02\x31\x00\x05\x00\x2a\x00\x16\x00\x02\x02\x30\x02\x2f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x30\x02\x31\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x31\x02\x32\x00\x03\x00\x02\x00\x02\x00\x02\x02\x32\x02\x34"\
      "\x00\x05\x01\x0e\x00\x88\x00\x02\x02\x33\x02\x35\x00\x05\x00\x2a\x00\x16"\
      "\x00\x02\x02\x34\x02\x33\x00\x03\x00\x02\x00\x02\x00\x02\x02\x34\x02\x35"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x35\x02\x36\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x36\x02\x37\x00\x07\x00\x17\x00\x02\x00\x02\x02\x37\x02\x38"\
      "\x00\x05\x00\x26\x00\x14\x00\x02\x02\x38\x00\x27\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x39\x02\x3a\x00\x07\x00\x03\x00\x02\x00\x02\x02\x3a\x02\x3b"\
      "\x00\x07\x00\x4b\x00\x02\x00\x02\x02\x3b\x00\x29\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x3c\x02\x3d\x00\x07\x00\x54\x00\x02\x00\x02\x02\x3d\x02\x3e"\
      "\x00\x05\x00\x2c\x00\x17\x00\x02\x02\x3e\x00\x2b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x3f\x02\x40\x00\x05\x01\x34\x00\x9b\x00\x02\x02\x40\x00\x2d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x41\x02\x42\x00\x05\x00\x30\x00\x19"\
      "\x00\x02\x02\x42\x02\x43\x00\x05\x00\x08\x00\x05\x00\x02\x02\x43\x02\x48"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x44\x02\x45\x00\x05\x00\x30\x00\x19"\
      "\x00\x02\x02\x45\x02\x46\x00\x05\x00\x1e\x00\x10\x00\x02\x02\x46\x02\x48"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x47\x02\x41\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x47\x02\x44\x00\x03\x00\x02\x00\x02\x00\x02\x02\x48\x00\x2f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x49\x02\x4a\x00\x05\x00\x32\x00\x1a"\
      "\x00\x02\x02\x4a\x02\x4b\x00\x07\x00\x4b\x00\x02\x00\x02\x02\x4b\x00\x31"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x4c\x02\x4d\x00\x05\x01\x92\x00\xca"\
      "\x00\x02\x02\x4d\x00\x33\x00\x03\x00\x02\x00\x02\x00\x02\x02\x4e\x02\x53"\
      "\x00\x05\x00\x36\x00\x1c\x00\x02\x02\x4f\x02\x53\x00\x05\x00\x38\x00\x1d"\
      "\x00\x02\x02\x50\x02\x53\x00\x05\x00\x3a\x00\x1e\x00\x02\x02\x51\x02\x53"\
      "\x00\x05\x00\x3c\x00\x1f\x00\x02\x02\x52\x02\x4e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x52\x02\x4f\x00\x03\x00\x02\x00\x02\x00\x02\x02\x52\x02\x50"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x52\x02\x51\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x53\x00\x35\x00\x03\x00\x02\x00\x02\x00\x02\x02\x54\x02\x56"\
      "\x00\x07\x00\x3a\x00\x02\x00\x02\x02\x55\x02\x57\x00\x05\x00\x32\x00\x1a"\
      "\x00\x02\x02\x56\x02\x55\x00\x03\x00\x02\x00\x02\x00\x02\x02\x56\x02\x57"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x57\x00\x37\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x58\x02\x5a\x00\x07\x00\x30\x00\x02\x00\x02\x02\x59\x02\x5b"\
      "\x00\x05\x00\x32\x00\x1a\x00\x02\x02\x5a\x02\x59\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x5a\x02\x5b\x00\x03\x00\x02\x00\x02\x00\x02\x02\x5b\x00\x39"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x5c\x02\x5d\x00\x07\x00\x52\x00\x02"\
      "\x00\x02\x02\x5d\x00\x3b\x00\x03\x00\x02\x00\x02\x00\x02\x02\x5e\x02\x60"\
      "\x00\x07\x00\x32\x00\x02\x00\x02\x02\x5f\x02\x61\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x02\x60\x02\x5f\x00\x03\x00\x02\x00\x02\x00\x02\x02\x60\x02\x61"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x61\x00\x3d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x62\x02\x63\x00\x07\x00\x1f\x00\x02\x00\x02\x02\x63\x02\x65"\
      "\x00\x05\x00\x40\x00\x21\x00\x02\x02\x64\x02\x66\x00\x05\x00\x44\x00\x23"\
      "\x00\x02\x02\x65\x02\x64\x00\x03\x00\x02\x00\x02\x00\x02\x02\x65\x02\x66"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x66\x02\x67\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x67\x02\x68\x00\x07\x00\x4f\x00\x02\x00\x02\x02\x68\x00\x3f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x69\x02\x6f\x00\x05\x00\x42\x00\x22"\
      "\x00\x02\x02\x6a\x02\x6b\x00\x05\x00\x42\x00\x22\x00\x02\x02\x6b\x02\x6c"\
      "\x00\x07\x00\x17\x00\x02\x00\x02\x02\x6c\x02\x6d\x00\x05\x00\x40\x00\x21"\
      "\x00\x02\x02\x6d\x02\x6f\x00\x03\x00\x02\x00\x02\x00\x02\x02\x6e\x02\x69"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x6e\x02\x6a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x6f\x00\x41\x00\x03\x00\x02\x00\x02\x00\x02\x02\x70\x02\x7a"\
      "\x00\x05\x01\x7a\x00\xbe\x00\x02\x02\x71\x02\x72\x00\x05\x01\x7a\x00\xbe"\
      "\x00\x02\x02\x72\x02\x73\x00\x07\x00\x4b\x00\x02\x00\x02\x02\x73\x02\x74"\
      "\x00\x05\x01\x78\x00\xbd\x00\x02\x02\x74\x02\x7a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x75\x02\x76\x00\x05\x01\x7a\x00\xbe\x00\x02\x02\x76\x02\x77"\
      "\x00\x07\x00\x4b\x00\x02\x00\x02\x02\x77\x02\x78\x00\x05\x01\x86\x00\xc4"\
      "\x00\x02\x02\x78\x02\x7a\x00\x03\x00\x02\x00\x02\x00\x02\x02\x79\x02\x70"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x79\x02\x71\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x79\x02\x75\x00\x03\x00\x02\x00\x02\x00\x02\x02\x7a\x00\x43"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x7b\x02\x7c\x00\x07\x00\x54\x00\x02"\
      "\x00\x02\x02\x7c\x02\x7d\x00\x05\x00\x46\x00\x24\x00\x02\x02\x7d\x00\x45"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x7e\x02\x84\x00\x05\x00\x48\x00\x25"\
      "\x00\x02\x02\x7f\x02\x80\x00\x05\x00\x48\x00\x25\x00\x02\x02\x80\x02\x81"\
      "\x00\x07\x00\x17\x00\x02\x00\x02\x02\x81\x02\x82\x00\x05\x00\x46\x00\x24"\
      "\x00\x02\x02\x82\x02\x84\x00\x03\x00\x02\x00\x02\x00\x02\x02\x83\x02\x7e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x83\x02\x7f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x84\x00\x47\x00\x03\x00\x02\x00\x02\x00\x02\x02\x85\x02\x88"\
      "\x00\x05\x00\x4a\x00\x26\x00\x02\x02\x86\x02\x88\x00\x05\x00\x4c\x00\x27"\
      "\x00\x02\x02\x87\x02\x85\x00\x03\x00\x02\x00\x02\x00\x02\x02\x87\x02\x86"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x88\x00\x49\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x89\x02\x8a\x00\x05\x01\x78\x00\xbd\x00\x02\x02\x8a\x02\x8b"\
      "\x00\x07\x00\x4b\x00\x02\x00\x02\x02\x8b\x02\x8c\x00\x05\x01\x78\x00\xbd"\
      "\x00\x02\x02\x8c\x02\x92\x00\x03\x00\x02\x00\x02\x00\x02\x02\x8d\x02\x8e"\
      "\x00\x05\x01\x78\x00\xbd\x00\x02\x02\x8e\x02\x8f\x00\x07\x00\x4b\x00\x02"\
      "\x00\x02\x02\x8f\x02\x90\x00\x05\x01\x86\x00\xc4\x00\x02\x02\x90\x02\x92"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x91\x02\x89\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x91\x02\x8d\x00\x03\x00\x02\x00\x02\x00\x02\x02\x92\x00\x4b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x93\x02\x94\x00\x05\x01\x78\x00\xbd"\
      "\x00\x02\x02\x94\x02\x95\x00\x07\x00\x4e\x00\x02\x00\x02\x02\x95\x02\x96"\
      "\x00\x05\x01\x78\x00\xbd\x00\x02\x02\x96\x00\x4d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\x97\x02\x98\x00\x07\x00\x1f\x00\x02\x00\x02\x02\x98\x02\x99"\
      "\x00\x05\x00\x50\x00\x29\x00\x02\x02\x99\x02\x9a\x00\x07\x00\x4f\x00\x02"\
      "\x00\x02\x02\x9a\x00\x4f\x00\x03\x00\x02\x00\x02\x00\x02\x02\x9b\x02\xa0"\
      "\x00\x05\x00\x52\x00\x2a\x00\x02\x02\x9c\x02\x9d\x00\x07\x00\x17\x00\x02"\
      "\x00\x02\x02\x9d\x02\x9f\x00\x05\x00\x52\x00\x2a\x00\x02\x02\x9e\x02\x9c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\x9f\x02\xa2\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xa0\x02\x9e\x00\x03\x00\x02\x00\x02\x00\x02\x02\xa0\x02\xa1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xa1\x00\x51\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xa2\x02\xa0\x00\x03\x00\x02\x00\x02\x00\x02\x02\xa3\x02\xa4"\
      "\x00\x05\x01\x74\x00\xbb\x00\x02\x02\xa4\x00\x53\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xa5\x02\xb4\x00\x05\x00\x5e\x00\x30\x00\x02\x02\xa6\x02\xb4"\
      "\x00\x05\x00\x66\x00\x34\x00\x02\x02\xa7\x02\xb4\x00\x05\x00\x6e\x00\x38"\
      "\x00\x02\x02\xa8\x02\xb4\x00\x05\x00\x88\x00\x45\x00\x02\x02\xa9\x02\xb4"\
      "\x00\x05\x00\x90\x00\x49\x00\x02\x02\xaa\x02\xb4\x00\x05\x00\xaa\x00\x56"\
      "\x00\x02\x02\xab\x02\xb4\x00\x05\x00\xca\x00\x66\x00\x02\x02\xac\x02\xb4"\
      "\x00\x05\x00\xd0\x00\x69\x00\x02\x02\xad\x02\xb4\x00\x05\x00\xd6\x00\x6c"\
      "\x00\x02\x02\xae\x02\xb4\x00\x05\x00\xea\x00\x76\x00\x02\x02\xaf\x02\xb4"\
      "\x00\x05\x00\xf0\x00\x79\x00\x02\x02\xb0\x02\xb4\x00\x05\x00\xf2\x00\x7a"\
      "\x00\x02\x02\xb1\x02\xb4\x00\x05\x00\xf6\x00\x7c\x00\x02\x02\xb2\x02\xb4"\
      "\x00\x05\x00\xfc\x00\x7f\x00\x02\x02\xb3\x02\xa5\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xb3\x02\xa6\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb3\x02\xa7"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb3\x02\xa8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xb3\x02\xa9\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb3\x02\xaa"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb3\x02\xab\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xb3\x02\xac\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb3\x02\xad"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb3\x02\xae\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xb3\x02\xaf\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb3\x02\xb0"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb3\x02\xb1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xb3\x02\xb2\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb4\x00\x55"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb5\x02\xb7\x00\x05\x00\x54\x00\x2b"\
      "\x00\x02\x02\xb6\x02\xb8\x00\x05\x00\x56\x00\x2c\x00\x02\x02\xb7\x02\xb6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb7\x02\xb8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xb8\x00\x57\x00\x03\x00\x02\x00\x02\x00\x02\x02\xb9\x02\xbb"\
      "\x00\x05\x00\x5a\x00\x2e\x00\x02\x02\xba\x02\xbc\x00\x05\x00\x58\x00\x2d"\
      "\x00\x02\x02\xbb\x02\xba\x00\x03\x00\x02\x00\x02\x00\x02\x02\xbb\x02\xbc"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xbc\x00\x59\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xbd\x02\xbe\x00\x09\x00\x02\x00\x02\x00\x02\x02\xbe\x00\x5b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xbf\x02\xc1\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x02\xc0\x02\xc2\x00\x05\x00\x06\x00\x04\x00\x02\x02\xc1\x02\xc0"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xc1\x02\xc2\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xc2\x02\xc3\x00\x03\x00\x02\x00\x02\x00\x02\x02\xc3\x02\xc4"\
      "\x00\x07\x00\x36\x00\x02\x00\x02\x02\xc4\x00\x5d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xc5\x02\xc7\x00\x05\x01\x2c\x00\x97\x00\x02\x02\xc6\x02\xc5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xc6\x02\xc7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xc7\x02\xc8\x00\x03\x00\x02\x00\x02\x00\x02\x02\xc8\x02\xca"\
      "\x00\x07\x00\x5f\x00\x02\x00\x02\x02\xc9\x02\xcb\x00\x05\x00\x60\x00\x31"\
      "\x00\x02\x02\xca\x02\xc9\x00\x03\x00\x02\x00\x02\x00\x02\x02\xca\x02\xcb"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xcb\x02\xcc\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xcc\x02\xcd\x00\x05\x00\x62\x00\x32\x00\x02\x02\xcd\x00\x5f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xce\x02\xcf\x00\x09\x00\x03\x00\x02"\
      "\x00\x02\x02\xcf\x00\x61\x00\x03\x00\x02\x00\x02\x00\x02\x02\xd0\x02\xd6"\
      "\x00\x05\x00\x64\x00\x33\x00\x02\x02\xd1\x02\xd2\x00\x05\x00\x64\x00\x33"\
      "\x00\x02\x02\xd2\x02\xd3\x00\x07\x00\x42\x00\x02\x00\x02\x02\xd3\x02\xd4"\
      "\x00\x05\x00\x62\x00\x32\x00\x02\x02\xd4\x02\xd6\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xd5\x02\xd0\x00\x03\x00\x02\x00\x02\x00\x02\x02\xd5\x02\xd1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xd6\x00\x63\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xd7\x02\xda\x00\x05\x01\x92\x00\xca\x00\x02\x02\xd8\x02\xda"\
      "\x00\x05\x01\x6c\x00\xb7\x00\x02\x02\xd9\x02\xd7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xd9\x02\xd8\x00\x03\x00\x02\x00\x02\x00\x02\x02\xda\x00\x65"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xdb\x02\xdd\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x02\xdc\x02\xdb\x00\x03\x00\x02\x00\x02\x00\x02\x02\xdc\x02\xdd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xdd\x02\xdf\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xde\x02\xe0\x00\x05\x00\x58\x00\x2d\x00\x02\x02\xdf\x02\xde"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xdf\x02\xe0\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xe0\x02\xe1\x00\x03\x00\x02\x00\x02\x00\x02\x02\xe1\x02\xe2"\
      "\x00\x07\x00\x25\x00\x02\x00\x02\x02\xe2\x02\xe3\x00\x05\x00\x68\x00\x35"\
      "\x00\x02\x02\xe3\x00\x67\x00\x03\x00\x02\x00\x02\x00\x02\x02\xe4\x02\xe9"\
      "\x00\x05\x00\x6a\x00\x36\x00\x02\x02\xe5\x02\xe6\x00\x07\x00\x17\x00\x02"\
      "\x00\x02\x02\xe6\x02\xe8\x00\x05\x00\x6a\x00\x36\x00\x02\x02\xe7\x02\xe5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xe8\x02\xeb\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xe9\x02\xe7\x00\x03\x00\x02\x00\x02\x00\x02\x02\xe9\x02\xea"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xea\x00\x69\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xeb\x02\xe9\x00\x03\x00\x02\x00\x02\x00\x02\x02\xec\x02\xee"\
      "\x00\x05\x01\x0e\x00\x88\x00\x02\x02\xed\x02\xef\x00\x05\x00\x6c\x00\x37"\
      "\x00\x02\x02\xee\x02\xed\x00\x03\x00\x02\x00\x02\x00\x02\x02\xee\x02\xef"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xef\x00\x6b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xf0\x02\xf1\x00\x07\x00\x0d\x00\x02\x00\x02\x02\xf1\x02\xf2"\
      "\x00\x05\x01\x34\x00\x9b\x00\x02\x02\xf2\x00\x6d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xf3\x02\xf4\x00\x05\x00\x70\x00\x39\x00\x02\x02\xf4\x02\xf5"\
      "\x00\x05\x00\x68\x00\x35\x00\x02\x02\xf5\x03\x0e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x02\xf6\x02\xf7\x00\x05\x00\x70\x00\x39\x00\x02\x02\xf7\x02\xf8"\
      "\x00\x05\x00\x72\x00\x3a\x00\x02\x02\xf8\x02\xf9\x00\x05\x01\x76\x00\xbc"\
      "\x00\x02\x02\xf9\x02\xfa\x00\x05\x00\x5c\x00\x2f\x00\x02\x02\xfa\x03\x0e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x02\xfb\x02\xfc\x00\x05\x00\x70\x00\x39"\
      "\x00\x02\x02\xfc\x02\xfd\x00\x05\x00\x72\x00\x3a\x00\x02\x02\xfd\x02\xfe"\
      "\x00\x05\x01\x76\x00\xbc\x00\x02\x02\xfe\x02\xff\x00\x05\x00\x74\x00\x3b"\
      "\x00\x02\x02\xff\x03\x0e\x00\x03\x00\x02\x00\x02\x00\x02\x03\x00\x03\x01"\
      "\x00\x05\x00\x70\x00\x39\x00\x02\x03\x01\x03\x02\x00\x05\x00\x72\x00\x3a"\
      "\x00\x02\x03\x02\x03\x03\x00\x05\x01\x76\x00\xbc\x00\x02\x03\x03\x03\x04"\
      "\x00\x05\x00\x7c\x00\x3f\x00\x02\x03\x04\x03\x0e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x05\x03\x06\x00\x05\x00\x70\x00\x39\x00\x02\x03\x06\x03\x07"\
      "\x00\x05\x00\x72\x00\x3a\x00\x02\x03\x07\x03\x09\x00\x05\x01\x76\x00\xbc"\
      "\x00\x02\x03\x08\x03\x0a\x00\x05\x00\x6c\x00\x37\x00\x02\x03\x09\x03\x08"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x09\x03\x0a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x0a\x03\x0b\x00\x03\x00\x02\x00\x02\x00\x02\x03\x0b\x03\x0c"\
      "\x00\x05\x00\x82\x00\x42\x00\x02\x03\x0c\x03\x0e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x0d\x02\xf3\x00\x03\x00\x02\x00\x02\x00\x02\x03\x0d\x02\xf6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x0d\x02\xfb\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x0d\x03\x00\x00\x03\x00\x02\x00\x02\x00\x02\x03\x0d\x03\x05"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x0e\x00\x6f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x0f\x03\x11\x00\x05\x01\x2c\x00\x97\x00\x02\x03\x10\x03\x0f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x10\x03\x11\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x11\x03\x13\x00\x03\x00\x02\x00\x02\x00\x02\x03\x12\x03\x14"\
      "\x00\x05\x00\x58\x00\x2d\x00\x02\x03\x13\x03\x12\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x13\x03\x14\x00\x03\x00\x02\x00\x02\x00\x02\x03\x14\x03\x15"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x15\x03\x16\x00\x07\x00\x1b\x00\x02"\
      "\x00\x02\x03\x16\x00\x71\x00\x03\x00\x02\x00\x02\x00\x02\x03\x17\x03\x18"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x03\x18\x00\x73\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x19\x03\x1a\x00\x07\x00\x0b\x00\x02\x00\x02\x03\x1a\x03\x1c"\
      "\x00\x05\x00\x76\x00\x3c\x00\x02\x03\x1b\x03\x1d\x00\x05\x00\x78\x00\x3d"\
      "\x00\x02\x03\x1c\x03\x1b\x00\x03\x00\x02\x00\x02\x00\x02\x03\x1c\x03\x1d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x1d\x03\x1e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x1e\x03\x1f\x00\x07\x00\x36\x00\x02\x00\x02\x03\x1f\x03\x26"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x20\x03\x21\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x03\x21\x03\x22\x00\x05\x00\x78\x00\x3d\x00\x02\x03\x22\x03\x23"\
      "\x00\x05\x00\x76\x00\x3c\x00\x02\x03\x23\x03\x24\x00\x07\x00\x36\x00\x02"\
      "\x00\x02\x03\x24\x03\x26\x00\x03\x00\x02\x00\x02\x00\x02\x03\x25\x03\x19"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x25\x03\x20\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x26\x00\x75\x00\x03\x00\x02\x00\x02\x00\x02\x03\x27\x03\x29"\
      "\x00\x05\x01\x2c\x00\x97\x00\x02\x03\x28\x03\x27\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x28\x03\x29\x00\x03\x00\x02\x00\x02\x00\x02\x03\x29\x03\x2a"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x2a\x03\x2b\x00\x07\x00\x11\x00\x02"\
      "\x00\x02\x03\x2b\x03\x2c\x00\x05\x00\x5c\x00\x2f\x00\x02\x03\x2c\x00\x77"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x2d\x03\x2f\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x03\x2e\x03\x2d\x00\x03\x00\x02\x00\x02\x00\x02\x03\x2e\x03\x2f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x2f\x03\x30\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x30\x03\x32\x00\x07\x00\x08\x00\x02\x00\x02\x03\x31\x03\x33"\
      "\x00\x05\x00\x7a\x00\x3e\x00\x02\x03\x32\x03\x31\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x32\x03\x33\x00\x03\x00\x02\x00\x02\x00\x02\x03\x33\x03\x34"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x34\x03\x35\x00\x05\x00\x5c\x00\x2f"\
      "\x00\x02\x03\x35\x00\x79\x00\x03\x00\x02\x00\x02\x00\x02\x03\x36\x03\x37"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x03\x37\x00\x7b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x38\x03\x39\x00\x07\x00\x0b\x00\x02\x00\x02\x03\x39\x03\x3b"\
      "\x00\x05\x00\x7e\x00\x40\x00\x02\x03\x3a\x03\x3c\x00\x05\x00\x80\x00\x41"\
      "\x00\x02\x03\x3b\x03\x3a\x00\x03\x00\x02\x00\x02\x00\x02\x03\x3b\x03\x3c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x3c\x03\x3d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x3d\x03\x3e\x00\x07\x00\x36\x00\x02\x00\x02\x03\x3e\x03\x45"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x3f\x03\x40\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x03\x40\x03\x41\x00\x05\x00\x80\x00\x41\x00\x02\x03\x41\x03\x42"\
      "\x00\x05\x00\x7e\x00\x40\x00\x02\x03\x42\x03\x43\x00\x07\x00\x36\x00\x02"\
      "\x00\x02\x03\x43\x03\x45\x00\x03\x00\x02\x00\x02\x00\x02\x03\x44\x03\x38"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x44\x03\x3f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x45\x00\x7d\x00\x03\x00\x02\x00\x02\x00\x02\x03\x46\x03\x48"\
      "\x00\x05\x01\x2c\x00\x97\x00\x02\x03\x47\x03\x46\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x47\x03\x48\x00\x03\x00\x02\x00\x02\x00\x02\x03\x48\x03\x49"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x49\x03\x4a\x00\x07\x00\x11\x00\x02"\
      "\x00\x02\x03\x4a\x00\x7f\x00\x03\x00\x02\x00\x02\x00\x02\x03\x4b\x03\x4d"\
      "\x00\x05\x01\x2c\x00\x97\x00\x02\x03\x4c\x03\x4b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x4c\x03\x4d\x00\x03\x00\x02\x00\x02\x00\x02\x03\x4d\x03\x4e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x4e\x03\x4f\x00\x07\x00\x08\x00\x02"\
      "\x00\x02\x03\x4f\x00\x81\x00\x03\x00\x02\x00\x02\x00\x02\x03\x50\x03\x51"\
      "\x00\x07\x00\x0b\x00\x02\x00\x02\x03\x51\x03\x53\x00\x05\x00\x84\x00\x43"\
      "\x00\x02\x03\x52\x03\x54\x00\x05\x00\x86\x00\x44\x00\x02\x03\x53\x03\x52"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x53\x03\x54\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x54\x03\x55\x00\x03\x00\x02\x00\x02\x00\x02\x03\x55\x03\x56"\
      "\x00\x07\x00\x36\x00\x02\x00\x02\x03\x56\x03\x5d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x57\x03\x58\x00\x07\x00\x0b\x00\x02\x00\x02\x03\x58\x03\x59"\
      "\x00\x05\x00\x86\x00\x44\x00\x02\x03\x59\x03\x5a\x00\x05\x00\x84\x00\x43"\
      "\x00\x02\x03\x5a\x03\x5b\x00\x07\x00\x36\x00\x02\x00\x02\x03\x5b\x03\x5d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x5c\x03\x50\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x5c\x03\x57\x00\x03\x00\x02\x00\x02\x00\x02\x03\x5d\x00\x83"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x5e\x03\x60\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x03\x5f\x03\x5e\x00\x03\x00\x02\x00\x02\x00\x02\x03\x5f\x03\x60"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x60\x03\x61\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x61\x03\x63\x00\x07\x00\x0a\x00\x02\x00\x02\x03\x62\x03\x64"\
      "\x00\x05\x00\x7a\x00\x3e\x00\x02\x03\x63\x03\x62\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x63\x03\x64\x00\x03\x00\x02\x00\x02\x00\x02\x03\x64\x03\x65"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x65\x03\x66\x00\x05\x00\x5c\x00\x2f"\
      "\x00\x02\x03\x66\x00\x85\x00\x03\x00\x02\x00\x02\x00\x02\x03\x67\x03\x69"\
      "\x00\x05\x01\x2c\x00\x97\x00\x02\x03\x68\x03\x67\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x68\x03\x69\x00\x03\x00\x02\x00\x02\x00\x02\x03\x69\x03\x6a"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x6a\x03\x6c\x00\x07\x00\x51\x00\x02"\
      "\x00\x02\x03\x6b\x03\x6d\x00\x05\x00\x7a\x00\x3e\x00\x02\x03\x6c\x03\x6b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x6c\x03\x6d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x6d\x03\x6e\x00\x03\x00\x02\x00\x02\x00\x02\x03\x6e\x03\x6f"\
      "\x00\x05\x00\x5c\x00\x2f\x00\x02\x03\x6f\x00\x87\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x70\x03\x71\x00\x05\x00\x8a\x00\x46\x00\x02\x03\x71\x03\x72"\
      "\x00\x05\x00\x8e\x00\x48\x00\x02\x03\x72\x00\x89\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x73\x03\x74\x00\x07\x00\x5e\x00\x02\x00\x02\x03\x74\x03\x75"\
      "\x00\x05\x00\x8c\x00\x47\x00\x02\x03\x75\x00\x8b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x76\x03\x77\x00\x05\x01\x92\x00\xca\x00\x02\x03\x77\x00\x8d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x78\x03\x79\x00\x07\x00\x0d\x00\x02"\
      "\x00\x02\x03\x79\x03\x7a\x00\x05\x01\x74\x00\xbb\x00\x02\x03\x7a\x00\x8f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x7b\x03\x7c\x00\x05\x00\x92\x00\x4a"\
      "\x00\x02\x03\x7c\x03\x7e\x00\x05\x00\x94\x00\x4b\x00\x02\x03\x7d\x03\x7f"\
      "\x00\x05\x00\x3e\x00\x20\x00\x02\x03\x7e\x03\x7d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x7e\x03\x7f\x00\x03\x00\x02\x00\x02\x00\x02\x03\x7f\x03\x80"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x80\x03\x81\x00\x05\x00\x96\x00\x4c"\
      "\x00\x02\x03\x81\x03\x82\x00\x05\x00\x9a\x00\x4e\x00\x02\x03\x82\x00\x91"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x83\x03\x85\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x03\x84\x03\x83\x00\x03\x00\x02\x00\x02\x00\x02\x03\x84\x03\x85"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x85\x03\x87\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x86\x03\x88\x00\x05\x00\x58\x00\x2d\x00\x02\x03\x87\x03\x86"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x87\x03\x88\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x88\x03\x89\x00\x03\x00\x02\x00\x02\x00\x02\x03\x89\x03\x8a"\
      "\x00\x07\x00\x04\x00\x02\x00\x02\x03\x8a\x00\x93\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x8b\x03\x8e\x00\x05\x01\x92\x00\xca\x00\x02\x03\x8c\x03\x8e"\
      "\x00\x05\x01\x6c\x00\xb7\x00\x02\x03\x8d\x03\x8b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x8d\x03\x8c\x00\x03\x00\x02\x00\x02\x00\x02\x03\x8e\x00\x95"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x8f\x03\x91\x00\x05\x00\x9c\x00\x4f"\
      "\x00\x02\x03\x90\x03\x92\x00\x05\x00\x98\x00\x4d\x00\x02\x03\x91\x03\x90"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x91\x03\x92\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x92\x00\x97\x00\x03\x00\x02\x00\x02\x00\x02\x03\x93\x03\x95"\
      "\x00\x07\x00\x43\x00\x02\x00\x02\x03\x94\x03\x96\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x03\x95\x03\x94\x00\x03\x00\x02\x00\x02\x00\x02\x03\x95\x03\x96"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x96\x03\x97\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x97\x03\x98\x00\x05\x01\x74\x00\xbb\x00\x02\x03\x98\x00\x99"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x99\x03\x9a\x00\x05\x00\x5c\x00\x2f"\
      "\x00\x02\x03\x9a\x00\x9b\x00\x03\x00\x02\x00\x02\x00\x02\x03\x9b\x03\x9d"\
      "\x00\x05\x00\x9e\x00\x50\x00\x02\x03\x9c\x03\x9e\x00\x05\x00\x9c\x00\x4f"\
      "\x00\x02\x03\x9d\x03\x9c\x00\x03\x00\x02\x00\x02\x00\x02\x03\x9d\x03\x9e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\x9e\x00\x9d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\x9f\x03\xa0\x00\x07\x00\x15\x00\x02\x00\x02\x03\xa0\x03\xa9"\
      "\x00\x07\x00\x5a\x00\x02\x00\x02\x03\xa1\x03\xa2\x00\x07\x00\x15\x00\x02"\
      "\x00\x02\x03\xa2\x03\xa4\x00\x05\x00\xa0\x00\x51\x00\x02\x03\xa3\x03\xa5"\
      "\x00\x07\x00\x45\x00\x02\x00\x02\x03\xa4\x03\xa3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xa4\x03\xa5\x00\x03\x00\x02\x00\x02\x00\x02\x03\xa5\x03\xa6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xa6\x03\xa7\x00\x07\x00\x5a\x00\x02"\
      "\x00\x02\x03\xa7\x03\xa9\x00\x03\x00\x02\x00\x02\x00\x02\x03\xa8\x03\x9f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xa8\x03\xa1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xa9\x00\x9f\x00\x03\x00\x02\x00\x02\x00\x02\x03\xaa\x03\xb0"\
      "\x00\x05\x00\xa2\x00\x52\x00\x02\x03\xab\x03\xac\x00\x05\x00\xa2\x00\x52"\
      "\x00\x02\x03\xac\x03\xad\x00\x07\x00\x17\x00\x02\x00\x02\x03\xad\x03\xae"\
      "\x00\x05\x00\xa0\x00\x51\x00\x02\x03\xae\x03\xb0\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xaf\x03\xaa\x00\x03\x00\x02\x00\x02\x00\x02\x03\xaf\x03\xab"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xb0\x00\xa1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xb1\x03\xb3\x00\x07\x00\x3c\x00\x02\x00\x02\x03\xb2\x03\xb1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xb2\x03\xb3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xb3\x03\xb5\x00\x03\x00\x02\x00\x02\x00\x02\x03\xb4\x03\xb6"\
      "\x00\x07\x00\x25\x00\x02\x00\x02\x03\xb5\x03\xb4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xb5\x03\xb6\x00\x03\x00\x02\x00\x02\x00\x02\x03\xb6\x03\xb8"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xb7\x03\xb9\x00\x07\x00\x24\x00\x02"\
      "\x00\x02\x03\xb8\x03\xb7\x00\x03\x00\x02\x00\x02\x00\x02\x03\xb8\x03\xb9"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xb9\x03\xba\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xba\x03\xbc\x00\x05\x00\xa4\x00\x53\x00\x02\x03\xbb\x03\xbd"\
      "\x00\x05\x00\xa6\x00\x54\x00\x02\x03\xbc\x03\xbb\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xbc\x03\xbd\x00\x03\x00\x02\x00\x02\x00\x02\x03\xbd\x03\xbe"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xbe\x03\xc0\x00\x05\x01\x76\x00\xbc"\
      "\x00\x02\x03\xbf\x03\xc1\x00\x05\x00\xa8\x00\x55\x00\x02\x03\xc0\x03\xbf"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xc0\x03\xc1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xc1\x03\xd6\x00\x03\x00\x02\x00\x02\x00\x02\x03\xc2\x03\xc4"\
      "\x00\x07\x00\x3c\x00\x02\x00\x02\x03\xc3\x03\xc2\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xc3\x03\xc4\x00\x03\x00\x02\x00\x02\x00\x02\x03\xc4\x03\xc5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xc5\x03\xc7\x00\x07\x00\x1b\x00\x02"\
      "\x00\x02\x03\xc6\x03\xc8\x00\x07\x00\x24\x00\x02\x00\x02\x03\xc7\x03\xc6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xc7\x03\xc8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xc8\x03\xc9\x00\x03\x00\x02\x00\x02\x00\x02\x03\xc9\x03\xcb"\
      "\x00\x05\x00\xa4\x00\x53\x00\x02\x03\xca\x03\xcc\x00\x05\x00\xa6\x00\x54"\
      "\x00\x02\x03\xcb\x03\xca\x00\x03\x00\x02\x00\x02\x00\x02\x03\xcb\x03\xcc"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xcc\x03\xcd\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xcd\x03\xcf\x00\x05\x01\x76\x00\xbc\x00\x02\x03\xce\x03\xd0"\
      "\x00\x05\x00\xa8\x00\x55\x00\x02\x03\xcf\x03\xce\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xcf\x03\xd0\x00\x03\x00\x02\x00\x02\x00\x02\x03\xd0\x03\xd6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xd1\x03\xd3\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x03\xd2\x03\xd1\x00\x03\x00\x02\x00\x02\x00\x02\x03\xd2\x03\xd3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xd3\x03\xd4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xd4\x03\xd6\x00\x05\x01\x74\x00\xbb\x00\x02\x03\xd5\x03\xb2"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xd5\x03\xc3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xd5\x03\xd2\x00\x03\x00\x02\x00\x02\x00\x02\x03\xd6\x00\xa3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xd7\x03\xda\x00\x05\x01\x92\x00\xca"\
      "\x00\x02\x03\xd8\x03\xda\x00\x07\x00\x50\x00\x02\x00\x02\x03\xd9\x03\xd7"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xd9\x03\xd8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xda\x00\xa5\x00\x03\x00\x02\x00\x02\x00\x02\x03\xdb\x03\xde"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x03\xdc\x03\xde\x00\x07\x00\x50\x00\x02"\
      "\x00\x02\x03\xdd\x03\xdb\x00\x03\x00\x02\x00\x02\x00\x02\x03\xdd\x03\xdc"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xde\x00\xa7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xdf\x03\xe0\x00\x07\x00\x0d\x00\x02\x00\x02\x03\xe0\x03\xe1"\
      "\x00\x05\x01\x34\x00\x9b\x00\x02\x03\xe1\x00\xa9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xe2\x03\xe4\x00\x05\x01\x2c\x00\x97\x00\x02\x03\xe3\x03\xe2"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xe3\x03\xe4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xe4\x03\xe5\x00\x03\x00\x02\x00\x02\x00\x02\x03\xe5\x03\xeb"\
      "\x00\x05\x00\xac\x00\x57\x00\x02\x03\xe6\x03\xe8\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x03\xe7\x03\xe6\x00\x03\x00\x02\x00\x02\x00\x02\x03\xe7\x03\xe8"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xe8\x03\xe9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xe9\x03\xeb\x00\x05\x00\xbc\x00\x5f\x00\x02\x03\xea\x03\xe3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xea\x03\xe7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xeb\x00\xab\x00\x03\x00\x02\x00\x02\x00\x02\x03\xec\x03\xee"\
      "\x00\x05\x00\xb8\x00\x5d\x00\x02\x03\xed\x03\xef\x00\x05\x00\x3e\x00\x20"\
      "\x00\x02\x03\xee\x03\xed\x00\x03\x00\x02\x00\x02\x00\x02\x03\xee\x03\xef"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xef\x03\xf0\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xf0\x03\xf2\x00\x07\x00\x0b\x00\x02\x00\x02\x03\xf1\x03\xf3"\
      "\x00\x05\x00\xae\x00\x58\x00\x02\x03\xf2\x03\xf1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xf2\x03\xf3\x00\x03\x00\x02\x00\x02\x00\x02\x03\xf3\x03\xf4"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xf4\x03\xf5\x00\x07\x00\x36\x00\x02"\
      "\x00\x02\x03\xf5\x00\xad\x00\x03\x00\x02\x00\x02\x00\x02\x03\xf6\x03\xf8"\
      "\x00\x05\x00\xb0\x00\x59\x00\x02\x03\xf7\x03\xf9\x00\x05\x00\xae\x00\x58"\
      "\x00\x02\x03\xf8\x03\xf7\x00\x03\x00\x02\x00\x02\x00\x02\x03\xf8\x03\xf9"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xf9\x00\xaf\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xfa\x03\xfd\x00\x05\x00\x54\x00\x2b\x00\x02\x03\xfb\x03\xfd"\
      "\x00\x05\x00\xb2\x00\x5a\x00\x02\x03\xfc\x03\xfa\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x03\xfc\x03\xfb\x00\x03\x00\x02\x00\x02\x00\x02\x03\xfd\x00\xb1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x03\xfe\x04\x00\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x03\xff\x03\xfe\x00\x03\x00\x02\x00\x02\x00\x02\x03\xff\x04\x00"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x00\x04\x01\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x01\x04\x02\x00\x07\x00\x44\x00\x02\x00\x02\x04\x02\x04\x03"\
      "\x00\x05\x00\xb4\x00\x5b\x00\x02\x04\x03\x00\xb3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x04\x04\x0a\x00\x05\x00\xb6\x00\x5c\x00\x02\x04\x05\x04\x06"\
      "\x00\x05\x00\xb6\x00\x5c\x00\x02\x04\x06\x04\x07\x00\x07\x00\x17\x00\x02"\
      "\x00\x02\x04\x07\x04\x08\x00\x05\x00\xb4\x00\x5b\x00\x02\x04\x08\x04\x0a"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x09\x04\x04\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x09\x04\x05\x00\x03\x00\x02\x00\x02\x00\x02\x04\x0a\x00\xb5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x0b\x04\x0d\x00\x05\x00\xba\x00\x5e"\
      "\x00\x02\x04\x0c\x04\x0e\x00\x05\x01\x7c\x00\xbf\x00\x02\x04\x0d\x04\x0c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x0d\x04\x0e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x0e\x00\xb7\x00\x03\x00\x02\x00\x02\x00\x02\x04\x0f\x04\x10"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x04\x10\x00\xb9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x11\x04\x12\x00\x05\x01\x92\x00\xca\x00\x02\x04\x12\x00\xbb"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x13\x04\x15\x00\x05\x00\xb8\x00\x5d"\
      "\x00\x02\x04\x14\x04\x16\x00\x05\x00\x3e\x00\x20\x00\x02\x04\x15\x04\x14"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x15\x04\x16\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x16\x04\x17\x00\x03\x00\x02\x00\x02\x00\x02\x04\x17\x04\x18"\
      "\x00\x07\x00\x4b\x00\x02\x00\x02\x04\x18\x04\x19\x00\x05\x01\x78\x00\xbd"\
      "\x00\x02\x04\x19\x04\x1b\x00\x07\x00\x0b\x00\x02\x00\x02\x04\x1a\x04\x1c"\
      "\x00\x05\x00\xbe\x00\x60\x00\x02\x04\x1b\x04\x1a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x1b\x04\x1c\x00\x03\x00\x02\x00\x02\x00\x02\x04\x1c\x04\x1d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x1d\x04\x1e\x00\x07\x00\x36\x00\x02"\
      "\x00\x02\x04\x1e\x00\xbd\x00\x03\x00\x02\x00\x02\x00\x02\x04\x1f\x04\x21"\
      "\x00\x05\x00\xc0\x00\x61\x00\x02\x04\x20\x04\x22\x00\x05\x00\xbe\x00\x60"\
      "\x00\x02\x04\x21\x04\x20\x00\x03\x00\x02\x00\x02\x00\x02\x04\x21\x04\x22"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x22\x00\xbf\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x23\x04\x26\x00\x05\x00\x54\x00\x2b\x00\x02\x04\x24\x04\x26"\
      "\x00\x05\x00\xc2\x00\x62\x00\x02\x04\x25\x04\x23\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x25\x04\x24\x00\x03\x00\x02\x00\x02\x00\x02\x04\x26\x00\xc1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x27\x04\x29\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x04\x28\x04\x27\x00\x03\x00\x02\x00\x02\x00\x02\x04\x28\x04\x29"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x29\x04\x2a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x2a\x04\x2b\x00\x07\x00\x44\x00\x02\x00\x02\x04\x2b\x04\x2c"\
      "\x00\x05\x00\xc4\x00\x63\x00\x02\x04\x2c\x00\xc3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x2d\x04\x33\x00\x05\x00\xc6\x00\x64\x00\x02\x04\x2e\x04\x2f"\
      "\x00\x05\x00\xc6\x00\x64\x00\x02\x04\x2f\x04\x30\x00\x07\x00\x17\x00\x02"\
      "\x00\x02\x04\x30\x04\x31\x00\x05\x00\xc4\x00\x63\x00\x02\x04\x31\x04\x33"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x32\x04\x2d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x32\x04\x2e\x00\x03\x00\x02\x00\x02\x00\x02\x04\x33\x00\xc5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x34\x04\x36\x00\x05\x00\xba\x00\x5e"\
      "\x00\x02\x04\x35\x04\x37\x00\x05\x00\xc8\x00\x65\x00\x02\x04\x36\x04\x35"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x36\x04\x37\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x37\x00\xc7\x00\x03\x00\x02\x00\x02\x00\x02\x04\x38\x04\x39"\
      "\x00\x07\x00\x0d\x00\x02\x00\x02\x04\x39\x04\x3a\x00\x05\x01\x9a\x00\xce"\
      "\x00\x02\x04\x3a\x00\xc9\x00\x03\x00\x02\x00\x02\x00\x02\x04\x3b\x04\x3d"\
      "\x00\x05\x01\x2c\x00\x97\x00\x02\x04\x3c\x04\x3b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x3c\x04\x3d\x00\x03\x00\x02\x00\x02\x00\x02\x04\x3d\x04\x3e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x3e\x04\x3f\x00\x07\x00\x29\x00\x02"\
      "\x00\x02\x04\x3f\x04\x41\x00\x05\x00\xcc\x00\x67\x00\x02\x04\x40\x04\x42"\
      "\x00\x05\x00\x3e\x00\x20\x00\x02\x04\x41\x04\x40\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x41\x04\x42\x00\x03\x00\x02\x00\x02\x00\x02\x04\x42\x04\x44"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x43\x04\x45\x00\x05\x01\x8e\x00\xc8"\
      "\x00\x02\x04\x44\x04\x43\x00\x03\x00\x02\x00\x02\x00\x02\x04\x44\x04\x45"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x45\x04\x46\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x46\x04\x47\x00\x05\x00\xce\x00\x68\x00\x02\x04\x47\x00\xcb"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x48\x04\x49\x00\x05\x01\x92\x00\xca"\
      "\x00\x02\x04\x49\x00\xcd\x00\x03\x00\x02\x00\x02\x00\x02\x04\x4a\x04\x4c"\
      "\x00\x07\x00\x0b\x00\x02\x00\x02\x04\x4b\x04\x4d\x00\x05\x00\x56\x00\x2c"\
      "\x00\x02\x04\x4c\x04\x4b\x00\x03\x00\x02\x00\x02\x00\x02\x04\x4c\x04\x4d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x4d\x04\x4e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x4e\x04\x4f\x00\x07\x00\x36\x00\x02\x00\x02\x04\x4f\x00\xcf"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x50\x04\x52\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x04\x51\x04\x50\x00\x03\x00\x02\x00\x02\x00\x02\x04\x51\x04\x52"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x52\x04\x53\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x53\x04\x54\x00\x07\x00\x33\x00\x02\x00\x02\x04\x54\x04\x56"\
      "\x00\x05\x00\xd2\x00\x6a\x00\x02\x04\x55\x04\x57\x00\x05\x00\x3e\x00\x20"\
      "\x00\x02\x04\x56\x04\x55\x00\x03\x00\x02\x00\x02\x00\x02\x04\x56\x04\x57"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x57\x04\x59\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x58\x04\x5a\x00\x05\x01\x8e\x00\xc8\x00\x02\x04\x59\x04\x58"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x59\x04\x5a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x5a\x04\x5b\x00\x03\x00\x02\x00\x02\x00\x02\x04\x5b\x04\x5c"\
      "\x00\x05\x00\xd4\x00\x6b\x00\x02\x04\x5c\x00\xd1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x5d\x04\x5e\x00\x05\x01\x92\x00\xca\x00\x02\x04\x5e\x00\xd3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x5f\x04\x61\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x04\x60\x04\x62\x00\x05\x00\x56\x00\x2c\x00\x02\x04\x61\x04\x60"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x61\x04\x62\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x62\x04\x63\x00\x03\x00\x02\x00\x02\x00\x02\x04\x63\x04\x64"\
      "\x00\x07\x00\x36\x00\x02\x00\x02\x04\x64\x00\xd5\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x65\x04\x67\x00\x05\x01\x2c\x00\x97\x00\x02\x04\x66\x04\x65"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x66\x04\x67\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x67\x04\x68\x00\x03\x00\x02\x00\x02\x00\x02\x04\x68\x04\x69"\
      "\x00\x07\x00\x2d\x00\x02\x00\x02\x04\x69\x04\x6b\x00\x05\x00\xd8\x00\x6d"\
      "\x00\x02\x04\x6a\x04\x6c\x00\x05\x01\x8e\x00\xc8\x00\x02\x04\x6b\x04\x6a"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x6b\x04\x6c\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x6c\x04\x6d\x00\x03\x00\x02\x00\x02\x00\x02\x04\x6d\x04\x6e"\
      "\x00\x05\x00\xda\x00\x6e\x00\x02\x04\x6e\x00\xd7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x6f\x04\x70\x00\x05\x01\x92\x00\xca\x00\x02\x04\x70\x00\xd9"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x71\x04\x73\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x04\x72\x04\x74\x00\x05\x00\xde\x00\x70\x00\x02\x04\x73\x04\x72"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x73\x04\x74\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x74\x04\x75\x00\x03\x00\x02\x00\x02\x00\x02\x04\x75\x04\x76"\
      "\x00\x07\x00\x36\x00\x02\x00\x02\x04\x76\x00\xdb\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x77\x04\x7d\x00\x05\x00\xe0\x00\x71\x00\x02\x04\x78\x04\x7d"\
      "\x00\x05\x00\xe2\x00\x72\x00\x02\x04\x79\x04\x7d\x00\x05\x00\xe4\x00\x73"\
      "\x00\x02\x04\x7a\x04\x7d\x00\x05\x00\xe6\x00\x74\x00\x02\x04\x7b\x04\x7d"\
      "\x00\x05\x00\xe8\x00\x75\x00\x02\x04\x7c\x04\x77\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x7c\x04\x78\x00\x03\x00\x02\x00\x02\x00\x02\x04\x7c\x04\x79"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x7c\x04\x7a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x7c\x04\x7b\x00\x03\x00\x02\x00\x02\x00\x02\x04\x7d\x00\xdd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x7e\x04\x80\x00\x05\x00\xdc\x00\x6f"\
      "\x00\x02\x04\x7f\x04\x81\x00\x05\x00\xde\x00\x70\x00\x02\x04\x80\x04\x7f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x80\x04\x81\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x81\x00\xdf\x00\x03\x00\x02\x00\x02\x00\x02\x04\x82\x04\x83"\
      "\x00\x05\x00\x70\x00\x39\x00\x02\x04\x83\x04\x84\x00\x05\x00\x72\x00\x3a"\
      "\x00\x02\x04\x84\x04\x85\x00\x05\x01\x76\x00\xbc\x00\x02\x04\x85\x04\x86"\
      "\x00\x05\x00\x7c\x00\x3f\x00\x02\x04\x86\x00\xe1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x87\x04\x88\x00\x05\x00\x92\x00\x4a\x00\x02\x04\x88\x04\x8a"\
      "\x00\x05\x00\x94\x00\x4b\x00\x02\x04\x89\x04\x8b\x00\x05\x00\x3e\x00\x20"\
      "\x00\x02\x04\x8a\x04\x89\x00\x03\x00\x02\x00\x02\x00\x02\x04\x8a\x04\x8b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x8b\x04\x8c\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x8c\x04\x8d\x00\x05\x00\x96\x00\x4c\x00\x02\x04\x8d\x00\xe3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x8e\x04\x90\x00\x05\x00\xec\x00\x77"\
      "\x00\x02\x04\x8f\x04\x91\x00\x05\x00\x3e\x00\x20\x00\x02\x04\x90\x04\x8f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x90\x04\x91\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x91\x04\x92\x00\x03\x00\x02\x00\x02\x00\x02\x04\x92\x04\x93"\
      "\x00\x05\x00\x9e\x00\x50\x00\x02\x04\x93\x00\xe5\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x94\x04\x95\x00\x05\x00\xf8\x00\x7d\x00\x02\x04\x95\x04\x96"\
      "\x00\x05\x00\xfa\x00\x7e\x00\x02\x04\x96\x04\x97\x00\x05\x00\x7c\x00\x3f"\
      "\x00\x02\x04\x97\x00\xe7\x00\x03\x00\x02\x00\x02\x00\x02\x04\x98\x04\x9a"\
      "\x00\x05\x00\x8a\x00\x46\x00\x02\x04\x99\x04\x9b\x00\x05\x01\x8e\x00\xc8"\
      "\x00\x02\x04\x9a\x04\x99\x00\x03\x00\x02\x00\x02\x00\x02\x04\x9a\x04\x9b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x9b\x04\x9d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x9c\x04\x9e\x00\x05\x00\x8e\x00\x48\x00\x02\x04\x9d\x04\x9c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\x9d\x04\x9e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\x9e\x00\xe9\x00\x03\x00\x02\x00\x02\x00\x02\x04\x9f\x04\xa1"\
      "\x00\x05\x00\xec\x00\x77\x00\x02\x04\xa0\x04\xa2\x00\x05\x00\x3e\x00\x20"\
      "\x00\x02\x04\xa1\x04\xa0\x00\x03\x00\x02\x00\x02\x00\x02\x04\xa1\x04\xa2"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xa2\x04\xa3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xa3\x04\xa4\x00\x05\x00\x9e\x00\x50\x00\x02\x04\xa4\x04\xa5"\
      "\x00\x05\x00\xee\x00\x78\x00\x02\x04\xa5\x00\xeb\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xa6\x04\xa8\x00\x05\x01\x2c\x00\x97\x00\x02\x04\xa7\x04\xa6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xa7\x04\xa8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xa8\x04\xaa\x00\x03\x00\x02\x00\x02\x00\x02\x04\xa9\x04\xab"\
      "\x00\x07\x00\x47\x00\x02\x00\x02\x04\xaa\x04\xa9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xaa\x04\xab\x00\x03\x00\x02\x00\x02\x00\x02\x04\xab\x04\xac"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xac\x04\xad\x00\x07\x00\x1c\x00\x02"\
      "\x00\x02\x04\xad\x00\xed\x00\x03\x00\x02\x00\x02\x00\x02\x04\xae\x04\xaf"\
      "\x00\x05\x00\x5c\x00\x2f\x00\x02\x04\xaf\x00\xef\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xb0\x04\xb2\x00\x05\x01\x2c\x00\x97\x00\x02\x04\xb1\x04\xb0"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xb1\x04\xb2\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xb2\x04\xb3\x00\x03\x00\x02\x00\x02\x00\x02\x04\xb3\x04\xb4"\
      "\x00\x07\x00\x2e\x00\x02\x00\x02\x04\xb4\x04\xb5\x00\x05\x00\x5c\x00\x2f"\
      "\x00\x02\x04\xb5\x00\xf1\x00\x03\x00\x02\x00\x02\x00\x02\x04\xb6\x04\xb7"\
      "\x00\x07\x00\x1e\x00\x02\x00\x02\x04\xb7\x04\xb9\x00\x05\x01\x78\x00\xbd"\
      "\x00\x02\x04\xb8\x04\xba\x00\x05\x01\x8e\x00\xc8\x00\x02\x04\xb9\x04\xb8"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xb9\x04\xba\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xba\x04\xbb\x00\x03\x00\x02\x00\x02\x00\x02\x04\xbb\x04\xbc"\
      "\x00\x05\x00\xf4\x00\x7b\x00\x02\x04\xbc\x00\xf3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xbd\x04\xbf\x00\x07\x00\x0b\x00\x02\x00\x02\x04\xbe\x04\xc0"\
      "\x00\x05\x00\x56\x00\x2c\x00\x02\x04\xbf\x04\xbe\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xbf\x04\xc0\x00\x03\x00\x02\x00\x02\x00\x02\x04\xc0\x04\xc1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xc1\x04\xc2\x00\x07\x00\x36\x00\x02"\
      "\x00\x02\x04\xc2\x00\xf5\x00\x03\x00\x02\x00\x02\x00\x02\x04\xc3\x04\xc4"\
      "\x00\x05\x00\xf8\x00\x7d\x00\x02\x04\xc4\x04\xc5\x00\x05\x00\xfa\x00\x7e"\
      "\x00\x02\x04\xc5\x04\xc6\x00\x05\x00\x5c\x00\x2f\x00\x02\x04\xc6\x04\xd0"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xc7\x04\xc8\x00\x05\x00\xf8\x00\x7d"\
      "\x00\x02\x04\xc8\x04\xc9\x00\x05\x00\xfa\x00\x7e\x00\x02\x04\xc9\x04\xca"\
      "\x00\x05\x00\x74\x00\x3b\x00\x02\x04\xca\x04\xd0\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xcb\x04\xcc\x00\x05\x00\xf8\x00\x7d\x00\x02\x04\xcc\x04\xcd"\
      "\x00\x05\x00\xfa\x00\x7e\x00\x02\x04\xcd\x04\xce\x00\x05\x00\x7c\x00\x3f"\
      "\x00\x02\x04\xce\x04\xd0\x00\x03\x00\x02\x00\x02\x00\x02\x04\xcf\x04\xc3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xcf\x04\xc7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xcf\x04\xcb\x00\x03\x00\x02\x00\x02\x00\x02\x04\xd0\x00\xf7"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xd1\x04\xd3\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x04\xd2\x04\xd1\x00\x03\x00\x02\x00\x02\x00\x02\x04\xd2\x04\xd3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xd3\x04\xd4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xd4\x04\xd5\x00\x07\x00\x2b\x00\x02\x00\x02\x04\xd5\x04\xd6"\
      "\x00\x05\x00\x9e\x00\x50\x00\x02\x04\xd6\x00\xf9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xd7\x04\xd9\x00\x07\x00\x43\x00\x02\x00\x02\x04\xd8\x04\xda"\
      "\x00\x05\x01\x2c\x00\x97\x00\x02\x04\xd9\x04\xd8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xd9\x04\xda\x00\x03\x00\x02\x00\x02\x00\x02\x04\xda\x04\xdb"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xdb\x04\xdc\x00\x05\x01\x74\x00\xbb"\
      "\x00\x02\x04\xdc\x00\xfb\x00\x03\x00\x02\x00\x02\x00\x02\x04\xdd\x04\xe1"\
      "\x00\x05\x00\xfe\x00\x80\x00\x02\x04\xde\x04\xe1\x00\x05\x01\x00\x00\x81"\
      "\x00\x02\x04\xdf\x04\xe1\x00\x05\x01\x02\x00\x82\x00\x02\x04\xe0\x04\xdd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xe0\x04\xde\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xe0\x04\xdf\x00\x03\x00\x02\x00\x02\x00\x02\x04\xe1\x00\xfd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xe2\x04\xe3\x00\x07\x00\x07\x00\x02"\
      "\x00\x02\x04\xe3\x04\xe4\x00\x07\x00\x5d\x00\x02\x00\x02\x04\xe4\x04\xe5"\
      "\x00\x07\x00\x07\x00\x02\x00\x02\x04\xe5\x04\xe6\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x04\xe6\x04\xe7\x00\x07\x00\x36\x00\x02\x00\x02\x04\xe7\x00\xff"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xe8\x04\xe9\x00\x07\x00\x07\x00\x02"\
      "\x00\x02\x04\xe9\x04\xea\x00\x07\x00\x10\x00\x02\x00\x02\x04\xea\x04\xeb"\
      "\x00\x07\x00\x07\x00\x02\x00\x02\x04\xeb\x04\xec\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x04\xec\x04\xed\x00\x07\x00\x36\x00\x02\x00\x02\x04\xed\x01\x01"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xee\x04\xef\x00\x07\x00\x07\x00\x02"\
      "\x00\x02\x04\xef\x04\xf0\x00\x07\x00\x28\x00\x02\x00\x02\x04\xf0\x04\xf1"\
      "\x00\x07\x00\x07\x00\x02\x00\x02\x04\xf1\x04\xf2\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x04\xf2\x04\xf3\x00\x05\x01\x04\x00\x83\x00\x02\x04\xf3\x04\xf4"\
      "\x00\x07\x00\x36\x00\x02\x00\x02\x04\xf4\x01\x03\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xf5\x04\xf7\x00\x05\x01\x06\x00\x84\x00\x02\x04\xf6\x04\xf5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xf6\x04\xf7\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xf7\x04\xf9\x00\x03\x00\x02\x00\x02\x00\x02\x04\xf8\x04\xfa"\
      "\x00\x05\x01\x0a\x00\x86\x00\x02\x04\xf9\x04\xf8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x04\xf9\x04\xfa\x00\x03\x00\x02\x00\x02\x00\x02\x04\xfa\x01\x05"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xfb\x04\xfc\x00\x07\x00\x09\x00\x02"\
      "\x00\x02\x04\xfc\x04\xfd\x00\x05\x01\x08\x00\x85\x00\x02\x04\xfd\x01\x07"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x04\xfe\x04\xff\x00\x05\x01\x9c\x00\xcf"\
      "\x00\x02\x04\xff\x01\x09\x00\x03\x00\x02\x00\x02\x00\x02\x05\x00\x05\x01"\
      "\x00\x07\x00\x06\x00\x02\x00\x02\x05\x01\x05\x02\x00\x05\x01\x0c\x00\x87"\
      "\x00\x02\x05\x02\x01\x0b\x00\x03\x00\x02\x00\x02\x00\x02\x05\x03\x05\x04"\
      "\x00\x09\x00\x04\x00\x02\x00\x02\x05\x04\x01\x0d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x05\x05\x06\x00\x08\x00\x88\x00\x01\x00\x02\x05\x06\x05\x08"\
      "\x00\x05\x01\x10\x00\x89\x00\x02\x05\x07\x05\x09\x00\x05\x01\x76\x00\xbc"\
      "\x00\x02\x05\x08\x05\x07\x00\x03\x00\x02\x00\x02\x00\x02\x05\x08\x05\x09"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x09\x05\x18\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x0a\x05\x0c\x00\x05\x01\x12\x00\x8a\x00\x02\x05\x0b\x05\x0d"\
      "\x00\x05\x01\x76\x00\xbc\x00\x02\x05\x0c\x05\x0b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x0c\x05\x0d\x00\x03\x00\x02\x00\x02\x00\x02\x05\x0d\x05\x18"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x0e\x05\x18\x00\x05\x01\x14\x00\x8b"\
      "\x00\x02\x05\x0f\x05\x11\x00\x05\x01\x16\x00\x8c\x00\x02\x05\x10\x05\x12"\
      "\x00\x05\x01\x76\x00\xbc\x00\x02\x05\x11\x05\x10\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x11\x05\x12\x00\x03\x00\x02\x00\x02\x00\x02\x05\x12\x05\x18"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x13\x05\x18\x00\x05\x01\x1c\x00\x8f"\
      "\x00\x02\x05\x14\x05\x15\x00\x07\x00\x3d\x00\x02\x00\x02\x05\x15\x05\x18"\
      "\x00\x05\x01\x74\x00\xbb\x00\x02\x05\x16\x05\x18\x00\x05\x01\x24\x00\x93"\
      "\x00\x02\x05\x17\x05\x05\x00\x03\x00\x02\x00\x02\x00\x02\x05\x17\x05\x0a"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x17\x05\x0e\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x17\x05\x0f\x00\x03\x00\x02\x00\x02\x00\x02\x05\x17\x05\x13"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x17\x05\x14\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x17\x05\x16\x00\x03\x00\x02\x00\x02\x00\x02\x05\x18\x05\x1e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x19\x05\x1a\x00\x0c\x00\x04\x00\x02"\
      "\x00\x02\x05\x1a\x05\x1b\x00\x07\x00\x2f\x00\x02\x00\x02\x05\x1b\x05\x1d"\
      "\x00\x05\x01\x74\x00\xbb\x00\x02\x05\x1c\x05\x19\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x1d\x05\x20\x00\x03\x00\x02\x00\x02\x00\x02\x05\x1e\x05\x1c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x1e\x05\x1f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x1f\x01\x0f\x00\x03\x00\x02\x00\x02\x00\x02\x05\x20\x05\x1e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x21\x05\x22\x00\x07\x00\x50\x00\x02"\
      "\x00\x02\x05\x22\x01\x11\x00\x03\x00\x02\x00\x02\x00\x02\x05\x23\x05\x24"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x05\x24\x01\x13\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x25\x05\x26\x00\x07\x00\x1b\x00\x02\x00\x02\x05\x26\x05\x2a"\
      "\x00\x05\x01\x0e\x00\x88\x00\x02\x05\x27\x05\x28\x00\x07\x00\x25\x00\x02"\
      "\x00\x02\x05\x28\x05\x2a\x00\x05\x01\x0e\x00\x88\x00\x02\x05\x29\x05\x25"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x29\x05\x27\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x2a\x01\x15\x00\x03\x00\x02\x00\x02\x00\x02\x05\x2b\x05\x2d"\
      "\x00\x07\x00\x15\x00\x02\x00\x02\x05\x2c\x05\x2e\x00\x05\x01\x18\x00\x8d"\
      "\x00\x02\x05\x2d\x05\x2c\x00\x03\x00\x02\x00\x02\x00\x02\x05\x2d\x05\x2e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x2e\x05\x2f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x2f\x05\x30\x00\x07\x00\x5a\x00\x02\x00\x02\x05\x30\x01\x17"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x31\x05\x36\x00\x05\x01\x1a\x00\x8e"\
      "\x00\x02\x05\x32\x05\x33\x00\x07\x00\x17\x00\x02\x00\x02\x05\x33\x05\x35"\
      "\x00\x05\x01\x1a\x00\x8e\x00\x02\x05\x34\x05\x32\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x35\x05\x38\x00\x03\x00\x02\x00\x02\x00\x02\x05\x36\x05\x34"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x36\x05\x37\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x37\x01\x19\x00\x03\x00\x02\x00\x02\x00\x02\x05\x38\x05\x36"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x39\x05\x3a\x00\x05\x01\x0e\x00\x88"\
      "\x00\x02\x05\x3a\x01\x1b\x00\x03\x00\x02\x00\x02\x00\x02\x05\x3b\x05\x3d"\
      "\x00\x05\x01\x78\x00\xbd\x00\x02\x05\x3c\x05\x3b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x3c\x05\x3d\x00\x03\x00\x02\x00\x02\x00\x02\x05\x3d\x05\x3e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x3e\x05\x3f\x00\x07\x00\x42\x00\x02"\
      "\x00\x02\x05\x3f\x05\x41\x00\x05\x00\xba\x00\x5e\x00\x02\x05\x40\x05\x42"\
      "\x00\x05\x01\x16\x00\x8c\x00\x02\x05\x41\x05\x40\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x41\x05\x42\x00\x03\x00\x02\x00\x02\x00\x02\x05\x42\x01\x1d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x43\x05\x46\x00\x05\x01\x20\x00\x91"\
      "\x00\x02\x05\x44\x05\x46\x00\x05\x01\x22\x00\x92\x00\x02\x05\x45\x05\x43"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x45\x05\x44\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x46\x01\x1f\x00\x03\x00\x02\x00\x02\x00\x02\x05\x47\x05\x48"\
      "\x00\x07\x00\x3d\x00\x02\x00\x02\x05\x48\x05\x49\x00\x05\x01\x74\x00\xbb"\
      "\x00\x02\x05\x49\x01\x21\x00\x03\x00\x02\x00\x02\x00\x02\x05\x4a\x05\x4b"\
      "\x00\x05\x01\x0e\x00\x88\x00\x02\x05\x4b\x05\x4c\x00\x07\x00\x2f\x00\x02"\
      "\x00\x02\x05\x4c\x05\x4d\x00\x05\x01\x74\x00\xbb\x00\x02\x05\x4d\x01\x23"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x4e\x05\x4f\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x05\x4f\x01\x25\x00\x03\x00\x02\x00\x02\x00\x02\x05\x50\x05\x51"\
      "\x00\x07\x00\x22\x00\x02\x00\x02\x05\x51\x05\x53\x00\x05\x01\x28\x00\x95"\
      "\x00\x02\x05\x52\x05\x54\x00\x05\x01\x2a\x00\x96\x00\x02\x05\x53\x05\x52"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x53\x05\x54\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x54\x01\x27\x00\x03\x00\x02\x00\x02\x00\x02\x05\x55\x05\x56"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x05\x56\x01\x29\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x57\x05\x59\x00\x07\x00\x15\x00\x02\x00\x02\x05\x58\x05\x5a"\
      "\x00\x05\x01\x2e\x00\x98\x00\x02\x05\x59\x05\x58\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x59\x05\x5a\x00\x03\x00\x02\x00\x02\x00\x02\x05\x5a\x05\x5b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x5b\x05\x5c\x00\x07\x00\x5a\x00\x02"\
      "\x00\x02\x05\x5c\x01\x2b\x00\x03\x00\x02\x00\x02\x00\x02\x05\x5d\x05\x5f"\
      "\x00\x05\x01\x26\x00\x94\x00\x02\x05\x5e\x05\x5d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x5f\x05\x60\x00\x03\x00\x02\x00\x02\x00\x02\x05\x60\x05\x5e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x60\x05\x61\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x61\x01\x2d\x00\x03\x00\x02\x00\x02\x00\x02\x05\x62\x05\x64"\
      "\x00\x05\x01\x30\x00\x99\x00\x02\x05\x63\x05\x62\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x64\x05\x65\x00\x03\x00\x02\x00\x02\x00\x02\x05\x65\x05\x63"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x65\x05\x66\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x66\x01\x2f\x00\x03\x00\x02\x00\x02\x00\x02\x05\x67\x05\x69"\
      "\x00\x07\x00\x15\x00\x02\x00\x02\x05\x68\x05\x6a\x00\x05\x01\x2e\x00\x98"\
      "\x00\x02\x05\x69\x05\x68\x00\x03\x00\x02\x00\x02\x00\x02\x05\x69\x05\x6a"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x6a\x05\x6b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x6b\x05\x7c\x00\x07\x00\x5a\x00\x02\x00\x02\x05\x6c\x05\x6e"\
      "\x00\x07\x00\x4c\x00\x02\x00\x02\x05\x6d\x05\x6f\x00\x05\x01\x2e\x00\x98"\
      "\x00\x02\x05\x6e\x05\x6d\x00\x03\x00\x02\x00\x02\x00\x02\x05\x6e\x05\x6f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x6f\x05\x70\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x70\x05\x7c\x00\x07\x00\x20\x00\x02\x00\x02\x05\x71\x05\x73"\
      "\x00\x07\x00\x0b\x00\x02\x00\x02\x05\x72\x05\x74\x00\x05\x01\x2e\x00\x98"\
      "\x00\x02\x05\x73\x05\x72\x00\x03\x00\x02\x00\x02\x00\x02\x05\x73\x05\x74"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x74\x05\x75\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x75\x05\x7c\x00\x07\x00\x36\x00\x02\x00\x02\x05\x76\x05\x7c"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x05\x77\x05\x7c\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x05\x78\x05\x7c\x00\x05\x01\x96\x00\xcc\x00\x02\x05\x79\x05\x7c"\
      "\x00\x05\x01\x9a\x00\xce\x00\x02\x05\x7a\x05\x7c\x00\x05\x01\x6c\x00\xb7"\
      "\x00\x02\x05\x7b\x05\x67\x00\x03\x00\x02\x00\x02\x00\x02\x05\x7b\x05\x6c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x7b\x05\x71\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x7b\x05\x76\x00\x03\x00\x02\x00\x02\x00\x02\x05\x7b\x05\x77"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x7b\x05\x78\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x7b\x05\x79\x00\x03\x00\x02\x00\x02\x00\x02\x05\x7b\x05\x7a"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x7c\x01\x31\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x7d\x05\x82\x00\x05\x01\x34\x00\x9b\x00\x02\x05\x7e\x05\x7f"\
      "\x00\x07\x00\x17\x00\x02\x00\x02\x05\x7f\x05\x81\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x05\x80\x05\x7e\x00\x03\x00\x02\x00\x02\x00\x02\x05\x81\x05\x84"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x82\x05\x80\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x82\x05\x83\x00\x03\x00\x02\x00\x02\x00\x02\x05\x83\x01\x33"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x84\x05\x82\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x85\x05\x86\x00\x08\x00\x9b\x00\x01\x00\x02\x05\x86\x05\x87"\
      "\x00\x05\x01\x70\x00\xb9\x00\x02\x05\x87\x05\x88\x00\x05\x01\x34\x00\x9b"\
      "\x00\x13\x05\x88\x05\x8c\x00\x03\x00\x02\x00\x02\x00\x02\x05\x89\x05\x8c"\
      "\x00\x05\x01\x36\x00\x9c\x00\x02\x05\x8a\x05\x8c\x00\x05\x01\x40\x00\xa1"\
      "\x00\x02\x05\x8b\x05\x85\x00\x03\x00\x02\x00\x02\x00\x02\x05\x8b\x05\x89"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x8b\x05\x8a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x8c\x05\xbf\x00\x03\x00\x02\x00\x02\x00\x02\x05\x8d\x05\x8e"\
      "\x00\x0c\x00\x10\x00\x02\x00\x02\x05\x8e\x05\x8f\x00\x05\x01\x6e\x00\xb8"\
      "\x00\x02\x05\x8f\x05\x90\x00\x05\x01\x34\x00\x9b\x00\x11\x05\x90\x05\xbe"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\x91\x05\x92\x00\x0c\x00\x0f\x00\x02"\
      "\x00\x02\x05\x92\x05\x93\x00\x05\x01\x38\x00\x9d\x00\x02\x05\x93\x05\x94"\
      "\x00\x05\x01\x34\x00\x9b\x00\x10\x05\x94\x05\xbe\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\x95\x05\x96\x00\x0c\x00\x0e\x00\x02\x00\x02\x05\x96\x05\x97"\
      "\x00\x05\x01\x3a\x00\x9e\x00\x02\x05\x97\x05\x98\x00\x05\x01\x34\x00\x9b"\
      "\x00\x0f\x05\x98\x05\xbe\x00\x03\x00\x02\x00\x02\x00\x02\x05\x99\x05\x9a"\
      "\x00\x0c\x00\x0d\x00\x02\x00\x02\x05\x9a\x05\xbe\x00\x05\x01\x3c\x00\x9f"\
      "\x00\x02\x05\x9b\x05\x9c\x00\x0c\x00\x0c\x00\x02\x00\x02\x05\x9c\x05\xbe"\
      "\x00\x05\x01\x72\x00\xba\x00\x02\x05\x9d\x05\x9e\x00\x0c\x00\x0b\x00\x02"\
      "\x00\x02\x05\x9e\x05\xa0\x00\x05\x01\x64\x00\xb3\x00\x02\x05\x9f\x05\xa1"\
      "\x00\x05\x01\x3e\x00\xa0\x00\x02\x05\xa0\x05\x9f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xa0\x05\xa1\x00\x03\x00\x02\x00\x02\x00\x02\x05\xa1\x05\xbe"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xa2\x05\xa3\x00\x0c\x00\x0a\x00\x02"\
      "\x00\x02\x05\xa3\x05\xa4\x00\x07\x00\x42\x00\x02\x00\x02\x05\xa4\x05\xbe"\
      "\x00\x07\x00\x1c\x00\x02\x00\x02\x05\xa5\x05\xa6\x00\x0c\x00\x09\x00\x02"\
      "\x00\x02\x05\xa6\x05\xa7\x00\x07\x00\x42\x00\x02\x00\x02\x05\xa7\x05\xbe"\
      "\x00\x07\x00\x64\x00\x02\x00\x02\x05\xa8\x05\xa9\x00\x0c\x00\x08\x00\x02"\
      "\x00\x02\x05\xa9\x05\xaa\x00\x07\x00\x42\x00\x02\x00\x02\x05\xaa\x05\xac"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x05\xab\x05\xad\x00\x05\x00\x4e\x00\x28"\
      "\x00\x02\x05\xac\x05\xab\x00\x03\x00\x02\x00\x02\x00\x02\x05\xac\x05\xad"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xad\x05\xbe\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xae\x05\xaf\x00\x0c\x00\x07\x00\x02\x00\x02\x05\xaf\x05\xb0"\
      "\x00\x07\x00\x42\x00\x02\x00\x02\x05\xb0\x05\xbe\x00\x07\x00\x59\x00\x02"\
      "\x00\x02\x05\xb1\x05\xb2\x00\x0c\x00\x06\x00\x02\x00\x02\x05\xb2\x05\xb3"\
      "\x00\x07\x00\x42\x00\x02\x00\x02\x05\xb3\x05\xbe\x00\x07\x00\x1d\x00\x02"\
      "\x00\x02\x05\xb4\x05\xb5\x00\x0c\x00\x05\x00\x02\x00\x02\x05\xb5\x05\xb6"\
      "\x00\x07\x00\x4c\x00\x02\x00\x02\x05\xb6\x05\xb7\x00\x05\x01\x32\x00\x9a"\
      "\x00\x02\x05\xb7\x05\xb8\x00\x07\x00\x20\x00\x02\x00\x02\x05\xb8\x05\xbe"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xb9\x05\xba\x00\x0c\x00\x04\x00\x02"\
      "\x00\x02\x05\xba\x05\xbe\x00\x07\x00\x53\x00\x02\x00\x02\x05\xbb\x05\xbc"\
      "\x00\x0c\x00\x03\x00\x02\x00\x02\x05\xbc\x05\xbe\x00\x07\x00\x38\x00\x02"\
      "\x00\x02\x05\xbd\x05\x8d\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbd\x05\x91"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbd\x05\x95\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xbd\x05\x99\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbd\x05\x9b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbd\x05\x9d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xbd\x05\xa2\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbd\x05\xa5"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbd\x05\xa8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xbd\x05\xae\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbd\x05\xb1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbd\x05\xb4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xbd\x05\xb9\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbd\x05\xbb"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbe\x05\xc1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xbf\x05\xbd\x00\x03\x00\x02\x00\x02\x00\x02\x05\xbf\x05\xc0"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xc0\x01\x35\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xc1\x05\xbf\x00\x03\x00\x02\x00\x02\x00\x02\x05\xc2\x05\xc3"\
      "\x00\x07\x00\x3b\x00\x02\x00\x02\x05\xc3\x05\xc4\x00\x05\x01\x92\x00\xca"\
      "\x00\x02\x05\xc4\x01\x37\x00\x03\x00\x02\x00\x02\x00\x02\x05\xc5\x05\xc6"\
      "\x00\x07\x00\x0d\x00\x02\x00\x02\x05\xc6\x01\x39\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xc7\x05\xc8\x00\x07\x00\x38\x00\x02\x00\x02\x05\xc8\x05\xc9"\
      "\x00\x05\x01\x34\x00\x9b\x00\x02\x05\xc9\x05\xca\x00\x07\x00\x4b\x00\x02"\
      "\x00\x02\x05\xca\x01\x3b\x00\x03\x00\x02\x00\x02\x00\x02\x05\xcb\x05\xcc"\
      "\x00\x07\x00\x3d\x00\x02\x00\x02\x05\xcc\x05\xd3\x00\x05\x01\x74\x00\xbb"\
      "\x00\x02\x05\xcd\x05\xcf\x00\x07\x00\x2f\x00\x02\x00\x02\x05\xce\x05\xd0"\
      "\x00\x07\x00\x38\x00\x02\x00\x02\x05\xcf\x05\xce\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xcf\x05\xd0\x00\x03\x00\x02\x00\x02\x00\x02\x05\xd0\x05\xd1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xd1\x05\xd3\x00\x05\x01\x74\x00\xbb"\
      "\x00\x02\x05\xd2\x05\xcb\x00\x03\x00\x02\x00\x02\x00\x02\x05\xd2\x05\xcd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xd3\x01\x3d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xd4\x05\xd5\x00\x05\x01\x5a\x00\xae\x00\x02\x05\xd5\x01\x3f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xd6\x05\xd8\x00\x05\x01\x92\x00\xca"\
      "\x00\x02\x05\xd7\x05\xd9\x00\x05\x00\x4e\x00\x28\x00\x02\x05\xd8\x05\xd7"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xd8\x05\xd9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xd9\x05\xe2\x00\x03\x00\x02\x00\x02\x00\x02\x05\xda\x05\xe2"\
      "\x00\x05\x01\x42\x00\xa2\x00\x02\x05\xdb\x05\xe2\x00\x05\x01\x50\x00\xa9"\
      "\x00\x02\x05\xdc\x05\xe2\x00\x05\x01\x52\x00\xaa\x00\x02\x05\xdd\x05\xe2"\
      "\x00\x05\x01\x5a\x00\xae\x00\x02\x05\xde\x05\xe2\x00\x05\x01\x64\x00\xb3"\
      "\x00\x02\x05\xdf\x05\xe2\x00\x05\x01\x62\x00\xb2\x00\x02\x05\xe0\x05\xe2"\
      "\x00\x05\x01\x6a\x00\xb6\x00\x02\x05\xe1\x05\xd6\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xe1\x05\xda\x00\x03\x00\x02\x00\x02\x00\x02\x05\xe1\x05\xdb"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xe1\x05\xdc\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xe1\x05\xdd\x00\x03\x00\x02\x00\x02\x00\x02\x05\xe1\x05\xde"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xe1\x05\xdf\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xe1\x05\xe0\x00\x03\x00\x02\x00\x02\x00\x02\x05\xe2\x01\x41"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xe3\x05\xeb\x00\x05\x01\x9a\x00\xce"\
      "\x00\x02\x05\xe4\x05\xeb\x00\x05\x01\x44\x00\xa3\x00\x02\x05\xe5\x05\xeb"\
      "\x00\x05\x01\x4a\x00\xa6\x00\x02\x05\xe6\x05\xeb\x00\x07\x00\x1a\x00\x02"\
      "\x00\x02\x05\xe7\x05\xeb\x00\x07\x00\x21\x00\x02\x00\x02\x05\xe8\x05\xeb"\
      "\x00\x07\x00\x48\x00\x02\x00\x02\x05\xe9\x05\xeb\x00\x07\x00\x12\x00\x02"\
      "\x00\x02\x05\xea\x05\xe3\x00\x03\x00\x02\x00\x02\x00\x02\x05\xea\x05\xe4"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xea\x05\xe5\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xea\x05\xe6\x00\x03\x00\x02\x00\x02\x00\x02\x05\xea\x05\xe7"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xea\x05\xe8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xea\x05\xe9\x00\x03\x00\x02\x00\x02\x00\x02\x05\xeb\x01\x43"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xec\x05\xee\x00\x07\x00\x4c\x00\x02"\
      "\x00\x02\x05\xed\x05\xef\x00\x05\x01\x46\x00\xa4\x00\x02\x05\xee\x05\xed"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xee\x05\xef\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xef\x05\xf0\x00\x03\x00\x02\x00\x02\x00\x02\x05\xf0\x05\xf1"\
      "\x00\x07\x00\x20\x00\x02\x00\x02\x05\xf1\x01\x45\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xf2\x05\xf4\x00\x05\x01\x48\x00\xa5\x00\x02\x05\xf3\x05\xf5"\
      "\x00\x07\x00\x17\x00\x02\x00\x02\x05\xf4\x05\xf3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xf4\x05\xf5\x00\x03\x00\x02\x00\x02\x00\x02\x05\xf5\x05\xfb"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xf6\x05\xf7\x00\x05\x01\x48\x00\xa5"\
      "\x00\x02\x05\xf7\x05\xf8\x00\x07\x00\x17\x00\x02\x00\x02\x05\xf8\x05\xf9"\
      "\x00\x05\x01\x46\x00\xa4\x00\x02\x05\xf9\x05\xfb\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xfa\x05\xf2\x00\x03\x00\x02\x00\x02\x00\x02\x05\xfa\x05\xf6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xfb\x01\x47\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x05\xfc\x05\xfd\x00\x05\x01\x34\x00\x9b\x00\x02\x05\xfd\x01\x49"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x05\xfe\x05\xff\x00\x07\x00\x4c\x00\x02"\
      "\x00\x02\x05\xff\x06\x00\x00\x05\x01\x4c\x00\xa7\x00\x02\x06\x00\x06\x01"\
      "\x00\x07\x00\x20\x00\x02\x00\x02\x06\x01\x06\x06\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x02\x06\x03\x00\x07\x00\x4c\x00\x02\x00\x02\x06\x03\x06\x04"\
      "\x00\x07\x00\x4b\x00\x02\x00\x02\x06\x04\x06\x06\x00\x07\x00\x20\x00\x02"\
      "\x00\x02\x06\x05\x05\xfe\x00\x03\x00\x02\x00\x02\x00\x02\x06\x05\x06\x02"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x06\x01\x4b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x07\x06\x09\x00\x05\x01\x4e\x00\xa8\x00\x02\x06\x08\x06\x0a"\
      "\x00\x07\x00\x17\x00\x02\x00\x02\x06\x09\x06\x08\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x09\x06\x0a\x00\x03\x00\x02\x00\x02\x00\x02\x06\x0a\x06\x0b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x0b\x06\x0c\x00\x05\x01\x4e\x00\xa8"\
      "\x00\x02\x06\x0c\x06\x0d\x00\x07\x00\x17\x00\x02\x00\x02\x06\x0d\x06\x0e"\
      "\x00\x05\x01\x4c\x00\xa7\x00\x02\x06\x0e\x01\x4d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x0f\x06\x10\x00\x05\x01\x34\x00\x9b\x00\x02\x06\x10\x06\x11"\
      "\x00\x07\x00\x4b\x00\x02\x00\x02\x06\x11\x06\x12\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x06\x12\x01\x4f\x00\x03\x00\x02\x00\x02\x00\x02\x06\x13\x06\x20"\
      "\x00\x07\x00\x59\x00\x02\x00\x02\x06\x14\x06\x15\x00\x07\x00\x59\x00\x02"\
      "\x00\x02\x06\x15\x06\x16\x00\x07\x00\x42\x00\x02\x00\x02\x06\x16\x06\x20"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x06\x17\x06\x18\x00\x07\x00\x59\x00\x02"\
      "\x00\x02\x06\x18\x06\x19\x00\x07\x00\x4c\x00\x02\x00\x02\x06\x19\x06\x1a"\
      "\x00\x05\x01\x34\x00\x9b\x00\x02\x06\x1a\x06\x1b\x00\x07\x00\x20\x00\x02"\
      "\x00\x02\x06\x1b\x06\x20\x00\x03\x00\x02\x00\x02\x00\x02\x06\x1c\x06\x1d"\
      "\x00\x07\x00\x59\x00\x02\x00\x02\x06\x1d\x06\x1e\x00\x07\x00\x42\x00\x02"\
      "\x00\x02\x06\x1e\x06\x20\x00\x07\x00\x1c\x00\x02\x00\x02\x06\x1f\x06\x13"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x1f\x06\x14\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x1f\x06\x17\x00\x03\x00\x02\x00\x02\x00\x02\x06\x1f\x06\x1c"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x20\x01\x51\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x21\x06\x26\x00\x05\x01\x54\x00\xab\x00\x02\x06\x22\x06\x23"\
      "\x00\x05\x01\x56\x00\xac\x00\x02\x06\x23\x06\x24\x00\x05\x01\x58\x00\xad"\
      "\x00\x02\x06\x24\x06\x26\x00\x03\x00\x02\x00\x02\x00\x02\x06\x25\x06\x21"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x25\x06\x22\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x26\x01\x53\x00\x03\x00\x02\x00\x02\x00\x02\x06\x27\x06\x28"\
      "\x00\x07\x00\x58\x00\x02\x00\x02\x06\x28\x06\x29\x00\x07\x00\x42\x00\x02"\
      "\x00\x02\x06\x29\x06\x2a\x00\x05\x01\x92\x00\xca\x00\x02\x06\x2a\x01\x55"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x2b\x06\x2c\x00\x07\x00\x58\x00\x02"\
      "\x00\x02\x06\x2c\x06\x2d\x00\x07\x00\x4c\x00\x02\x00\x02\x06\x2d\x06\x2e"\
      "\x00\x05\x01\x34\x00\x9b\x00\x02\x06\x2e\x06\x2f\x00\x07\x00\x20\x00\x02"\
      "\x00\x02\x06\x2f\x01\x57\x00\x03\x00\x02\x00\x02\x00\x02\x06\x30\x06\x31"\
      "\x00\x07\x00\x58\x00\x02\x00\x02\x06\x31\x06\x32\x00\x07\x00\x42\x00\x02"\
      "\x00\x02\x06\x32\x06\x33\x00\x07\x00\x1c\x00\x02\x00\x02\x06\x33\x01\x59"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x34\x06\x36\x00\x07\x00\x0b\x00\x02"\
      "\x00\x02\x06\x35\x06\x37\x00\x05\x01\x5c\x00\xaf\x00\x02\x06\x36\x06\x35"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x36\x06\x37\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x37\x06\x38\x00\x03\x00\x02\x00\x02\x00\x02\x06\x38\x06\x39"\
      "\x00\x05\x00\x06\x00\x04\x00\x02\x06\x39\x06\x3a\x00\x07\x00\x36\x00\x02"\
      "\x00\x02\x06\x3a\x01\x5b\x00\x03\x00\x02\x00\x02\x00\x02\x06\x3b\x06\x3d"\
      "\x00\x05\x00\x9e\x00\x50\x00\x02\x06\x3c\x06\x3e\x00\x05\x00\x98\x00\x4d"\
      "\x00\x02\x06\x3d\x06\x3c\x00\x03\x00\x02\x00\x02\x00\x02\x06\x3d\x06\x3e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x3e\x06\x3f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x3f\x06\x40\x00\x07\x00\x57\x00\x02\x00\x02\x06\x40\x06\x59"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x41\x06\x43\x00\x05\x01\x98\x00\xcd"\
      "\x00\x02\x06\x42\x06\x44\x00\x05\x00\x98\x00\x4d\x00\x02\x06\x43\x06\x42"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x43\x06\x44\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x44\x06\x45\x00\x03\x00\x02\x00\x02\x00\x02\x06\x45\x06\x46"\
      "\x00\x07\x00\x57\x00\x02\x00\x02\x06\x46\x06\x59\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x47\x06\x48\x00\x05\x01\x5e\x00\xb0\x00\x02\x06\x48\x06\x4a"\
      "\x00\x05\x00\x9e\x00\x50\x00\x02\x06\x49\x06\x4b\x00\x05\x00\x98\x00\x4d"\
      "\x00\x02\x06\x4a\x06\x49\x00\x03\x00\x02\x00\x02\x00\x02\x06\x4a\x06\x4b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x4b\x06\x4c\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x4c\x06\x4d\x00\x07\x00\x57\x00\x02\x00\x02\x06\x4d\x06\x59"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x4e\x06\x4f\x00\x05\x01\x5e\x00\xb0"\
      "\x00\x02\x06\x4f\x06\x51\x00\x05\x01\x98\x00\xcd\x00\x02\x06\x50\x06\x52"\
      "\x00\x05\x00\x98\x00\x4d\x00\x02\x06\x51\x06\x50\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x51\x06\x52\x00\x03\x00\x02\x00\x02\x00\x02\x06\x52\x06\x53"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x53\x06\x54\x00\x07\x00\x57\x00\x02"\
      "\x00\x02\x06\x54\x06\x59\x00\x03\x00\x02\x00\x02\x00\x02\x06\x55\x06\x56"\
      "\x00\x05\x01\x5e\x00\xb0\x00\x02\x06\x56\x06\x57\x00\x07\x00\x57\x00\x02"\
      "\x00\x02\x06\x57\x06\x59\x00\x03\x00\x02\x00\x02\x00\x02\x06\x58\x06\x3b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x58\x06\x41\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x58\x06\x47\x00\x03\x00\x02\x00\x02\x00\x02\x06\x58\x06\x4e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x58\x06\x55\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x59\x01\x5d\x00\x03\x00\x02\x00\x02\x00\x02\x06\x5a\x06\x5b"\
      "\x00\x07\x00\x4c\x00\x02\x00\x02\x06\x5b\x06\x5c\x00\x05\x01\x60\x00\xb1"\
      "\x00\x02\x06\x5c\x06\x5d\x00\x05\x01\x34\x00\x9b\x00\x02\x06\x5d\x06\x5e"\
      "\x00\x07\x00\x20\x00\x02\x00\x02\x06\x5e\x01\x5f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x5f\x06\x60\x00\x09\x00\x05\x00\x02\x00\x02\x06\x60\x01\x61"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x61\x06\x62\x00\x07\x00\x42\x00\x02"\
      "\x00\x02\x06\x62\x06\x63\x00\x05\x01\x92\x00\xca\x00\x02\x06\x63\x01\x63"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x64\x06\x66\x00\x07\x00\x15\x00\x02"\
      "\x00\x02\x06\x65\x06\x67\x00\x05\x01\x66\x00\xb4\x00\x02\x06\x66\x06\x65"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x66\x06\x67\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x67\x06\x68\x00\x03\x00\x02\x00\x02\x00\x02\x06\x68\x06\x69"\
      "\x00\x07\x00\x5a\x00\x02\x00\x02\x06\x69\x01\x65\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x6a\x06\x70\x00\x05\x01\x68\x00\xb5\x00\x02\x06\x6b\x06\x6c"\
      "\x00\x05\x01\x68\x00\xb5\x00\x02\x06\x6c\x06\x6d\x00\x07\x00\x17\x00\x02"\
      "\x00\x02\x06\x6d\x06\x6e\x00\x05\x01\x66\x00\xb4\x00\x02\x06\x6e\x06\x70"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x6f\x06\x6a\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x6f\x06\x6b\x00\x03\x00\x02\x00\x02\x00\x02\x06\x70\x01\x67"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x71\x06\x77\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x06\x72\x06\x73\x00\x05\x01\x92\x00\xca\x00\x02\x06\x73\x06\x74"\
      "\x00\x07\x00\x4b\x00\x02\x00\x02\x06\x74\x06\x75\x00\x05\x01\x34\x00\x9b"\
      "\x00\x02\x06\x75\x06\x77\x00\x03\x00\x02\x00\x02\x00\x02\x06\x76\x06\x71"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x76\x06\x72\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x77\x01\x69\x00\x03\x00\x02\x00\x02\x00\x02\x06\x78\x06\x79"\
      "\x00\x07\x00\x50\x00\x02\x00\x02\x06\x79\x01\x6b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x7a\x06\x7b\x00\x09\x00\x06\x00\x02\x00\x02\x06\x7b\x01\x6d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x7c\x06\x7d\x00\x05\x01\x6c\x00\xb7"\
      "\x00\x02\x06\x7d\x01\x6f\x00\x03\x00\x02\x00\x02\x00\x02\x06\x7e\x06\x7f"\
      "\x00\x05\x01\x6c\x00\xb7\x00\x02\x06\x7f\x01\x71\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x80\x06\x81\x00\x05\x01\x6c\x00\xb7\x00\x02\x06\x81\x01\x73"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x82\x06\x83\x00\x08\x00\xbb\x00\x01"\
      "\x00\x02\x06\x83\x06\x87\x00\x05\x01\x78\x00\xbd\x00\x02\x06\x84\x06\x87"\
      "\x00\x05\x01\x7c\x00\xbf\x00\x02\x06\x85\x06\x87\x00\x05\x01\x86\x00\xc4"\
      "\x00\x02\x06\x86\x06\x82\x00\x03\x00\x02\x00\x02\x00\x02\x06\x86\x06\x84"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x86\x06\x85\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x87\x06\x9a\x00\x03\x00\x02\x00\x02\x00\x02\x06\x88\x06\x89"\
      "\x00\x0c\x00\x0a\x00\x02\x00\x02\x06\x89\x06\x8a\x00\x07\x00\x43\x00\x02"\
      "\x00\x02\x06\x8a\x06\x99\x00\x05\x01\x74\x00\xbb\x00\x0b\x06\x8b\x06\x8c"\
      "\x00\x0c\x00\x0b\x00\x02\x00\x02\x06\x8c\x06\x8d\x00\x07\x00\x4c\x00\x02"\
      "\x00\x02\x06\x8d\x06\x99\x00\x07\x00\x20\x00\x02\x00\x02\x06\x8e\x06\x8f"\
      "\x00\x0c\x00\x07\x00\x02\x00\x02\x06\x8f\x06\x99\x00\x07\x00\x38\x00\x02"\
      "\x00\x02\x06\x90\x06\x91\x00\x0c\x00\x06\x00\x02\x00\x02\x06\x91\x06\x99"\
      "\x00\x07\x00\x53\x00\x02\x00\x02\x06\x92\x06\x93\x00\x0c\x00\x04\x00\x02"\
      "\x00\x02\x06\x93\x06\x94\x00\x07\x00\x42\x00\x02\x00\x02\x06\x94\x06\x99"\
      "\x00\x07\x00\x40\x00\x02\x00\x02\x06\x95\x06\x96\x00\x0c\x00\x03\x00\x02"\
      "\x00\x02\x06\x96\x06\x97\x00\x07\x00\x42\x00\x02\x00\x02\x06\x97\x06\x99"\
      "\x00\x07\x00\x2a\x00\x02\x00\x02\x06\x98\x06\x88\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x98\x06\x8b\x00\x03\x00\x02\x00\x02\x00\x02\x06\x98\x06\x8e"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x98\x06\x90\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x98\x06\x92\x00\x03\x00\x02\x00\x02\x00\x02\x06\x98\x06\x95"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x99\x06\x9c\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x9a\x06\x98\x00\x03\x00\x02\x00\x02\x00\x02\x06\x9a\x06\x9b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\x9b\x01\x75\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\x9c\x06\x9a\x00\x03\x00\x02\x00\x02\x00\x02\x06\x9d\x06\x9f"\
      "\x00\x07\x00\x4b\x00\x02\x00\x02\x06\x9e\x06\xa0\x00\x05\x01\x2c\x00\x97"\
      "\x00\x02\x06\x9f\x06\x9e\x00\x03\x00\x02\x00\x02\x00\x02\x06\x9f\x06\xa0"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xa0\x06\xa1\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xa1\x06\xa2\x00\x05\x01\x74\x00\xbb\x00\x02\x06\xa2\x01\x77"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xa3\x06\xa5\x00\x05\x01\x7a\x00\xbe"\
      "\x00\x02\x06\xa4\x06\xa6\x00\x05\x00\x4e\x00\x28\x00\x02\x06\xa5\x06\xa4"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xa5\x06\xa6\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xa6\x06\xaf\x00\x03\x00\x02\x00\x02\x00\x02\x06\xa7\x06\xa9"\
      "\x00\x05\x01\x7a\x00\xbe\x00\x02\x06\xa8\x06\xaa\x00\x05\x00\x4e\x00\x28"\
      "\x00\x02\x06\xa9\x06\xa8\x00\x03\x00\x02\x00\x02\x00\x02\x06\xa9\x06\xaa"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xaa\x06\xab\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xab\x06\xac\x00\x07\x00\x42\x00\x02\x00\x02\x06\xac\x06\xad"\
      "\x00\x05\x01\x78\x00\xbd\x00\x02\x06\xad\x06\xaf\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xae\x06\xa3\x00\x03\x00\x02\x00\x02\x00\x02\x06\xae\x06\xa7"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xaf\x01\x79\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xb0\x06\xb1\x00\x05\x01\x92\x00\xca\x00\x02\x06\xb1\x01\x7b"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xb2\x06\xb4\x00\x07\x00\x15\x00\x02"\
      "\x00\x02\x06\xb3\x06\xb5\x00\x05\x01\x7e\x00\xc0\x00\x02\x06\xb4\x06\xb3"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xb4\x06\xb5\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xb5\x06\xb6\x00\x03\x00\x02\x00\x02\x00\x02\x06\xb6\x06\xb7"\
      "\x00\x07\x00\x5a\x00\x02\x00\x02\x06\xb7\x01\x7d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xb8\x06\xba\x00\x05\x01\x80\x00\xc1\x00\x02\x06\xb9\x06\xbb"\
      "\x00\x07\x00\x45\x00\x02\x00\x02\x06\xba\x06\xb9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xba\x06\xbb\x00\x03\x00\x02\x00\x02\x00\x02\x06\xbb\x01\x7f"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xbc\x06\xc2\x00\x05\x01\x82\x00\xc2"\
      "\x00\x02\x06\xbd\x06\xbe\x00\x05\x01\x82\x00\xc2\x00\x02\x06\xbe\x06\xbf"\
      "\x00\x07\x00\x17\x00\x02\x00\x02\x06\xbf\x06\xc0\x00\x05\x01\x80\x00\xc1"\
      "\x00\x02\x06\xc0\x06\xc2\x00\x03\x00\x02\x00\x02\x00\x02\x06\xc1\x06\xbc"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xc1\x06\xbd\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xc2\x01\x81\x00\x03\x00\x02\x00\x02\x00\x02\x06\xc3\x06\xc5"\
      "\x00\x05\x01\x2c\x00\x97\x00\x02\x06\xc4\x06\xc3\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xc4\x06\xc5\x00\x03\x00\x02\x00\x02\x00\x02\x06\xc5\x06\xc7"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xc6\x06\xc8\x00\x07\x00\x3c\x00\x02"\
      "\x00\x02\x06\xc7\x06\xc6\x00\x03\x00\x02\x00\x02\x00\x02\x06\xc7\x06\xc8"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xc8\x06\xc9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xc9\x06\xd1\x00\x05\x01\x74\x00\xbb\x00\x02\x06\xca\x06\xcc"\
      "\x00\x07\x00\x3c\x00\x02\x00\x02\x06\xcb\x06\xca\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xcb\x06\xcc\x00\x03\x00\x02\x00\x02\x00\x02\x06\xcc\x06\xcd"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xcd\x06\xce\x00\x05\x01\x84\x00\xc3"\
      "\x00\x02\x06\xce\x06\xcf\x00\x05\x01\x76\x00\xbc\x00\x02\x06\xcf\x06\xd1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xd0\x06\xc4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xd0\x06\xcb\x00\x03\x00\x02\x00\x02\x00\x02\x06\xd1\x01\x83"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xd2\x06\xd3\x00\x05\x01\x92\x00\xca"\
      "\x00\x02\x06\xd3\x01\x85\x00\x03\x00\x02\x00\x02\x00\x02\x06\xd4\x06\xd5"\
      "\x00\x07\x00\x2d\x00\x02\x00\x02\x06\xd5\x06\xd7\x00\x07\x00\x1f\x00\x02"\
      "\x00\x02\x06\xd6\x06\xd8\x00\x05\x01\x88\x00\xc5\x00\x02\x06\xd7\x06\xd6"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xd7\x06\xd8\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xd8\x06\xd9\x00\x03\x00\x02\x00\x02\x00\x02\x06\xd9\x06\xda"\
      "\x00\x07\x00\x4f\x00\x02\x00\x02\x06\xda\x01\x87\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xdb\x06\xe1\x00\x05\x01\x8a\x00\xc6\x00\x02\x06\xdc\x06\xdd"\
      "\x00\x05\x01\x8a\x00\xc6\x00\x02\x06\xdd\x06\xde\x00\x07\x00\x17\x00\x02"\
      "\x00\x02\x06\xde\x06\xdf\x00\x05\x01\x88\x00\xc5\x00\x02\x06\xdf\x06\xe1"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xe0\x06\xdb\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xe0\x06\xdc\x00\x03\x00\x02\x00\x02\x00\x02\x06\xe1\x01\x89"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xe2\x06\xe3\x00\x05\x01\x78\x00\xbd"\
      "\x00\x02\x06\xe3\x01\x8b\x00\x03\x00\x02\x00\x02\x00\x02\x06\xe4\x06\xe5"\
      "\x00\x05\x01\x74\x00\xbb\x00\x02\x06\xe5\x06\xe6\x00\x07\x00\x42\x00\x02"\
      "\x00\x02\x06\xe6\x06\xe7\x00\x07\x00\x40\x00\x02\x00\x02\x06\xe7\x06\xed"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xe8\x06\xe9\x00\x05\x01\x74\x00\xbb"\
      "\x00\x02\x06\xe9\x06\xea\x00\x07\x00\x42\x00\x02\x00\x02\x06\xea\x06\xeb"\
      "\x00\x07\x00\x2a\x00\x02\x00\x02\x06\xeb\x06\xed\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xec\x06\xe4\x00\x03\x00\x02\x00\x02\x00\x02\x06\xec\x06\xe8"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xed\x01\x8d\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xee\x06\xef\x00\x07\x00\x4b\x00\x02\x00\x02\x06\xef\x06\xf0"\
      "\x00\x05\x01\x90\x00\xc9\x00\x02\x06\xf0\x01\x8f\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xf1\x06\xf6\x00\x05\x01\x78\x00\xbd\x00\x02\x06\xf2\x06\xf3"\
      "\x00\x07\x00\x17\x00\x02\x00\x02\x06\xf3\x06\xf5\x00\x05\x01\x78\x00\xbd"\
      "\x00\x02\x06\xf4\x06\xf2\x00\x03\x00\x02\x00\x02\x00\x02\x06\xf5\x06\xf8"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xf6\x06\xf4\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xf6\x06\xf7\x00\x03\x00\x02\x00\x02\x00\x02\x06\xf7\x01\x91"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xf8\x06\xf6\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xf9\x06\xfc\x00\x07\x00\x60\x00\x02\x00\x02\x06\xfa\x06\xfc"\
      "\x00\x05\x01\x96\x00\xcc\x00\x02\x06\xfb\x06\xf9\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x06\xfb\x06\xfa\x00\x03\x00\x02\x00\x02\x00\x02\x06\xfc\x01\x93"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x06\xfd\x06\xfe\x00\x09\x00\x07\x00\x02"\
      "\x00\x02\x06\xfe\x01\x95\x00\x03\x00\x02\x00\x02\x00\x02\x06\xff\x07\x00"\
      "\x00\x09\x00\x08\x00\x02\x00\x02\x07\x00\x01\x97\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x07\x01\x07\x07\x00\x05\x01\x92\x00\xca\x00\x02\x07\x02\x07\x03"\
      "\x00\x05\x01\x92\x00\xca\x00\x02\x07\x03\x07\x04\x00\x07\x00\x17\x00\x02"\
      "\x00\x02\x07\x04\x07\x05\x00\x05\x01\x98\x00\xcd\x00\x02\x07\x05\x07\x07"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x07\x06\x07\x01\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x07\x06\x07\x02\x00\x03\x00\x02\x00\x02\x00\x02\x07\x07\x01\x99"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x07\x08\x07\x0c\x00\x05\x01\x9c\x00\xcf"\
      "\x00\x02\x07\x09\x07\x0c\x00\x07\x00\x66\x00\x02\x00\x02\x07\x0a\x07\x0c"\
      "\x00\x07\x00\x67\x00\x02\x00\x02\x07\x0b\x07\x08\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x07\x0b\x07\x09\x00\x03\x00\x02\x00\x02\x00\x02\x07\x0b\x07\x0a"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x07\x0c\x01\x9b\x00\x03\x00\x02\x00\x02"\
      "\x00\x02\x07\x0d\x07\x0e\x00\x09\x00\x09\x00\x02\x00\x02\x07\x0e\x01\x9d"\
      "\x00\x03\x00\x02\x00\x02\x00\x02\x00\xd1\x01\xa0\x01\xa2\x01\xa9\x01\xad"\
      "\x01\xb1\x01\xb5\x01\xba\x01\xbc\x01\xc1\x01\xc7\x01\xcb\x01\xcf\x01\xd3"\
      "\x01\xd8\x01\xdc\x01\xe0\x01\xe3\x01\xe7\x01\xf5\x01\xfe\x02\x04\x02\x08"\
      "\x02\x0e\x02\x14\x02\x1a\x02\x28\x02\x30\x02\x34\x02\x47\x02\x52\x02\x56"\
      "\x02\x5a\x02\x60\x02\x65\x02\x6e\x02\x79\x02\x83\x02\x87\x02\x91\x02\xa0"\
      "\x02\xb3\x02\xb7\x02\xbb\x02\xc1\x02\xc6\x02\xca\x02\xd5\x02\xd9\x02\xdc"\
      "\x02\xdf\x02\xe9\x02\xee\x03\x09\x03\x0d\x03\x10\x03\x13\x03\x1c\x03\x25"\
      "\x03\x28\x03\x2e\x03\x32\x03\x3b\x03\x44\x03\x47\x03\x4c\x03\x53\x03\x5c"\
      "\x03\x5f\x03\x63\x03\x68\x03\x6c\x03\x7e\x03\x84\x03\x87\x03\x8d\x03\x91"\
      "\x03\x95\x03\x9d\x03\xa4\x03\xa8\x03\xaf\x03\xb2\x03\xb5\x03\xb8\x03\xbc"\
      "\x03\xc0\x03\xc3\x03\xc7\x03\xcb\x03\xcf\x03\xd2\x03\xd5\x03\xd9\x03\xdd"\
      "\x03\xe3\x03\xe7\x03\xea\x03\xee\x03\xf2\x03\xf8\x03\xfc\x03\xff\x04\x09"\
      "\x04\x0d\x04\x15\x04\x1b\x04\x21\x04\x25\x04\x28\x04\x32\x04\x36\x04\x3c"\
      "\x04\x41\x04\x44\x04\x4c\x04\x51\x04\x56\x04\x59\x04\x61\x04\x66\x04\x6b"\
      "\x04\x73\x04\x7c\x04\x80\x04\x8a\x04\x90\x04\x9a\x04\x9d\x04\xa1\x04\xa7"\
      "\x04\xaa\x04\xb1\x04\xb9\x04\xbf\x04\xcf\x04\xd2\x04\xd9\x04\xe0\x04\xf6"\
      "\x04\xf9\x05\x08\x05\x0c\x05\x11\x05\x17\x05\x1e\x05\x29\x05\x2d\x05\x36"\
      "\x05\x3c\x05\x41\x05\x45\x05\x53\x05\x59\x05\x60\x05\x65\x05\x69\x05\x6e"\
      "\x05\x73\x05\x7b\x05\x82\x05\x8b\x05\xa0\x05\xac\x05\xbd\x05\xbf\x05\xcf"\
      "\x05\xd2\x05\xd8\x05\xe1\x05\xea\x05\xee\x05\xf4\x05\xfa\x06\x05\x06\x09"\
      "\x06\x1f\x06\x25\x06\x36\x06\x3d\x06\x43\x06\x4a\x06\x51\x06\x58\x06\x66"\
      "\x06\x6f\x06\x76\x06\x86\x06\x98\x06\x9a\x06\x9f\x06\xa5\x06\xa9\x06\xae"\
      "\x06\xb4\x06\xba\x06\xc1\x06\xc4\x06\xc7\x06\xcb\x06\xd0\x06\xd7\x06\xe0"\
      "\x06\xec\x06\xf6\x06\xfb\x07\x06\x07\x0b".bytes
      end		

    EOF = Token.EOF
    T__92=1
    T__91=2
    T__90=3
    T__89=4
    T__88=5
    T__87=6
    T__86=7
    T__85=8
    T__84=9
    T__83=10
    T__82=11
    T__81=12
    T__80=13
    T__79=14
    T__78=15
    T__77=16
    T__76=17
    T__75=18
    T__74=19
    T__73=20
    T__72=21
    T__71=22
    T__70=23
    T__69=24
    T__68=25
    T__67=26
    T__66=27
    T__65=28
    T__64=29
    T__63=30
    T__62=31
    T__61=32
    T__60=33
    T__59=34
    T__58=35
    T__57=36
    T__56=37
    T__55=38
    T__54=39
    T__53=40
    T__52=41
    T__51=42
    T__50=43
    T__49=44
    T__48=45
    T__47=46
    T__46=47
    T__45=48
    T__44=49
    T__43=50
    T__42=51
    T__41=52
    T__40=53
    T__39=54
    T__38=55
    T__37=56
    T__36=57
    T__35=58
    T__34=59
    T__33=60
    T__32=61
    T__31=62
    T__30=63
    T__29=64
    T__28=65
    T__27=66
    T__26=67
    T__25=68
    T__24=69
    T__23=70
    T__22=71
    T__21=72
    T__20=73
    T__19=74
    T__18=75
    T__17=76
    T__16=77
    T__15=78
    T__14=79
    T__13=80
    T__12=81
    T__11=82
    T__10=83
    T__9=84
    T__8=85
    T__7=86
    T__6=87
    T__5=88
    T__4=89
    T__3=90
    T__2=91
    T__1=92
    T__0=93
    Identifier=94
    Implicit_parameter_name=95
    Binary_literal=96
    Octal_literal=97
    Decimal_literal=98
    Hexadecimal_literal=99
    Floating_point_literal=100
    String_literal=101
    Escaped_character=102
    WS=103
    Block_comment=104
    Line_comment=105

    RULE_top_level = 0
    RULE_statement = 1
    RULE_statements = 2
    RULE_loop_statement = 3
    RULE_for_statement = 4
    RULE_for_init = 5
    RULE_for_in_statement = 6
    RULE_while_statement = 7
    RULE_while_condition = 8
    RULE_do_while_statement = 9
    RULE_branch_statement = 10
    RULE_if_statement = 11
    RULE_if_condition = 12
    RULE_else_clause = 13
    RULE_switch_statement = 14
    RULE_switch_cases = 15
    RULE_switch_case = 16
    RULE_case_label = 17
    RULE_case_item_list = 18
    RULE_default_label = 19
    RULE_guard_clause = 20
    RULE_guard_expression = 21
    RULE_labeled_statement = 22
    RULE_statement_label = 23
    RULE_label_name = 24
    RULE_control_transfer_statement = 25
    RULE_break_statement = 26
    RULE_continue_statement = 27
    RULE_fallthrough_statement = 28
    RULE_return_statement = 29
    RULE_generic_parameter_clause = 30
    RULE_generic_parameter_list = 31
    RULE_generic_parameter = 32
    RULE_requirement_clause = 33
    RULE_requirement_list = 34
    RULE_requirement = 35
    RULE_conformance_requirement = 36
    RULE_same_type_requirement = 37
    RULE_generic_argument_clause = 38
    RULE_generic_argument_list = 39
    RULE_generic_argument = 40
    RULE_declaration = 41
    RULE_declarations = 42
    RULE_declaration_specifiers = 43
    RULE_declaration_specifier = 44
    RULE_code_block = 45
    RULE_import_declaration = 46
    RULE_import_kind = 47
    RULE_import_path = 48
    RULE_import_path_identifier = 49
    RULE_constant_declaration = 50
    RULE_pattern_initializer_list = 51
    RULE_pattern_initializer = 52
    RULE_initializer = 53
    RULE_variable_declaration = 54
    RULE_variable_declaration_head = 55
    RULE_variable_name = 56
    RULE_getter_setter_block = 57
    RULE_getter_clause = 58
    RULE_setter_clause = 59
    RULE_setter_name = 60
    RULE_getter_setter_keyword_block = 61
    RULE_getter_keyword_clause = 62
    RULE_setter_keyword_clause = 63
    RULE_willSet_didSet_block = 64
    RULE_willSet_clause = 65
    RULE_didSet_clause = 66
    RULE_typealias_declaration = 67
    RULE_typealias_head = 68
    RULE_typealias_name = 69
    RULE_typealias_assignment = 70
    RULE_function_declaration = 71
    RULE_function_head = 72
    RULE_function_name = 73
    RULE_function_signature = 74
    RULE_function_result = 75
    RULE_function_body = 76
    RULE_parameter_clauses = 77
    RULE_parameter_clause = 78
    RULE_parameter_list = 79
    RULE_parameter = 80
    RULE_parameter_name = 81
    RULE_local_parameter_name = 82
    RULE_default_argument_clause = 83
    RULE_enum_declaration = 84
    RULE_union_style_enum = 85
    RULE_union_style_enum_members = 86
    RULE_union_style_enum_member = 87
    RULE_union_style_enum_case_clause = 88
    RULE_union_style_enum_case_list = 89
    RULE_union_style_enum_case = 90
    RULE_enum_name = 91
    RULE_enum_case_name = 92
    RULE_raw_value_style_enum = 93
    RULE_raw_value_style_enum_members = 94
    RULE_raw_value_style_enum_member = 95
    RULE_raw_value_style_enum_case_clause = 96
    RULE_raw_value_style_enum_case_list = 97
    RULE_raw_value_style_enum_case = 98
    RULE_raw_value_assignment = 99
    RULE_struct_declaration = 100
    RULE_struct_name = 101
    RULE_struct_body = 102
    RULE_class_declaration = 103
    RULE_class_name = 104
    RULE_class_body = 105
    RULE_protocol_declaration = 106
    RULE_protocol_name = 107
    RULE_protocol_body = 108
    RULE_protocol_member_declaration = 109
    RULE_protocol_member_declarations = 110
    RULE_protocol_property_declaration = 111
    RULE_protocol_method_declaration = 112
    RULE_protocol_initializer_declaration = 113
    RULE_protocol_subscript_declaration = 114
    RULE_protocol_associated_type_declaration = 115
    RULE_initializer_declaration = 116
    RULE_initializer_head = 117
    RULE_initializer_body = 118
    RULE_deinitializer_declaration = 119
    RULE_extension_declaration = 120
    RULE_extension_body = 121
    RULE_subscript_declaration = 122
    RULE_subscript_head = 123
    RULE_subscript_result = 124
    RULE_operator_declaration = 125
    RULE_prefix_operator_declaration = 126
    RULE_postfix_operator_declaration = 127
    RULE_infix_operator_declaration = 128
    RULE_infix_operator_attributes = 129
    RULE_precedence_clause = 130
    RULE_precedence_level = 131
    RULE_associativity_clause = 132
    RULE_associativity = 133
    RULE_pattern = 134
    RULE_wildcard_pattern = 135
    RULE_identifier_pattern = 136
    RULE_value_binding_pattern = 137
    RULE_tuple_pattern = 138
    RULE_tuple_pattern_element_list = 139
    RULE_tuple_pattern_element = 140
    RULE_enum_case_pattern = 141
    RULE_type_casting_pattern = 142
    RULE_is_pattern = 143
    RULE_as_pattern = 144
    RULE_expression_pattern = 145
    RULE_attribute = 146
    RULE_attribute_name = 147
    RULE_attribute_argument_clause = 148
    RULE_attributes = 149
    RULE_balanced_tokens = 150
    RULE_balanced_token = 151
    RULE_expression_list = 152
    RULE_expression = 153
    RULE_in_out_expression = 154
    RULE_assignment_operator = 155
    RULE_conditional_operator = 156
    RULE_type_casting_operator = 157
    RULE_trailing_closure = 158
    RULE_primary_expression = 159
    RULE_literal_expression = 160
    RULE_array_literal = 161
    RULE_array_literal_items = 162
    RULE_array_literal_item = 163
    RULE_dictionary_literal = 164
    RULE_dictionary_literal_items = 165
    RULE_dictionary_literal_item = 166
    RULE_self_expression = 167
    RULE_superclass_expression = 168
    RULE_superclass_method_expression = 169
    RULE_superclass_subscript_expression = 170
    RULE_superclass_initializer_expression = 171
    RULE_closure_expression = 172
    RULE_closure_signature = 173
    RULE_capture_list = 174
    RULE_capture_specifier = 175
    RULE_implicit_member_expression = 176
    RULE_parenthesized_expression = 177
    RULE_expression_element_list = 178
    RULE_expression_element = 179
    RULE_wildcard_expression = 180
    RULE_operator = 181
    RULE_binary_operator = 182
    RULE_prefix_operator = 183
    RULE_postfix_operator = 184
    RULE_type = 185
    RULE_type_annotation = 186
    RULE_type_identifier = 187
    RULE_type_name = 188
    RULE_tuple_type = 189
    RULE_tuple_type_body = 190
    RULE_tuple_type_element_list = 191
    RULE_tuple_type_element = 192
    RULE_element_name = 193
    RULE_protocol_composition_type = 194
    RULE_protocol_identifier_list = 195
    RULE_protocol_identifier = 196
    RULE_metatype_type = 197
    RULE_type_inheritance_clause = 198
    RULE_type_inheritance_list = 199
    RULE_identifier = 200
    RULE_keyword = 201
    RULE_context_sensitive_keyword = 202
    RULE_identifier_list = 203
    RULE_literal = 204
    RULE_integer_literal = 205

    def initialize(input) # input:TokenStream
        super(input)
        self.checkVersion('4.4')
        self.predicates = nil
        @grammarFileName = 'java-escape'
        @tokenNames = [ "<INVALID>", "'default'", "'func'", "'new'", "'associativity'", 
                        "'operator'", "'set'", "'precedence'", "'willSet'", 
                        "'{'", "'while'", "'='", "'^'", "'for'", "'postfix'", 
                        "'get'", "'__FUNCTION__'", "'override'", "'none'", 
                        "'('", "'do'", "','", "'right'", "'unowned(safe)'", 
                        "'__FILE__'", "'var'", "'init'", "'dynamicType'", 
                        "'extension'", "'<'", "']'", "'__LINE__'", "'@'", 
                        "'unowned'", "'#'", "'let'", "'static'", "'+'", 
                        "'infix'", "'struct'", "'Protocol'", "'subscript'", 
                        "'/'", "'protocol'", "'deinit'", "'as'", "'continue'", 
                        "'Self'", "'return'", "'class'", "'\\'", "';'", 
                        "'}'", "'if'", "'?'", "'enum'", "'break'", "'&'", 
                        "'inout'", "'is'", "'switch'", "'*'", "'Type'", 
                        "'weak'", "'.'", "'->'", "'case'", "'...'", "'left'", 
                        "'convenience'", "'__COLUMN__'", "'unowned(unsafe)'", 
                        "'mutating'", "':'", "'['", "'|'", "'=='", "'>'", 
                        "'_'", "'didSet'", "'fallthrough'", "'!'", "'where'", 
                        "'%'", "'else'", "'in'", "'super'", "'self'", "')'", 
                        "'nonmutating'", "'-'", "'prefix'", "'typealias'", 
                        "'import'", "Identifier", "Implicit_parameter_name", 
                        "Binary_literal", "Octal_literal", "Decimal_literal", 
                        "Hexadecimal_literal", "Floating_point_literal", 
                        "String_literal", "Escaped_character", "WS", "Block_comment", 
                        "Line_comment" ]
        @ruleNames =  [ "top_level", "statement", "statements", "loop_statement", 
                        "for_statement", "for_init", "for_in_statement", 
                        "while_statement", "while_condition", "do_while_statement", 
                        "branch_statement", "if_statement", "if_condition", 
                        "else_clause", "switch_statement", "switch_cases", 
                        "switch_case", "case_label", "case_item_list", "default_label", 
                        "guard_clause", "guard_expression", "labeled_statement", 
                        "statement_label", "label_name", "control_transfer_statement", 
                        "break_statement", "continue_statement", "fallthrough_statement", 
                        "return_statement", "generic_parameter_clause", 
                        "generic_parameter_list", "generic_parameter", "requirement_clause", 
                        "requirement_list", "requirement", "conformance_requirement", 
                        "same_type_requirement", "generic_argument_clause", 
                        "generic_argument_list", "generic_argument", "declaration", 
                        "declarations", "declaration_specifiers", "declaration_specifier", 
                        "code_block", "import_declaration", "import_kind", 
                        "import_path", "import_path_identifier", "constant_declaration", 
                        "pattern_initializer_list", "pattern_initializer", 
                        "initializer", "variable_declaration", "variable_declaration_head", 
                        "variable_name", "getter_setter_block", "getter_clause", 
                        "setter_clause", "setter_name", "getter_setter_keyword_block", 
                        "getter_keyword_clause", "setter_keyword_clause", 
                        "willSet_didSet_block", "willSet_clause", "didSet_clause", 
                        "typealias_declaration", "typealias_head", "typealias_name", 
                        "typealias_assignment", "function_declaration", 
                        "function_head", "function_name", "function_signature", 
                        "function_result", "function_body", "parameter_clauses", 
                        "parameter_clause", "parameter_list", "parameter", 
                        "parameter_name", "local_parameter_name", "default_argument_clause", 
                        "enum_declaration", "union_style_enum", "union_style_enum_members", 
                        "union_style_enum_member", "union_style_enum_case_clause", 
                        "union_style_enum_case_list", "union_style_enum_case", 
                        "enum_name", "enum_case_name", "raw_value_style_enum", 
                        "raw_value_style_enum_members", "raw_value_style_enum_member", 
                        "raw_value_style_enum_case_clause", "raw_value_style_enum_case_list", 
                        "raw_value_style_enum_case", "raw_value_assignment", 
                        "struct_declaration", "struct_name", "struct_body", 
                        "class_declaration", "class_name", "class_body", 
                        "protocol_declaration", "protocol_name", "protocol_body", 
                        "protocol_member_declaration", "protocol_member_declarations", 
                        "protocol_property_declaration", "protocol_method_declaration", 
                        "protocol_initializer_declaration", "protocol_subscript_declaration", 
                        "protocol_associated_type_declaration", "initializer_declaration", 
                        "initializer_head", "initializer_body", "deinitializer_declaration", 
                        "extension_declaration", "extension_body", "subscript_declaration", 
                        "subscript_head", "subscript_result", "operator_declaration", 
                        "prefix_operator_declaration", "postfix_operator_declaration", 
                        "infix_operator_declaration", "infix_operator_attributes", 
                        "precedence_clause", "precedence_level", "associativity_clause", 
                        "associativity", "pattern", "wildcard_pattern", 
                        "identifier_pattern", "value_binding_pattern", "tuple_pattern", 
                        "tuple_pattern_element_list", "tuple_pattern_element", 
                        "enum_case_pattern", "type_casting_pattern", "is_pattern", 
                        "as_pattern", "expression_pattern", "attribute", 
                        "attribute_name", "attribute_argument_clause", "attributes", 
                        "balanced_tokens", "balanced_token", "expression_list", 
                        "expression", "in_out_expression", "assignment_operator", 
                        "conditional_operator", "type_casting_operator", 
                        "trailing_closure", "primary_expression", "literal_expression", 
                        "array_literal", "array_literal_items", "array_literal_item", 
                        "dictionary_literal", "dictionary_literal_items", 
                        "dictionary_literal_item", "self_expression", "superclass_expression", 
                        "superclass_method_expression", "superclass_subscript_expression", 
                        "superclass_initializer_expression", "closure_expression", 
                        "closure_signature", "capture_list", "capture_specifier", 
                        "implicit_member_expression", "parenthesized_expression", 
                        "expression_element_list", "expression_element", 
                        "wildcard_expression", "operator", "binary_operator", 
                        "prefix_operator", "postfix_operator", "type", "type_annotation", 
                        "type_identifier", "type_name", "tuple_type", "tuple_type_body", 
                        "tuple_type_element_list", "tuple_type_element", 
                        "element_name", "protocol_composition_type", "protocol_identifier_list", 
                        "protocol_identifier", "metatype_type", "type_inheritance_clause", 
                        "type_inheritance_list", "identifier", "keyword", 
                        "context_sensitive_keyword", "identifier_list", 
                        "literal", "integer_literal" ]

        @atn = ATNDeserializer.new().deserialize(self.class.serializedATN())
        @decisionsToDFA = @atn.decisionToState.each_with_index.map {|ds,i|  DFA.new(ds,i) }
        @sharedContextCache = PredictionContextCache.new()
        self.interp = ParserATNSimulator.new(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
    end


    # RuleFucntion generator
    class Top_levelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def EOF()
            getToken(SwiftParser::EOF, 0)
        end

        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def statement(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::StatementContext)
            else
                getTypedRuleContext(SwiftParser::StatementContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_top_level
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTop_level(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTop_level(self)
            end
        end
    end


    def top_level()
        localctx = SwiftParser::Top_levelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 0, SwiftParser.RULE_top_level)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 416
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__83) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__80) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__73) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__51) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__47) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__40) | (1 << self.T__37) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__33) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__24 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__13 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.T__1 - 64)) | (1 << (self.T__0 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) do
                self.state = 414
                la_ = self.interp.adaptivePredict(self.input,0,self.ctx)
                if la_ == 1 then
                    self.state = 412 
                    self.statement()

                elsif la_ == 2 then
                    self.state = 413 
                    self.expression(0)

                end
                self.state = 418
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
            self.state = 419
             match(SwiftParser::EOF)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class StatementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def branch_statement() 
            getTypedRuleContext(SwiftParser::Branch_statementContext,0)
        end


        def labeled_statement() 
            getTypedRuleContext(SwiftParser::Labeled_statementContext,0)
        end


        def control_transfer_statement() 
            getTypedRuleContext(SwiftParser::Control_transfer_statementContext,0)
        end


        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def loop_statement() 
            getTypedRuleContext(SwiftParser::Loop_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStatement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStatement(self)
            end
        end
    end


    def statement()
        localctx = SwiftParser::StatementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 2, SwiftParser.RULE_statement)
        _la = 0 # Token type
        begin
            self.state = 442
            la_ = self.interp.adaptivePredict(self.input,7,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 421 
                self.expression(0)
                self.state = 423
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 422
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 425 
                self.declaration()
                self.state = 427
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 426
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 429 
                self.loop_statement()
                self.state = 431
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 430
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 433 
                self.branch_statement()
                self.state = 435
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 434
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 437 
                self.labeled_statement()

            elsif la_ == 6 then
                self.enterOuterAlt(localctx, 6)
                self.state = 438 
                self.control_transfer_statement()
                self.state = 440
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 439
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class StatementsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def statement(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::StatementContext)
            else
                getTypedRuleContext(SwiftParser::StatementContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_statements
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStatements(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStatements(self)
            end
        end
    end


    def statements()
        localctx = SwiftParser::StatementsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 4, SwiftParser.RULE_statements)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 445 
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            # Trying to use Rubyism. This will probably break
            begin  # while true do
                self.state = 444 
                self.statement()
                self.state = 447 
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            #    if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__83) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__80) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__73) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__51) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__47) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__40) | (1 << self.T__37) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__33) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__24 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__13 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.T__1 - 64)) | (1 << (self.T__0 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0)) then
            #        break
            #    end
            end until not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__83) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__80) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__73) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__51) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__47) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__40) | (1 << self.T__37) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__33) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__24 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__13 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.T__1 - 64)) | (1 << (self.T__0 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0))
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Loop_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def for_statement() 
            getTypedRuleContext(SwiftParser::For_statementContext,0)
        end


        def while_statement() 
            getTypedRuleContext(SwiftParser::While_statementContext,0)
        end


        def for_in_statement() 
            getTypedRuleContext(SwiftParser::For_in_statementContext,0)
        end


        def do_while_statement() 
            getTypedRuleContext(SwiftParser::Do_while_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_loop_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLoop_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLoop_statement(self)
            end
        end
    end


    def loop_statement()
        localctx = SwiftParser::Loop_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 6, SwiftParser.RULE_loop_statement)
        begin
            self.state = 453
            la_ = self.interp.adaptivePredict(self.input,9,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 449 
                self.for_statement()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 450 
                self.for_in_statement()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 451 
                self.while_statement()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 452 
                self.do_while_statement()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class For_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def for_init() 
            getTypedRuleContext(SwiftParser::For_initContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_for_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFor_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFor_statement(self)
            end
        end
    end


    def for_statement()
        localctx = SwiftParser::For_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 8, SwiftParser.RULE_for_statement)
        _la = 0 # Token type
        begin
            self.state = 481
            la_ = self.interp.adaptivePredict(self.input,16,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 455
                 match(SwiftParser::T__80)
                self.state = 457
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 456 
                    self.for_init()
                end #LL1OptionalBlockSingleAlt

                self.state = 459
                 match(SwiftParser::T__42)
                self.state = 461
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 460 
                    self.expression(0)
                end #LL1OptionalBlockSingleAlt

                self.state = 463
                 match(SwiftParser::T__42)
                self.state = 465
                la_ = self.interp.adaptivePredict(self.input,12,self.ctx)
                if la_ == 1
                    self.state = 464 
                    self.expression(0)

                end
                self.state = 467 
                self.code_block()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 468
                 match(SwiftParser::T__80)

                self.state = 470
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 469 
                    self.for_init()
                end #LL1OptionalBlockSingleAlt

                self.state = 472
                 match(SwiftParser::T__42)
                self.state = 474
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 473 
                    self.expression(0)
                end #LL1OptionalBlockSingleAlt

                self.state = 476
                 match(SwiftParser::T__42)
                self.state = 478
                la_ = self.interp.adaptivePredict(self.input,15,self.ctx)
                if la_ == 1
                    self.state = 477 
                    self.expression(0)

                end
                self.state = 480 
                self.code_block()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class For_initContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression_list() 
            getTypedRuleContext(SwiftParser::Expression_listContext,0)
        end


        def variable_declaration() 
            getTypedRuleContext(SwiftParser::Variable_declarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_for_init
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFor_init(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFor_init(self)
            end
        end
    end


    def for_init()
        localctx = SwiftParser::For_initContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 10, SwiftParser.RULE_for_init)
        begin
            self.state = 485
            la_ = self.interp.adaptivePredict(self.input,17,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 483 
                self.variable_declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 484 
                self.expression_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class For_in_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_for_in_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFor_in_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFor_in_statement(self)
            end
        end
    end


    def for_in_statement()
        localctx = SwiftParser::For_in_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 12, SwiftParser.RULE_for_in_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 487
             match(SwiftParser::T__80)
            self.state = 488 
            self.pattern(0)
            self.state = 489
             match(SwiftParser::T__8)
            self.state = 490 
            self.expression(0)
            self.state = 491 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class While_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def while_condition() 
            getTypedRuleContext(SwiftParser::While_conditionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_while_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWhile_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWhile_statement(self)
            end
        end
    end


    def while_statement()
        localctx = SwiftParser::While_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 14, SwiftParser.RULE_while_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 493
             match(SwiftParser::T__83)
            self.state = 494 
            self.while_condition()
            self.state = 495 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class While_conditionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_while_condition
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWhile_condition(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWhile_condition(self)
            end
        end
    end


    def while_condition()
        localctx = SwiftParser::While_conditionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 16, SwiftParser.RULE_while_condition)
        begin
            self.state = 499
            la_ = self.interp.adaptivePredict(self.input,18,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 497 
                self.expression(0)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 498 
                self.declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Do_while_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def while_condition() 
            getTypedRuleContext(SwiftParser::While_conditionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_do_while_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDo_while_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDo_while_statement(self)
            end
        end
    end


    def do_while_statement()
        localctx = SwiftParser::Do_while_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 18, SwiftParser.RULE_do_while_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 501
             match(SwiftParser::T__73)
            self.state = 502 
            self.code_block()
            self.state = 503
             match(SwiftParser::T__83)
            self.state = 504 
            self.while_condition()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Branch_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def if_statement() 
            getTypedRuleContext(SwiftParser::If_statementContext,0)
        end


        def switch_statement() 
            getTypedRuleContext(SwiftParser::Switch_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_branch_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBranch_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBranch_statement(self)
            end
        end
    end


    def branch_statement()
        localctx = SwiftParser::Branch_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 20, SwiftParser.RULE_branch_statement)
        begin
            self.state = 508
            token = self.input.LA(1)
            if [self.T__40].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 506 
                self.if_statement()

            elsif [self.T__33].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 507 
                self.switch_statement()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class If_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def else_clause() 
            getTypedRuleContext(SwiftParser::Else_clauseContext,0)
        end


        def if_condition() 
            getTypedRuleContext(SwiftParser::If_conditionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_if_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIf_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIf_statement(self)
            end
        end
    end


    def if_statement()
        localctx = SwiftParser::If_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 22, SwiftParser.RULE_if_statement)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 510
             match(SwiftParser::T__40)
            self.state = 511 
            self.if_condition()
            self.state = 512 
            self.code_block()
            self.state = 514
            _la = self.input.LA(1)
            if _la==SwiftParser.T__9 then  # Ll1Optional Bloc Single Alt
                self.state = 513 
                self.else_clause()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class If_conditionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_if_condition
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIf_condition(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIf_condition(self)
            end
        end
    end


    def if_condition()
        localctx = SwiftParser::If_conditionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 24, SwiftParser.RULE_if_condition)
        begin
            self.state = 518
            la_ = self.interp.adaptivePredict(self.input,21,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 516 
                self.expression(0)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 517 
                self.declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Else_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def if_statement() 
            getTypedRuleContext(SwiftParser::If_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_else_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterElse_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitElse_clause(self)
            end
        end
    end


    def else_clause()
        localctx = SwiftParser::Else_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 26, SwiftParser.RULE_else_clause)
        begin
            self.state = 524
            la_ = self.interp.adaptivePredict(self.input,22,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 520
                 match(SwiftParser::T__9)
                self.state = 521 
                self.code_block()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 522
                 match(SwiftParser::T__9)
                self.state = 523 
                self.if_statement()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Switch_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def switch_cases() 
            getTypedRuleContext(SwiftParser::Switch_casesContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_switch_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSwitch_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSwitch_statement(self)
            end
        end
    end


    def switch_statement()
        localctx = SwiftParser::Switch_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 28, SwiftParser.RULE_switch_statement)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 526
             match(SwiftParser::T__33)
            self.state = 527 
            self.expression(0)
            self.state = 528
             match(SwiftParser::T__84)
            self.state = 530
            _la = self.input.LA(1)
            if _la==SwiftParser.T__92 or _la==SwiftParser.T__27 then  # Ll1Optional Bloc Single Alt
                self.state = 529 
                self.switch_cases()
            end #LL1OptionalBlockSingleAlt

            self.state = 532
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Switch_casesContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def switch_case() 
            getTypedRuleContext(SwiftParser::Switch_caseContext,0)
        end


        def switch_cases() 
            getTypedRuleContext(SwiftParser::Switch_casesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_switch_cases
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSwitch_cases(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSwitch_cases(self)
            end
        end
    end


    def switch_cases()
        localctx = SwiftParser::Switch_casesContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 30, SwiftParser.RULE_switch_cases)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 534 
            self.switch_case()
            self.state = 536
            _la = self.input.LA(1)
            if _la==SwiftParser.T__92 or _la==SwiftParser.T__27 then  # Ll1Optional Bloc Single Alt
                self.state = 535 
                self.switch_cases()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Switch_caseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def case_label() 
            getTypedRuleContext(SwiftParser::Case_labelContext,0)
        end


        def statements() 
            getTypedRuleContext(SwiftParser::StatementsContext,0)
        end


        def default_label() 
            getTypedRuleContext(SwiftParser::Default_labelContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_switch_case
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSwitch_case(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSwitch_case(self)
            end
        end
    end


    def switch_case()
        localctx = SwiftParser::Switch_caseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 32, SwiftParser.RULE_switch_case)
        begin
            self.state = 550
            la_ = self.interp.adaptivePredict(self.input,25,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 538 
                self.case_label()
                self.state = 539 
                self.statements()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 541 
                self.default_label()
                self.state = 542 
                self.statements()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 544 
                self.case_label()
                self.state = 545
                 match(SwiftParser::T__42)

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 547 
                self.default_label()
                self.state = 548
                 match(SwiftParser::T__42)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Case_labelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def case_item_list() 
            getTypedRuleContext(SwiftParser::Case_item_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_case_label
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCase_label(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCase_label(self)
            end
        end
    end


    def case_label()
        localctx = SwiftParser::Case_labelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 34, SwiftParser.RULE_case_label)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 552
             match(SwiftParser::T__27)
            self.state = 553 
            self.case_item_list()
            self.state = 554
             match(SwiftParser::T__20)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Case_item_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def case_item_list() 
            getTypedRuleContext(SwiftParser::Case_item_listContext,0)
        end


        def pattern(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::PatternContext)
            else
                getTypedRuleContext(SwiftParser::PatternContext,i)
            end
        end

        def guard_clause(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Guard_clauseContext)
            else
                getTypedRuleContext(SwiftParser::Guard_clauseContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_case_item_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCase_item_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCase_item_list(self)
            end
        end
    end


    def case_item_list()
        localctx = SwiftParser::Case_item_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 36, SwiftParser.RULE_case_item_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 556 
            self.pattern(0)
            self.state = 558
            _la = self.input.LA(1)
            if _la==SwiftParser.T__11 then  # Ll1Optional Bloc Single Alt
                self.state = 557 
                self.guard_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 560 
            self.pattern(0)
            self.state = 562
            _la = self.input.LA(1)
            if _la==SwiftParser.T__11 then  # Ll1Optional Bloc Single Alt
                self.state = 561 
                self.guard_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 564
             match(SwiftParser::T__72)
            self.state = 565 
            self.case_item_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Default_labelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_default_label
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDefault_label(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDefault_label(self)
            end
        end
    end


    def default_label()
        localctx = SwiftParser::Default_labelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 38, SwiftParser.RULE_default_label)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 567
             match(SwiftParser::T__92)
            self.state = 568
             match(SwiftParser::T__20)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Guard_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def guard_expression() 
            getTypedRuleContext(SwiftParser::Guard_expressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_guard_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGuard_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGuard_clause(self)
            end
        end
    end


    def guard_clause()
        localctx = SwiftParser::Guard_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 40, SwiftParser.RULE_guard_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 570
             match(SwiftParser::T__11)
            self.state = 571 
            self.guard_expression()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Guard_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_guard_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGuard_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGuard_expression(self)
            end
        end
    end


    def guard_expression()
        localctx = SwiftParser::Guard_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 42, SwiftParser.RULE_guard_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 573 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Labeled_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def statement_label() 
            getTypedRuleContext(SwiftParser::Statement_labelContext,0)
        end


        def switch_statement() 
            getTypedRuleContext(SwiftParser::Switch_statementContext,0)
        end


        def loop_statement() 
            getTypedRuleContext(SwiftParser::Loop_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_labeled_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLabeled_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLabeled_statement(self)
            end
        end
    end


    def labeled_statement()
        localctx = SwiftParser::Labeled_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 44, SwiftParser.RULE_labeled_statement)
        begin
            self.state = 581
            la_ = self.interp.adaptivePredict(self.input,28,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 575 
                self.statement_label()
                self.state = 576 
                self.loop_statement()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 578 
                self.statement_label()
                self.state = 579 
                self.switch_statement()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Statement_labelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def label_name() 
            getTypedRuleContext(SwiftParser::Label_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_statement_label
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStatement_label(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStatement_label(self)
            end
        end
    end


    def statement_label()
        localctx = SwiftParser::Statement_labelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 46, SwiftParser.RULE_statement_label)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 583 
            self.label_name()
            self.state = 584
             match(SwiftParser::T__20)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Label_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_label_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLabel_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLabel_name(self)
            end
        end
    end


    def label_name()
        localctx = SwiftParser::Label_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 48, SwiftParser.RULE_label_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 586 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Control_transfer_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def return_statement() 
            getTypedRuleContext(SwiftParser::Return_statementContext,0)
        end


        def fallthrough_statement() 
            getTypedRuleContext(SwiftParser::Fallthrough_statementContext,0)
        end


        def break_statement() 
            getTypedRuleContext(SwiftParser::Break_statementContext,0)
        end


        def continue_statement() 
            getTypedRuleContext(SwiftParser::Continue_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_control_transfer_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterControl_transfer_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitControl_transfer_statement(self)
            end
        end
    end


    def control_transfer_statement()
        localctx = SwiftParser::Control_transfer_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 50, SwiftParser.RULE_control_transfer_statement)
        begin
            self.state = 592
            token = self.input.LA(1)
            if [self.T__37].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 588 
                self.break_statement()

            elsif [self.T__47].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 589 
                self.continue_statement()

            elsif [self.T__13].member? token then 
                self.enterOuterAlt(localctx, 3)
                self.state = 590 
                self.fallthrough_statement()

            elsif [self.T__45].member? token then 
                self.enterOuterAlt(localctx, 4)
                self.state = 591 
                self.return_statement()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Break_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def label_name() 
            getTypedRuleContext(SwiftParser::Label_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_break_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBreak_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBreak_statement(self)
            end
        end
    end


    def break_statement()
        localctx = SwiftParser::Break_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 52, SwiftParser.RULE_break_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 594
             match(SwiftParser::T__37)
            self.state = 596
            la_ = self.interp.adaptivePredict(self.input,30,self.ctx)
            if la_ == 1
                self.state = 595 
                self.label_name()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Continue_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def label_name() 
            getTypedRuleContext(SwiftParser::Label_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_continue_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterContinue_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitContinue_statement(self)
            end
        end
    end


    def continue_statement()
        localctx = SwiftParser::Continue_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 54, SwiftParser.RULE_continue_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 598
             match(SwiftParser::T__47)
            self.state = 600
            la_ = self.interp.adaptivePredict(self.input,31,self.ctx)
            if la_ == 1
                self.state = 599 
                self.label_name()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Fallthrough_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_fallthrough_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFallthrough_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFallthrough_statement(self)
            end
        end
    end


    def fallthrough_statement()
        localctx = SwiftParser::Fallthrough_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 56, SwiftParser.RULE_fallthrough_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 602
             match(SwiftParser::T__13)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Return_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_return_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterReturn_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitReturn_statement(self)
            end
        end
    end


    def return_statement()
        localctx = SwiftParser::Return_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 58, SwiftParser.RULE_return_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 604
             match(SwiftParser::T__45)
            self.state = 606
            la_ = self.interp.adaptivePredict(self.input,32,self.ctx)
            if la_ == 1
                self.state = 605 
                self.expression(0)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_parameter_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def requirement_clause() 
            getTypedRuleContext(SwiftParser::Requirement_clauseContext,0)
        end


        def generic_parameter_list() 
            getTypedRuleContext(SwiftParser::Generic_parameter_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_parameter_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_parameter_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_parameter_clause(self)
            end
        end
    end


    def generic_parameter_clause()
        localctx = SwiftParser::Generic_parameter_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 60, SwiftParser.RULE_generic_parameter_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 608
             match(SwiftParser::T__64)
            self.state = 609 
            self.generic_parameter_list()
            self.state = 611
            _la = self.input.LA(1)
            if _la==SwiftParser.T__11 then  # Ll1Optional Bloc Single Alt
                self.state = 610 
                self.requirement_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 613
             match(SwiftParser::T__16)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_parameter_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_parameter_list() 
            getTypedRuleContext(SwiftParser::Generic_parameter_listContext,0)
        end


        def generic_parameter() 
            getTypedRuleContext(SwiftParser::Generic_parameterContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_parameter_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_parameter_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_parameter_list(self)
            end
        end
    end


    def generic_parameter_list()
        localctx = SwiftParser::Generic_parameter_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 62, SwiftParser.RULE_generic_parameter_list)
        begin
            self.state = 620
            la_ = self.interp.adaptivePredict(self.input,34,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 615 
                self.generic_parameter()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 616 
                self.generic_parameter()
                self.state = 617
                 match(SwiftParser::T__72)
                self.state = 618 
                self.generic_parameter_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_parameterContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def protocol_composition_type() 
            getTypedRuleContext(SwiftParser::Protocol_composition_typeContext,0)
        end


        def type_name() 
            getTypedRuleContext(SwiftParser::Type_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_parameter
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_parameter(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_parameter(self)
            end
        end
    end


    def generic_parameter()
        localctx = SwiftParser::Generic_parameterContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 64, SwiftParser.RULE_generic_parameter)
        begin
            self.state = 631
            la_ = self.interp.adaptivePredict(self.input,35,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 622 
                self.type_name()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 623 
                self.type_name()
                self.state = 624
                 match(SwiftParser::T__20)
                self.state = 625 
                self.type_identifier()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 627 
                self.type_name()
                self.state = 628
                 match(SwiftParser::T__20)
                self.state = 629 
                self.protocol_composition_type()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Requirement_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def requirement_list() 
            getTypedRuleContext(SwiftParser::Requirement_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_requirement_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRequirement_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRequirement_clause(self)
            end
        end
    end


    def requirement_clause()
        localctx = SwiftParser::Requirement_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 66, SwiftParser.RULE_requirement_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 633
             match(SwiftParser::T__11)
            self.state = 634 
            self.requirement_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Requirement_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def requirement() 
            getTypedRuleContext(SwiftParser::RequirementContext,0)
        end


        def requirement_list() 
            getTypedRuleContext(SwiftParser::Requirement_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_requirement_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRequirement_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRequirement_list(self)
            end
        end
    end


    def requirement_list()
        localctx = SwiftParser::Requirement_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 68, SwiftParser.RULE_requirement_list)
        begin
            self.state = 641
            la_ = self.interp.adaptivePredict(self.input,36,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 636 
                self.requirement()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 637 
                self.requirement()
                self.state = 638
                 match(SwiftParser::T__72)
                self.state = 639 
                self.requirement_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class RequirementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def conformance_requirement() 
            getTypedRuleContext(SwiftParser::Conformance_requirementContext,0)
        end


        def same_type_requirement() 
            getTypedRuleContext(SwiftParser::Same_type_requirementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_requirement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRequirement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRequirement(self)
            end
        end
    end


    def requirement()
        localctx = SwiftParser::RequirementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 70, SwiftParser.RULE_requirement)
        begin
            self.state = 645
            la_ = self.interp.adaptivePredict(self.input,37,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 643 
                self.conformance_requirement()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 644 
                self.same_type_requirement()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Conformance_requirementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_composition_type() 
            getTypedRuleContext(SwiftParser::Protocol_composition_typeContext,0)
        end


        def type_identifier(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Type_identifierContext)
            else
                getTypedRuleContext(SwiftParser::Type_identifierContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_conformance_requirement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterConformance_requirement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitConformance_requirement(self)
            end
        end
    end


    def conformance_requirement()
        localctx = SwiftParser::Conformance_requirementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 72, SwiftParser.RULE_conformance_requirement)
        begin
            self.state = 655
            la_ = self.interp.adaptivePredict(self.input,38,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 647 
                self.type_identifier()
                self.state = 648
                 match(SwiftParser::T__20)
                self.state = 649 
                self.type_identifier()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 651 
                self.type_identifier()
                self.state = 652
                 match(SwiftParser::T__20)
                self.state = 653 
                self.protocol_composition_type()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Same_type_requirementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Type_identifierContext)
            else
                getTypedRuleContext(SwiftParser::Type_identifierContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_same_type_requirement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSame_type_requirement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSame_type_requirement(self)
            end
        end
    end


    def same_type_requirement()
        localctx = SwiftParser::Same_type_requirementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 74, SwiftParser.RULE_same_type_requirement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 657 
            self.type_identifier()
            self.state = 658
             match(SwiftParser::T__17)
            self.state = 659 
            self.type_identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_argument_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_argument_list() 
            getTypedRuleContext(SwiftParser::Generic_argument_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_argument_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_argument_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_argument_clause(self)
            end
        end
    end


    def generic_argument_clause()
        localctx = SwiftParser::Generic_argument_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 76, SwiftParser.RULE_generic_argument_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 661
             match(SwiftParser::T__64)
            self.state = 662 
            self.generic_argument_list()
            self.state = 663
             match(SwiftParser::T__16)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_argument_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_argument(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Generic_argumentContext)
            else
                getTypedRuleContext(SwiftParser::Generic_argumentContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_argument_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_argument_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_argument_list(self)
            end
        end
    end


    def generic_argument_list()
        localctx = SwiftParser::Generic_argument_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 78, SwiftParser.RULE_generic_argument_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 665 
            self.generic_argument()
            self.state = 670
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 666
                 match(SwiftParser::T__72)
                self.state = 667 
                self.generic_argument()
                self.state = 672
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_argumentContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_argument
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_argument(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_argument(self)
            end
        end
    end


    def generic_argument()
        localctx = SwiftParser::Generic_argumentContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 80, SwiftParser.RULE_generic_argument)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 673 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class DeclarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator_declaration() 
            getTypedRuleContext(SwiftParser::Operator_declarationContext,0)
        end


        def variable_declaration() 
            getTypedRuleContext(SwiftParser::Variable_declarationContext,0)
        end


        def protocol_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_declarationContext,0)
        end


        def constant_declaration() 
            getTypedRuleContext(SwiftParser::Constant_declarationContext,0)
        end


        def typealias_declaration() 
            getTypedRuleContext(SwiftParser::Typealias_declarationContext,0)
        end


        def deinitializer_declaration() 
            getTypedRuleContext(SwiftParser::Deinitializer_declarationContext,0)
        end


        def function_declaration() 
            getTypedRuleContext(SwiftParser::Function_declarationContext,0)
        end


        def subscript_declaration() 
            getTypedRuleContext(SwiftParser::Subscript_declarationContext,0)
        end


        def import_declaration() 
            getTypedRuleContext(SwiftParser::Import_declarationContext,0)
        end


        def enum_declaration() 
            getTypedRuleContext(SwiftParser::Enum_declarationContext,0)
        end


        def extension_declaration() 
            getTypedRuleContext(SwiftParser::Extension_declarationContext,0)
        end


        def class_declaration() 
            getTypedRuleContext(SwiftParser::Class_declarationContext,0)
        end


        def struct_declaration() 
            getTypedRuleContext(SwiftParser::Struct_declarationContext,0)
        end


        def initializer_declaration() 
            getTypedRuleContext(SwiftParser::Initializer_declarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeclaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeclaration(self)
            end
        end
    end


    def declaration()
        localctx = SwiftParser::DeclarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 82, SwiftParser.RULE_declaration)
        begin
            self.state = 689
            la_ = self.interp.adaptivePredict(self.input,40,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 675 
                self.import_declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 676 
                self.constant_declaration()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 677 
                self.variable_declaration()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 678 
                self.typealias_declaration()

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 679 
                self.function_declaration()

            elsif la_ == 6 then
                self.enterOuterAlt(localctx, 6)
                self.state = 680 
                self.enum_declaration()

            elsif la_ == 7 then
                self.enterOuterAlt(localctx, 7)
                self.state = 681 
                self.struct_declaration()

            elsif la_ == 8 then
                self.enterOuterAlt(localctx, 8)
                self.state = 682 
                self.class_declaration()

            elsif la_ == 9 then
                self.enterOuterAlt(localctx, 9)
                self.state = 683 
                self.protocol_declaration()

            elsif la_ == 10 then
                self.enterOuterAlt(localctx, 10)
                self.state = 684 
                self.initializer_declaration()

            elsif la_ == 11 then
                self.enterOuterAlt(localctx, 11)
                self.state = 685 
                self.deinitializer_declaration()

            elsif la_ == 12 then
                self.enterOuterAlt(localctx, 12)
                self.state = 686 
                self.extension_declaration()

            elsif la_ == 13 then
                self.enterOuterAlt(localctx, 13)
                self.state = 687 
                self.subscript_declaration()

            elsif la_ == 14 then
                self.enterOuterAlt(localctx, 14)
                self.state = 688 
                self.operator_declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class DeclarationsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declarations() 
            getTypedRuleContext(SwiftParser::DeclarationsContext,0)
        end


        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_declarations
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeclarations(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeclarations(self)
            end
        end
    end


    def declarations()
        localctx = SwiftParser::DeclarationsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 84, SwiftParser.RULE_declarations)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 691 
            self.declaration()
            self.state = 693
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__24 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.T__1 - 68)) | (1 << (self.T__0 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 692 
                self.declarations()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Declaration_specifiersContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declaration_specifier() 
            getTypedRuleContext(SwiftParser::Declaration_specifierContext,0)
        end


        def declaration_specifiers() 
            getTypedRuleContext(SwiftParser::Declaration_specifiersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_declaration_specifiers
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeclaration_specifiers(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeclaration_specifiers(self)
            end
        end
    end


    def declaration_specifiers()
        localctx = SwiftParser::Declaration_specifiersContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 86, SwiftParser.RULE_declaration_specifiers)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 695 
            self.declaration_specifier()
            self.state = 697
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 696 
                self.declaration_specifiers()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Declaration_specifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_declaration_specifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeclaration_specifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeclaration_specifier(self)
            end
        end
    end


    def declaration_specifier()
        localctx = SwiftParser::Declaration_specifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 88, SwiftParser.RULE_declaration_specifier)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 699
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Code_blockContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def statements() 
            getTypedRuleContext(SwiftParser::StatementsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_code_block
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCode_block(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCode_block(self)
            end
        end
    end


    def code_block()
        localctx = SwiftParser::Code_blockContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 90, SwiftParser.RULE_code_block)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 701
             match(SwiftParser::T__84)
            self.state = 703
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__83) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__80) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__73) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__51) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__47) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__40) | (1 << self.T__37) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__33) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__24 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__13 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.T__1 - 64)) | (1 << (self.T__0 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 702 
                self.statements()
            end #LL1OptionalBlockSingleAlt

            self.state = 705
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Import_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def import_kind() 
            getTypedRuleContext(SwiftParser::Import_kindContext,0)
        end


        def import_path() 
            getTypedRuleContext(SwiftParser::Import_pathContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_import_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImport_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImport_declaration(self)
            end
        end
    end


    def import_declaration()
        localctx = SwiftParser::Import_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 92, SwiftParser.RULE_import_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 708
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 707 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 710
             match(SwiftParser::T__0)
            self.state = 712
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__68) | (1 << self.T__54) | (1 << self.T__50) | (1 << self.T__44) | (1 << self.T__38))) != 0) or _la==SwiftParser.T__1 then  # Ll1Optional Bloc Single Alt
                self.state = 711 
                self.import_kind()
            end #LL1OptionalBlockSingleAlt

            self.state = 714 
            self.import_path()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Import_kindContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_import_kind
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImport_kind(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImport_kind(self)
            end
        end
    end


    def import_kind()
        localctx = SwiftParser::Import_kindContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 94, SwiftParser.RULE_import_kind)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 716
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__68) | (1 << self.T__54) | (1 << self.T__50) | (1 << self.T__44) | (1 << self.T__38))) != 0) or _la==SwiftParser.T__1)  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Import_pathContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def import_path_identifier() 
            getTypedRuleContext(SwiftParser::Import_path_identifierContext,0)
        end


        def import_path() 
            getTypedRuleContext(SwiftParser::Import_pathContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_import_path
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImport_path(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImport_path(self)
            end
        end
    end


    def import_path()
        localctx = SwiftParser::Import_pathContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 96, SwiftParser.RULE_import_path)
        begin
            self.state = 723
            la_ = self.interp.adaptivePredict(self.input,46,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 718 
                self.import_path_identifier()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 719 
                self.import_path_identifier()
                self.state = 720
                 match(SwiftParser::T__29)
                self.state = 721 
                self.import_path()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Import_path_identifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_import_path_identifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImport_path_identifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImport_path_identifier(self)
            end
        end
    end


    def import_path_identifier()
        localctx = SwiftParser::Import_path_identifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 98, SwiftParser.RULE_import_path_identifier)
        begin
            self.state = 727
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 725 
                self.identifier()

            elsif [self.T__82, self.T__81, self.T__64, self.T__56, self.T__51, self.T__43, self.T__36, self.T__32, self.T__29, self.T__18, self.T__16, self.T__12, self.T__10, self.T__3].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 726 
                self.operator()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Constant_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def declaration_specifiers() 
            getTypedRuleContext(SwiftParser::Declaration_specifiersContext,0)
        end


        def pattern_initializer_list() 
            getTypedRuleContext(SwiftParser::Pattern_initializer_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_constant_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterConstant_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitConstant_declaration(self)
            end
        end
    end


    def constant_declaration()
        localctx = SwiftParser::Constant_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 100, SwiftParser.RULE_constant_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 730
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 729 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 733
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 732 
                self.declaration_specifiers()
            end #LL1OptionalBlockSingleAlt

            self.state = 735
             match(SwiftParser::T__58)
            self.state = 736 
            self.pattern_initializer_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Pattern_initializer_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern_initializer(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Pattern_initializerContext)
            else
                getTypedRuleContext(SwiftParser::Pattern_initializerContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_pattern_initializer_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPattern_initializer_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPattern_initializer_list(self)
            end
        end
    end


    def pattern_initializer_list()
        localctx = SwiftParser::Pattern_initializer_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 102, SwiftParser.RULE_pattern_initializer_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 738 
            self.pattern_initializer()
            self.state = 743
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 739
                 match(SwiftParser::T__72)
                self.state = 740 
                self.pattern_initializer()
                self.state = 745
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Pattern_initializerContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def initializer() 
            getTypedRuleContext(SwiftParser::InitializerContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_pattern_initializer
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPattern_initializer(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPattern_initializer(self)
            end
        end
    end


    def pattern_initializer()
        localctx = SwiftParser::Pattern_initializerContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 104, SwiftParser.RULE_pattern_initializer)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 746 
            self.pattern(0)
            self.state = 748
            la_ = self.interp.adaptivePredict(self.input,51,self.ctx)
            if la_ == 1
                self.state = 747 
                self.initializer()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class InitializerContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_initializer
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInitializer(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInitializer(self)
            end
        end
    end


    def initializer()
        localctx = SwiftParser::InitializerContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 106, SwiftParser.RULE_initializer)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 750
             match(SwiftParser::T__82)
            self.state = 751 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Variable_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def willSet_didSet_block() 
            getTypedRuleContext(SwiftParser::WillSet_didSet_blockContext,0)
        end


        def variable_declaration_head() 
            getTypedRuleContext(SwiftParser::Variable_declaration_headContext,0)
        end


        def variable_name() 
            getTypedRuleContext(SwiftParser::Variable_nameContext,0)
        end


        def getter_setter_keyword_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_keyword_blockContext,0)
        end


        def pattern_initializer_list() 
            getTypedRuleContext(SwiftParser::Pattern_initializer_listContext,0)
        end


        def getter_setter_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_blockContext,0)
        end


        def initializer() 
            getTypedRuleContext(SwiftParser::InitializerContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_variable_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterVariable_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitVariable_declaration(self)
            end
        end
    end


    def variable_declaration()
        localctx = SwiftParser::Variable_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 108, SwiftParser.RULE_variable_declaration)
        _la = 0 # Token type
        begin
            self.state = 779
            la_ = self.interp.adaptivePredict(self.input,53,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 753 
                self.variable_declaration_head()
                self.state = 754 
                self.pattern_initializer_list()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 756 
                self.variable_declaration_head()
                self.state = 757 
                self.variable_name()
                self.state = 758 
                self.type_annotation()
                self.state = 759 
                self.code_block()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 761 
                self.variable_declaration_head()
                self.state = 762 
                self.variable_name()
                self.state = 763 
                self.type_annotation()
                self.state = 764 
                self.getter_setter_block()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 766 
                self.variable_declaration_head()
                self.state = 767 
                self.variable_name()
                self.state = 768 
                self.type_annotation()
                self.state = 769 
                self.getter_setter_keyword_block()

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 771 
                self.variable_declaration_head()
                self.state = 772 
                self.variable_name()
                self.state = 773 
                self.type_annotation()
                self.state = 775
                _la = self.input.LA(1)
                if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                    self.state = 774 
                    self.initializer()
                end #LL1OptionalBlockSingleAlt

                self.state = 777 
                self.willSet_didSet_block()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Variable_declaration_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def declaration_specifiers() 
            getTypedRuleContext(SwiftParser::Declaration_specifiersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_variable_declaration_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterVariable_declaration_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitVariable_declaration_head(self)
            end
        end
    end


    def variable_declaration_head()
        localctx = SwiftParser::Variable_declaration_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 110, SwiftParser.RULE_variable_declaration_head)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 782
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 781 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 785
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 784 
                self.declaration_specifiers()
            end #LL1OptionalBlockSingleAlt

            self.state = 787
             match(SwiftParser::T__68)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Variable_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_variable_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterVariable_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitVariable_name(self)
            end
        end
    end


    def variable_name()
        localctx = SwiftParser::Variable_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 112, SwiftParser.RULE_variable_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 789 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Getter_setter_blockContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def setter_clause() 
            getTypedRuleContext(SwiftParser::Setter_clauseContext,0)
        end


        def getter_clause() 
            getTypedRuleContext(SwiftParser::Getter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_getter_setter_block
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGetter_setter_block(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGetter_setter_block(self)
            end
        end
    end


    def getter_setter_block()
        localctx = SwiftParser::Getter_setter_blockContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 114, SwiftParser.RULE_getter_setter_block)
        _la = 0 # Token type
        begin
            self.state = 803
            la_ = self.interp.adaptivePredict(self.input,57,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 791
                 match(SwiftParser::T__84)
                self.state = 792 
                self.getter_clause()
                self.state = 794
                _la = self.input.LA(1)
                if _la==SwiftParser.T__87 or _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 793 
                    self.setter_clause()
                end #LL1OptionalBlockSingleAlt

                self.state = 796
                 match(SwiftParser::T__41)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 798
                 match(SwiftParser::T__84)
                self.state = 799 
                self.setter_clause()
                self.state = 800 
                self.getter_clause()
                self.state = 801
                 match(SwiftParser::T__41)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Getter_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_getter_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGetter_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGetter_clause(self)
            end
        end
    end


    def getter_clause()
        localctx = SwiftParser::Getter_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 116, SwiftParser.RULE_getter_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 806
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 805 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 808
             match(SwiftParser::T__78)
            self.state = 809 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Setter_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def setter_name() 
            getTypedRuleContext(SwiftParser::Setter_nameContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_setter_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSetter_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSetter_clause(self)
            end
        end
    end


    def setter_clause()
        localctx = SwiftParser::Setter_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 118, SwiftParser.RULE_setter_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 811 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 814
             match(SwiftParser::T__87)
            self.state = 816
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 815 
                self.setter_name()
            end #LL1OptionalBlockSingleAlt

            self.state = 818 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Setter_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_setter_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSetter_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSetter_name(self)
            end
        end
    end


    def setter_name()
        localctx = SwiftParser::Setter_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 120, SwiftParser.RULE_setter_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 820 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Getter_setter_keyword_blockContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def getter_keyword_clause() 
            getTypedRuleContext(SwiftParser::Getter_keyword_clauseContext,0)
        end


        def setter_keyword_clause() 
            getTypedRuleContext(SwiftParser::Setter_keyword_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_getter_setter_keyword_block
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGetter_setter_keyword_block(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGetter_setter_keyword_block(self)
            end
        end
    end


    def getter_setter_keyword_block()
        localctx = SwiftParser::Getter_setter_keyword_blockContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 122, SwiftParser.RULE_getter_setter_keyword_block)
        _la = 0 # Token type
        begin
            self.state = 834
            la_ = self.interp.adaptivePredict(self.input,62,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 822
                 match(SwiftParser::T__84)
                self.state = 823 
                self.getter_keyword_clause()
                self.state = 825
                _la = self.input.LA(1)
                if _la==SwiftParser.T__87 or _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 824 
                    self.setter_keyword_clause()
                end #LL1OptionalBlockSingleAlt

                self.state = 827
                 match(SwiftParser::T__41)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 829
                 match(SwiftParser::T__84)
                self.state = 830 
                self.setter_keyword_clause()
                self.state = 831 
                self.getter_keyword_clause()
                self.state = 832
                 match(SwiftParser::T__41)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Getter_keyword_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_getter_keyword_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGetter_keyword_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGetter_keyword_clause(self)
            end
        end
    end


    def getter_keyword_clause()
        localctx = SwiftParser::Getter_keyword_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 124, SwiftParser.RULE_getter_keyword_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 837
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 836 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 839
             match(SwiftParser::T__78)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Setter_keyword_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_setter_keyword_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSetter_keyword_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSetter_keyword_clause(self)
            end
        end
    end


    def setter_keyword_clause()
        localctx = SwiftParser::Setter_keyword_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 126, SwiftParser.RULE_setter_keyword_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 842
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 841 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 844
             match(SwiftParser::T__87)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class WillSet_didSet_blockContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def willSet_clause() 
            getTypedRuleContext(SwiftParser::WillSet_clauseContext,0)
        end


        def didSet_clause() 
            getTypedRuleContext(SwiftParser::DidSet_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_willSet_didSet_block
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWillSet_didSet_block(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWillSet_didSet_block(self)
            end
        end
    end


    def willSet_didSet_block()
        localctx = SwiftParser::WillSet_didSet_blockContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 128, SwiftParser.RULE_willSet_didSet_block)
        _la = 0 # Token type
        begin
            self.state = 858
            la_ = self.interp.adaptivePredict(self.input,66,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 846
                 match(SwiftParser::T__84)
                self.state = 847 
                self.willSet_clause()
                self.state = 849
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 or _la==SwiftParser.T__14 then  # Ll1Optional Bloc Single Alt
                    self.state = 848 
                    self.didSet_clause()
                end #LL1OptionalBlockSingleAlt

                self.state = 851
                 match(SwiftParser::T__41)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 853
                 match(SwiftParser::T__84)
                self.state = 854 
                self.didSet_clause()
                self.state = 855 
                self.willSet_clause()
                self.state = 856
                 match(SwiftParser::T__41)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class WillSet_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def setter_name() 
            getTypedRuleContext(SwiftParser::Setter_nameContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_willSet_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWillSet_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWillSet_clause(self)
            end
        end
    end


    def willSet_clause()
        localctx = SwiftParser::WillSet_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 130, SwiftParser.RULE_willSet_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 861
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 860 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 863
             match(SwiftParser::T__85)
            self.state = 865
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 864 
                self.setter_name()
            end #LL1OptionalBlockSingleAlt

            self.state = 867 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class DidSet_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def setter_name() 
            getTypedRuleContext(SwiftParser::Setter_nameContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_didSet_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDidSet_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDidSet_clause(self)
            end
        end
    end


    def didSet_clause()
        localctx = SwiftParser::DidSet_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 132, SwiftParser.RULE_didSet_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 870
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 869 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 872
             match(SwiftParser::T__14)
            self.state = 874
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 873 
                self.setter_name()
            end #LL1OptionalBlockSingleAlt

            self.state = 876 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Typealias_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def typealias_head() 
            getTypedRuleContext(SwiftParser::Typealias_headContext,0)
        end


        def typealias_assignment() 
            getTypedRuleContext(SwiftParser::Typealias_assignmentContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_typealias_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTypealias_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTypealias_declaration(self)
            end
        end
    end


    def typealias_declaration()
        localctx = SwiftParser::Typealias_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 134, SwiftParser.RULE_typealias_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 878 
            self.typealias_head()
            self.state = 879 
            self.typealias_assignment()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Typealias_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def typealias_name() 
            getTypedRuleContext(SwiftParser::Typealias_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_typealias_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTypealias_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTypealias_head(self)
            end
        end
    end


    def typealias_head()
        localctx = SwiftParser::Typealias_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 136, SwiftParser.RULE_typealias_head)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 881
             match(SwiftParser::T__1)
            self.state = 882 
            self.typealias_name()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Typealias_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_typealias_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTypealias_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTypealias_name(self)
            end
        end
    end


    def typealias_name()
        localctx = SwiftParser::Typealias_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 138, SwiftParser.RULE_typealias_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 884 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Typealias_assignmentContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_typealias_assignment
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTypealias_assignment(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTypealias_assignment(self)
            end
        end
    end


    def typealias_assignment()
        localctx = SwiftParser::Typealias_assignmentContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 140, SwiftParser.RULE_typealias_assignment)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 886
             match(SwiftParser::T__82)
            self.state = 887 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def function_body() 
            getTypedRuleContext(SwiftParser::Function_bodyContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def function_head() 
            getTypedRuleContext(SwiftParser::Function_headContext,0)
        end


        def function_name() 
            getTypedRuleContext(SwiftParser::Function_nameContext,0)
        end


        def function_signature() 
            getTypedRuleContext(SwiftParser::Function_signatureContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_declaration(self)
            end
        end
    end


    def function_declaration()
        localctx = SwiftParser::Function_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 142, SwiftParser.RULE_function_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 889 
            self.function_head()
            self.state = 890 
            self.function_name()
            self.state = 892
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 891 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 894 
            self.function_signature()
            self.state = 895 
            self.function_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def declaration_specifiers() 
            getTypedRuleContext(SwiftParser::Declaration_specifiersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_head(self)
            end
        end
    end


    def function_head()
        localctx = SwiftParser::Function_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 144, SwiftParser.RULE_function_head)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 898
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 897 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 901
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 900 
                self.declaration_specifiers()
            end #LL1OptionalBlockSingleAlt

            self.state = 903
             match(SwiftParser::T__91)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_name(self)
            end
        end
    end


    def function_name()
        localctx = SwiftParser::Function_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 146, SwiftParser.RULE_function_name)
        begin
            self.state = 907
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 905 
                self.identifier()

            elsif [self.T__82, self.T__81, self.T__64, self.T__56, self.T__51, self.T__43, self.T__36, self.T__32, self.T__29, self.T__18, self.T__16, self.T__12, self.T__10, self.T__3].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 906 
                self.operator()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_signatureContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def parameter_clauses() 
            getTypedRuleContext(SwiftParser::Parameter_clausesContext,0)
        end


        def function_result() 
            getTypedRuleContext(SwiftParser::Function_resultContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_signature
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_signature(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_signature(self)
            end
        end
    end


    def function_signature()
        localctx = SwiftParser::Function_signatureContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 148, SwiftParser.RULE_function_signature)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 909 
            self.parameter_clauses()
            self.state = 911
            _la = self.input.LA(1)
            if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                self.state = 910 
                self.function_result()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_resultContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_result
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_result(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_result(self)
            end
        end
    end


    def function_result()
        localctx = SwiftParser::Function_resultContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 150, SwiftParser.RULE_function_result)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 913
             match(SwiftParser::T__28)
            self.state = 915
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 914 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 917 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_body(self)
            end
        end
    end


    def function_body()
        localctx = SwiftParser::Function_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 152, SwiftParser.RULE_function_body)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 919 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parameter_clausesContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def parameter_clauses() 
            getTypedRuleContext(SwiftParser::Parameter_clausesContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter_clauses
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter_clauses(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter_clauses(self)
            end
        end
    end


    def parameter_clauses()
        localctx = SwiftParser::Parameter_clausesContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 154, SwiftParser.RULE_parameter_clauses)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 921 
            self.parameter_clause()
            self.state = 923
            _la = self.input.LA(1)
            if _la==SwiftParser.T__74 then  # Ll1Optional Bloc Single Alt
                self.state = 922 
                self.parameter_clauses()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parameter_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def parameter_list() 
            getTypedRuleContext(SwiftParser::Parameter_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter_clause(self)
            end
        end
    end


    def parameter_clause()
        localctx = SwiftParser::Parameter_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 156, SwiftParser.RULE_parameter_clause)
        _la = 0 # Token type
        begin
            self.state = 934
            la_ = self.interp.adaptivePredict(self.input,79,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 925
                 match(SwiftParser::T__74)
                self.state = 926
                 match(SwiftParser::T__5)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 927
                 match(SwiftParser::T__74)
                self.state = 928 
                self.parameter_list()
                self.state = 930
                _la = self.input.LA(1)
                if _la==SwiftParser.T__26 then  # Ll1Optional Bloc Single Alt
                    self.state = 929
                     match(SwiftParser::T__26)
                end #LL1OptionalBlockSingleAlt

                self.state = 932
                 match(SwiftParser::T__5)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parameter_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def parameter() 
            getTypedRuleContext(SwiftParser::ParameterContext,0)
        end


        def parameter_list() 
            getTypedRuleContext(SwiftParser::Parameter_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter_list(self)
            end
        end
    end


    def parameter_list()
        localctx = SwiftParser::Parameter_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 158, SwiftParser.RULE_parameter_list)
        begin
            self.state = 941
            la_ = self.interp.adaptivePredict(self.input,80,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 936 
                self.parameter()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 937 
                self.parameter()
                self.state = 938
                 match(SwiftParser::T__72)
                self.state = 939 
                self.parameter_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class ParameterContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def default_argument_clause() 
            getTypedRuleContext(SwiftParser::Default_argument_clauseContext,0)
        end


        def local_parameter_name() 
            getTypedRuleContext(SwiftParser::Local_parameter_nameContext,0)
        end


        def parameter_name() 
            getTypedRuleContext(SwiftParser::Parameter_nameContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter(self)
            end
        end
    end


    def parameter()
        localctx = SwiftParser::ParameterContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 160, SwiftParser.RULE_parameter)
        _la = 0 # Token type
        begin
            self.state = 979
            la_ = self.interp.adaptivePredict(self.input,91,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 944
                la_ = self.interp.adaptivePredict(self.input,81,self.ctx)
                if la_ == 1
                    self.state = 943
                     match(SwiftParser::T__35)

                end
                self.state = 947
                _la = self.input.LA(1)
                if _la==SwiftParser.T__58 then  # Ll1Optional Bloc Single Alt
                    self.state = 946
                     match(SwiftParser::T__58)
                end #LL1OptionalBlockSingleAlt

                self.state = 950
                _la = self.input.LA(1)
                if _la==SwiftParser.T__59 then  # Ll1Optional Bloc Single Alt
                    self.state = 949
                     match(SwiftParser::T__59)
                end #LL1OptionalBlockSingleAlt

                self.state = 952 
                self.parameter_name()
                self.state = 954
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__15 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 953 
                    self.local_parameter_name()
                end #LL1OptionalBlockSingleAlt

                self.state = 956 
                self.type_annotation()
                self.state = 958
                _la = self.input.LA(1)
                if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                    self.state = 957 
                    self.default_argument_clause()
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 961
                _la = self.input.LA(1)
                if _la==SwiftParser.T__35 then  # Ll1Optional Bloc Single Alt
                    self.state = 960
                     match(SwiftParser::T__35)
                end #LL1OptionalBlockSingleAlt

                self.state = 963
                 match(SwiftParser::T__68)
                self.state = 965
                _la = self.input.LA(1)
                if _la==SwiftParser.T__59 then  # Ll1Optional Bloc Single Alt
                    self.state = 964
                     match(SwiftParser::T__59)
                end #LL1OptionalBlockSingleAlt

                self.state = 967 
                self.parameter_name()
                self.state = 969
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__15 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 968 
                    self.local_parameter_name()
                end #LL1OptionalBlockSingleAlt

                self.state = 971 
                self.type_annotation()
                self.state = 973
                _la = self.input.LA(1)
                if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                    self.state = 972 
                    self.default_argument_clause()
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 976
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 975 
                    self.attributes()
                end #LL1OptionalBlockSingleAlt

                self.state = 978 
                self.type(0)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parameter_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter_name(self)
            end
        end
    end


    def parameter_name()
        localctx = SwiftParser::Parameter_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 162, SwiftParser.RULE_parameter_name)
        begin
            self.state = 983
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 981 
                self.identifier()

            elsif [self.T__15].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 982
                 match(SwiftParser::T__15)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Local_parameter_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_local_parameter_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLocal_parameter_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLocal_parameter_name(self)
            end
        end
    end


    def local_parameter_name()
        localctx = SwiftParser::Local_parameter_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 164, SwiftParser.RULE_local_parameter_name)
        begin
            self.state = 987
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 985 
                self.identifier()

            elsif [self.T__15].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 986
                 match(SwiftParser::T__15)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Default_argument_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_default_argument_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDefault_argument_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDefault_argument_clause(self)
            end
        end
    end


    def default_argument_clause()
        localctx = SwiftParser::Default_argument_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 166, SwiftParser.RULE_default_argument_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 989
             match(SwiftParser::T__82)
            self.state = 990 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Enum_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def union_style_enum() 
            getTypedRuleContext(SwiftParser::Union_style_enumContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def raw_value_style_enum() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enumContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_enum_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterEnum_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitEnum_declaration(self)
            end
        end
    end


    def enum_declaration()
        localctx = SwiftParser::Enum_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 168, SwiftParser.RULE_enum_declaration)
        _la = 0 # Token type
        begin
            self.state = 1000
            la_ = self.interp.adaptivePredict(self.input,96,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 993
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 992 
                    self.attributes()
                end #LL1OptionalBlockSingleAlt

                self.state = 995 
                self.union_style_enum()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 997
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 996 
                    self.attributes()
                end #LL1OptionalBlockSingleAlt

                self.state = 999 
                self.raw_value_style_enum()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enumContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def union_style_enum_members() 
            getTypedRuleContext(SwiftParser::Union_style_enum_membersContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def enum_name() 
            getTypedRuleContext(SwiftParser::Enum_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum(self)
            end
        end
    end


    def union_style_enum()
        localctx = SwiftParser::Union_style_enumContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 170, SwiftParser.RULE_union_style_enum)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1002 
            self.enum_name()
            self.state = 1004
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1003 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1006
             match(SwiftParser::T__84)
            self.state = 1008
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__25 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__22 - 66)) | (1 << (self.T__21 - 66)) | (1 << (self.T__14 - 66)) | (1 << (self.T__4 - 66)) | (1 << (self.T__2 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)) | (1 << (self.Identifier - 66)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1007 
                self.union_style_enum_members()
            end #LL1OptionalBlockSingleAlt

            self.state = 1010
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_membersContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def union_style_enum_member() 
            getTypedRuleContext(SwiftParser::Union_style_enum_memberContext,0)
        end


        def union_style_enum_members() 
            getTypedRuleContext(SwiftParser::Union_style_enum_membersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_members
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_members(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_members(self)
            end
        end
    end


    def union_style_enum_members()
        localctx = SwiftParser::Union_style_enum_membersContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 172, SwiftParser.RULE_union_style_enum_members)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1012 
            self.union_style_enum_member()
            self.state = 1014
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__25 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__22 - 66)) | (1 << (self.T__21 - 66)) | (1 << (self.T__14 - 66)) | (1 << (self.T__4 - 66)) | (1 << (self.T__2 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)) | (1 << (self.Identifier - 66)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1013 
                self.union_style_enum_members()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_memberContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def union_style_enum_case_clause() 
            getTypedRuleContext(SwiftParser::Union_style_enum_case_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_member
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_member(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_member(self)
            end
        end
    end


    def union_style_enum_member()
        localctx = SwiftParser::Union_style_enum_memberContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 174, SwiftParser.RULE_union_style_enum_member)
        begin
            self.state = 1018
            la_ = self.interp.adaptivePredict(self.input,100,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1016 
                self.declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1017 
                self.union_style_enum_case_clause()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_case_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def union_style_enum_case_list() 
            getTypedRuleContext(SwiftParser::Union_style_enum_case_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_case_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_case_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_case_clause(self)
            end
        end
    end


    def union_style_enum_case_clause()
        localctx = SwiftParser::Union_style_enum_case_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 176, SwiftParser.RULE_union_style_enum_case_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1021
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1020 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1023
             match(SwiftParser::T__27)
            self.state = 1024 
            self.union_style_enum_case_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_case_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def union_style_enum_case_list() 
            getTypedRuleContext(SwiftParser::Union_style_enum_case_listContext,0)
        end


        def union_style_enum_case() 
            getTypedRuleContext(SwiftParser::Union_style_enum_caseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_case_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_case_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_case_list(self)
            end
        end
    end


    def union_style_enum_case_list()
        localctx = SwiftParser::Union_style_enum_case_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 178, SwiftParser.RULE_union_style_enum_case_list)
        begin
            self.state = 1031
            la_ = self.interp.adaptivePredict(self.input,102,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1026 
                self.union_style_enum_case()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1027 
                self.union_style_enum_case()
                self.state = 1028
                 match(SwiftParser::T__72)
                self.state = 1029 
                self.union_style_enum_case_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_caseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_type() 
            getTypedRuleContext(SwiftParser::Tuple_typeContext,0)
        end


        def enum_case_name() 
            getTypedRuleContext(SwiftParser::Enum_case_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_case
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_case(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_case(self)
            end
        end
    end


    def union_style_enum_case()
        localctx = SwiftParser::Union_style_enum_caseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 180, SwiftParser.RULE_union_style_enum_case)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1033 
            self.enum_case_name()
            self.state = 1035
            _la = self.input.LA(1)
            if _la==SwiftParser.T__74 then  # Ll1Optional Bloc Single Alt
                self.state = 1034 
                self.tuple_type()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Enum_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_enum_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterEnum_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitEnum_name(self)
            end
        end
    end


    def enum_name()
        localctx = SwiftParser::Enum_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 182, SwiftParser.RULE_enum_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1037 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Enum_case_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_enum_case_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterEnum_case_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitEnum_case_name(self)
            end
        end
    end


    def enum_case_name()
        localctx = SwiftParser::Enum_case_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 184, SwiftParser.RULE_enum_case_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1039 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enumContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def enum_name() 
            getTypedRuleContext(SwiftParser::Enum_nameContext,0)
        end


        def raw_value_style_enum_members() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_membersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum(self)
            end
        end
    end


    def raw_value_style_enum()
        localctx = SwiftParser::Raw_value_style_enumContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 186, SwiftParser.RULE_raw_value_style_enum)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1041 
            self.enum_name()
            self.state = 1043
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1042 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1045
             match(SwiftParser::T__20)
            self.state = 1046 
            self.type_identifier()
            self.state = 1047
             match(SwiftParser::T__84)
            self.state = 1049
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__25 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__22 - 66)) | (1 << (self.T__21 - 66)) | (1 << (self.T__14 - 66)) | (1 << (self.T__4 - 66)) | (1 << (self.T__2 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)) | (1 << (self.Identifier - 66)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1048 
                self.raw_value_style_enum_members()
            end #LL1OptionalBlockSingleAlt

            self.state = 1051
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_membersContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def raw_value_style_enum_member() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_memberContext,0)
        end


        def raw_value_style_enum_members() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_membersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_members
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_members(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_members(self)
            end
        end
    end


    def raw_value_style_enum_members()
        localctx = SwiftParser::Raw_value_style_enum_membersContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 188, SwiftParser.RULE_raw_value_style_enum_members)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1053 
            self.raw_value_style_enum_member()
            self.state = 1055
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__25 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__22 - 66)) | (1 << (self.T__21 - 66)) | (1 << (self.T__14 - 66)) | (1 << (self.T__4 - 66)) | (1 << (self.T__2 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)) | (1 << (self.Identifier - 66)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1054 
                self.raw_value_style_enum_members()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_memberContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def raw_value_style_enum_case_clause() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_case_clauseContext,0)
        end


        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_member
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_member(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_member(self)
            end
        end
    end


    def raw_value_style_enum_member()
        localctx = SwiftParser::Raw_value_style_enum_memberContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 190, SwiftParser.RULE_raw_value_style_enum_member)
        begin
            self.state = 1059
            la_ = self.interp.adaptivePredict(self.input,107,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1057 
                self.declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1058 
                self.raw_value_style_enum_case_clause()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_case_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def raw_value_style_enum_case_list() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_case_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_case_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_case_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_case_clause(self)
            end
        end
    end


    def raw_value_style_enum_case_clause()
        localctx = SwiftParser::Raw_value_style_enum_case_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 192, SwiftParser.RULE_raw_value_style_enum_case_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1062
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1061 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1064
             match(SwiftParser::T__27)
            self.state = 1065 
            self.raw_value_style_enum_case_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_case_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def raw_value_style_enum_case() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_caseContext,0)
        end


        def raw_value_style_enum_case_list() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_case_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_case_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_case_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_case_list(self)
            end
        end
    end


    def raw_value_style_enum_case_list()
        localctx = SwiftParser::Raw_value_style_enum_case_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 194, SwiftParser.RULE_raw_value_style_enum_case_list)
        begin
            self.state = 1072
            la_ = self.interp.adaptivePredict(self.input,109,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1067 
                self.raw_value_style_enum_case()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1068 
                self.raw_value_style_enum_case()
                self.state = 1069
                 match(SwiftParser::T__72)
                self.state = 1070 
                self.raw_value_style_enum_case_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_caseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def raw_value_assignment() 
            getTypedRuleContext(SwiftParser::Raw_value_assignmentContext,0)
        end


        def enum_case_name() 
            getTypedRuleContext(SwiftParser::Enum_case_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_case
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_case(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_case(self)
            end
        end
    end


    def raw_value_style_enum_case()
        localctx = SwiftParser::Raw_value_style_enum_caseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 196, SwiftParser.RULE_raw_value_style_enum_case)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1074 
            self.enum_case_name()
            self.state = 1076
            _la = self.input.LA(1)
            if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                self.state = 1075 
                self.raw_value_assignment()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_assignmentContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def literal() 
            getTypedRuleContext(SwiftParser::LiteralContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_assignment
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_assignment(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_assignment(self)
            end
        end
    end


    def raw_value_assignment()
        localctx = SwiftParser::Raw_value_assignmentContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 198, SwiftParser.RULE_raw_value_assignment)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1078
             match(SwiftParser::T__82)
            self.state = 1079 
            self.literal()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Struct_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def struct_name() 
            getTypedRuleContext(SwiftParser::Struct_nameContext,0)
        end


        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def struct_body() 
            getTypedRuleContext(SwiftParser::Struct_bodyContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_struct_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStruct_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStruct_declaration(self)
            end
        end
    end


    def struct_declaration()
        localctx = SwiftParser::Struct_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 200, SwiftParser.RULE_struct_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1082
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1081 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1084
             match(SwiftParser::T__54)
            self.state = 1085 
            self.struct_name()
            self.state = 1087
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1086 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1090
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1089 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1092 
            self.struct_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Struct_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_struct_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStruct_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStruct_name(self)
            end
        end
    end


    def struct_name()
        localctx = SwiftParser::Struct_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 202, SwiftParser.RULE_struct_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1094 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Struct_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declarations() 
            getTypedRuleContext(SwiftParser::DeclarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_struct_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStruct_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStruct_body(self)
            end
        end
    end


    def struct_body()
        localctx = SwiftParser::Struct_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 204, SwiftParser.RULE_struct_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1096
             match(SwiftParser::T__84)
            self.state = 1098
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__24 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.T__1 - 68)) | (1 << (self.T__0 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1097 
                self.declarations()
            end #LL1OptionalBlockSingleAlt

            self.state = 1100
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Class_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def class_body() 
            getTypedRuleContext(SwiftParser::Class_bodyContext,0)
        end


        def class_name() 
            getTypedRuleContext(SwiftParser::Class_nameContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_class_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClass_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClass_declaration(self)
            end
        end
    end


    def class_declaration()
        localctx = SwiftParser::Class_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 206, SwiftParser.RULE_class_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1103
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1102 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1105
             match(SwiftParser::T__44)
            self.state = 1106 
            self.class_name()
            self.state = 1108
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1107 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1111
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1110 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1113 
            self.class_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Class_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_class_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClass_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClass_name(self)
            end
        end
    end


    def class_name()
        localctx = SwiftParser::Class_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 208, SwiftParser.RULE_class_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1115 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Class_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declarations() 
            getTypedRuleContext(SwiftParser::DeclarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_class_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClass_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClass_body(self)
            end
        end
    end


    def class_body()
        localctx = SwiftParser::Class_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 210, SwiftParser.RULE_class_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1117
             match(SwiftParser::T__84)
            self.state = 1119
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__24 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.T__1 - 68)) | (1 << (self.T__0 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1118 
                self.declarations()
            end #LL1OptionalBlockSingleAlt

            self.state = 1121
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def protocol_name() 
            getTypedRuleContext(SwiftParser::Protocol_nameContext,0)
        end


        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def protocol_body() 
            getTypedRuleContext(SwiftParser::Protocol_bodyContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_declaration(self)
            end
        end
    end


    def protocol_declaration()
        localctx = SwiftParser::Protocol_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 212, SwiftParser.RULE_protocol_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1124
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1123 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1126
             match(SwiftParser::T__50)
            self.state = 1127 
            self.protocol_name()
            self.state = 1129
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1128 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1131 
            self.protocol_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_name(self)
            end
        end
    end


    def protocol_name()
        localctx = SwiftParser::Protocol_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 214, SwiftParser.RULE_protocol_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1133 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_member_declarations() 
            getTypedRuleContext(SwiftParser::Protocol_member_declarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_body(self)
            end
        end
    end


    def protocol_body()
        localctx = SwiftParser::Protocol_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 216, SwiftParser.RULE_protocol_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1135
             match(SwiftParser::T__84)
            self.state = 1137
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__76) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__52) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 69)) & ~0x3f) == 0  and ((1 << (_la - 69)) & ((1 << (self.T__24 - 69)) | (1 << (self.T__22 - 69)) | (1 << (self.T__21 - 69)) | (1 << (self.T__4 - 69)) | (1 << (self.T__1 - 69)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1136 
                self.protocol_member_declarations()
            end #LL1OptionalBlockSingleAlt

            self.state = 1139
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_member_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_subscript_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_subscript_declarationContext,0)
        end


        def protocol_method_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_method_declarationContext,0)
        end


        def protocol_property_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_property_declarationContext,0)
        end


        def protocol_initializer_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_initializer_declarationContext,0)
        end


        def protocol_associated_type_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_associated_type_declarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_member_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_member_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_member_declaration(self)
            end
        end
    end


    def protocol_member_declaration()
        localctx = SwiftParser::Protocol_member_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 218, SwiftParser.RULE_protocol_member_declaration)
        begin
            self.state = 1146
            la_ = self.interp.adaptivePredict(self.input,122,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1141 
                self.protocol_property_declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1142 
                self.protocol_method_declaration()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1143 
                self.protocol_initializer_declaration()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1144 
                self.protocol_subscript_declaration()

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 1145 
                self.protocol_associated_type_declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_member_declarationsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_member_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_member_declarationContext,0)
        end


        def protocol_member_declarations() 
            getTypedRuleContext(SwiftParser::Protocol_member_declarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_member_declarations
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_member_declarations(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_member_declarations(self)
            end
        end
    end


    def protocol_member_declarations()
        localctx = SwiftParser::Protocol_member_declarationsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 220, SwiftParser.RULE_protocol_member_declarations)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1148 
            self.protocol_member_declaration()
            self.state = 1150
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__76) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__52) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 69)) & ~0x3f) == 0  and ((1 << (_la - 69)) & ((1 << (self.T__24 - 69)) | (1 << (self.T__22 - 69)) | (1 << (self.T__21 - 69)) | (1 << (self.T__4 - 69)) | (1 << (self.T__1 - 69)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1149 
                self.protocol_member_declarations()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_property_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def variable_declaration_head() 
            getTypedRuleContext(SwiftParser::Variable_declaration_headContext,0)
        end


        def variable_name() 
            getTypedRuleContext(SwiftParser::Variable_nameContext,0)
        end


        def getter_setter_keyword_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_keyword_blockContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_property_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_property_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_property_declaration(self)
            end
        end
    end


    def protocol_property_declaration()
        localctx = SwiftParser::Protocol_property_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 222, SwiftParser.RULE_protocol_property_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1152 
            self.variable_declaration_head()
            self.state = 1153 
            self.variable_name()
            self.state = 1154 
            self.type_annotation()
            self.state = 1155 
            self.getter_setter_keyword_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_method_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def function_head() 
            getTypedRuleContext(SwiftParser::Function_headContext,0)
        end


        def function_name() 
            getTypedRuleContext(SwiftParser::Function_nameContext,0)
        end


        def function_signature() 
            getTypedRuleContext(SwiftParser::Function_signatureContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_method_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_method_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_method_declaration(self)
            end
        end
    end


    def protocol_method_declaration()
        localctx = SwiftParser::Protocol_method_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 224, SwiftParser.RULE_protocol_method_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1157 
            self.function_head()
            self.state = 1158 
            self.function_name()
            self.state = 1160
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1159 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1162 
            self.function_signature()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_initializer_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def initializer_head() 
            getTypedRuleContext(SwiftParser::Initializer_headContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_initializer_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_initializer_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_initializer_declaration(self)
            end
        end
    end


    def protocol_initializer_declaration()
        localctx = SwiftParser::Protocol_initializer_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 226, SwiftParser.RULE_protocol_initializer_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1164 
            self.initializer_head()
            self.state = 1166
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1165 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1168 
            self.parameter_clause()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_subscript_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def subscript_result() 
            getTypedRuleContext(SwiftParser::Subscript_resultContext,0)
        end


        def getter_setter_keyword_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_keyword_blockContext,0)
        end


        def subscript_head() 
            getTypedRuleContext(SwiftParser::Subscript_headContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_subscript_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_subscript_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_subscript_declaration(self)
            end
        end
    end


    def protocol_subscript_declaration()
        localctx = SwiftParser::Protocol_subscript_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 228, SwiftParser.RULE_protocol_subscript_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1170 
            self.subscript_head()
            self.state = 1171 
            self.subscript_result()
            self.state = 1172 
            self.getter_setter_keyword_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_associated_type_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def typealias_head() 
            getTypedRuleContext(SwiftParser::Typealias_headContext,0)
        end


        def typealias_assignment() 
            getTypedRuleContext(SwiftParser::Typealias_assignmentContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_associated_type_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_associated_type_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_associated_type_declaration(self)
            end
        end
    end


    def protocol_associated_type_declaration()
        localctx = SwiftParser::Protocol_associated_type_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 230, SwiftParser.RULE_protocol_associated_type_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1174 
            self.typealias_head()
            self.state = 1176
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1175 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1179
            _la = self.input.LA(1)
            if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                self.state = 1178 
                self.typealias_assignment()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Initializer_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def initializer_head() 
            getTypedRuleContext(SwiftParser::Initializer_headContext,0)
        end


        def initializer_body() 
            getTypedRuleContext(SwiftParser::Initializer_bodyContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_initializer_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInitializer_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInitializer_declaration(self)
            end
        end
    end


    def initializer_declaration()
        localctx = SwiftParser::Initializer_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 232, SwiftParser.RULE_initializer_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1181 
            self.initializer_head()
            self.state = 1183
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1182 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1185 
            self.parameter_clause()
            self.state = 1186 
            self.initializer_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Initializer_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_initializer_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInitializer_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInitializer_head(self)
            end
        end
    end


    def initializer_head()
        localctx = SwiftParser::Initializer_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 234, SwiftParser.RULE_initializer_head)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1189
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1188 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1192
            _la = self.input.LA(1)
            if _la==SwiftParser.T__24 then  # Ll1Optional Bloc Single Alt
                self.state = 1191
                 match(SwiftParser::T__24)
            end #LL1OptionalBlockSingleAlt

            self.state = 1194
             match(SwiftParser::T__67)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Initializer_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_initializer_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInitializer_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInitializer_body(self)
            end
        end
    end


    def initializer_body()
        localctx = SwiftParser::Initializer_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 236, SwiftParser.RULE_initializer_body)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1196 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Deinitializer_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_deinitializer_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeinitializer_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeinitializer_declaration(self)
            end
        end
    end


    def deinitializer_declaration()
        localctx = SwiftParser::Deinitializer_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 238, SwiftParser.RULE_deinitializer_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1199
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1198 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1201
             match(SwiftParser::T__49)
            self.state = 1202 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Extension_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def extension_body() 
            getTypedRuleContext(SwiftParser::Extension_bodyContext,0)
        end


        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_extension_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExtension_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExtension_declaration(self)
            end
        end
    end


    def extension_declaration()
        localctx = SwiftParser::Extension_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 240, SwiftParser.RULE_extension_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1204
             match(SwiftParser::T__65)
            self.state = 1205 
            self.type_identifier()
            self.state = 1207
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1206 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1209 
            self.extension_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Extension_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declarations() 
            getTypedRuleContext(SwiftParser::DeclarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_extension_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExtension_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExtension_body(self)
            end
        end
    end


    def extension_body()
        localctx = SwiftParser::Extension_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 242, SwiftParser.RULE_extension_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1211
             match(SwiftParser::T__84)
            self.state = 1213
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__24 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.T__1 - 68)) | (1 << (self.T__0 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1212 
                self.declarations()
            end #LL1OptionalBlockSingleAlt

            self.state = 1215
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Subscript_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def subscript_result() 
            getTypedRuleContext(SwiftParser::Subscript_resultContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def getter_setter_keyword_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_keyword_blockContext,0)
        end


        def subscript_head() 
            getTypedRuleContext(SwiftParser::Subscript_headContext,0)
        end


        def getter_setter_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_subscript_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSubscript_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSubscript_declaration(self)
            end
        end
    end


    def subscript_declaration()
        localctx = SwiftParser::Subscript_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 244, SwiftParser.RULE_subscript_declaration)
        begin
            self.state = 1229
            la_ = self.interp.adaptivePredict(self.input,134,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1217 
                self.subscript_head()
                self.state = 1218 
                self.subscript_result()
                self.state = 1219 
                self.code_block()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1221 
                self.subscript_head()
                self.state = 1222 
                self.subscript_result()
                self.state = 1223 
                self.getter_setter_block()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1225 
                self.subscript_head()
                self.state = 1226 
                self.subscript_result()
                self.state = 1227 
                self.getter_setter_keyword_block()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Subscript_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_subscript_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSubscript_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSubscript_head(self)
            end
        end
    end


    def subscript_head()
        localctx = SwiftParser::Subscript_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 246, SwiftParser.RULE_subscript_head)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1232
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1231 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1234
             match(SwiftParser::T__52)
            self.state = 1235 
            self.parameter_clause()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Subscript_resultContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_subscript_result
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSubscript_result(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSubscript_result(self)
            end
        end
    end


    def subscript_result()
        localctx = SwiftParser::Subscript_resultContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 248, SwiftParser.RULE_subscript_result)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1237
             match(SwiftParser::T__28)
            self.state = 1239
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1238 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1241 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Operator_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def postfix_operator_declaration() 
            getTypedRuleContext(SwiftParser::Postfix_operator_declarationContext,0)
        end


        def infix_operator_declaration() 
            getTypedRuleContext(SwiftParser::Infix_operator_declarationContext,0)
        end


        def prefix_operator_declaration() 
            getTypedRuleContext(SwiftParser::Prefix_operator_declarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_operator_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterOperator_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitOperator_declaration(self)
            end
        end
    end


    def operator_declaration()
        localctx = SwiftParser::Operator_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 250, SwiftParser.RULE_operator_declaration)
        begin
            self.state = 1246
            la_ = self.interp.adaptivePredict(self.input,137,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1243 
                self.prefix_operator_declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1244 
                self.postfix_operator_declaration()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1245 
                self.infix_operator_declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Prefix_operator_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_prefix_operator_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrefix_operator_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrefix_operator_declaration(self)
            end
        end
    end


    def prefix_operator_declaration()
        localctx = SwiftParser::Prefix_operator_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 252, SwiftParser.RULE_prefix_operator_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1248
             match(SwiftParser::T__88)
            self.state = 1249
             match(SwiftParser::T__2)
            self.state = 1250
             match(SwiftParser::T__88)
            self.state = 1251
             match(SwiftParser::T__84)
            self.state = 1252
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Postfix_operator_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_postfix_operator_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPostfix_operator_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPostfix_operator_declaration(self)
            end
        end
    end


    def postfix_operator_declaration()
        localctx = SwiftParser::Postfix_operator_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 254, SwiftParser.RULE_postfix_operator_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1254
             match(SwiftParser::T__88)
            self.state = 1255
             match(SwiftParser::T__79)
            self.state = 1256
             match(SwiftParser::T__88)
            self.state = 1257
             match(SwiftParser::T__84)
            self.state = 1258
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Infix_operator_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def infix_operator_attributes() 
            getTypedRuleContext(SwiftParser::Infix_operator_attributesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_infix_operator_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInfix_operator_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInfix_operator_declaration(self)
            end
        end
    end


    def infix_operator_declaration()
        localctx = SwiftParser::Infix_operator_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 256, SwiftParser.RULE_infix_operator_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1260
             match(SwiftParser::T__88)
            self.state = 1261
             match(SwiftParser::T__55)
            self.state = 1262
             match(SwiftParser::T__88)
            self.state = 1263
             match(SwiftParser::T__84)
            self.state = 1264 
            self.infix_operator_attributes()
            self.state = 1265
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Infix_operator_attributesContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def precedence_clause() 
            getTypedRuleContext(SwiftParser::Precedence_clauseContext,0)
        end


        def associativity_clause() 
            getTypedRuleContext(SwiftParser::Associativity_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_infix_operator_attributes
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInfix_operator_attributes(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInfix_operator_attributes(self)
            end
        end
    end


    def infix_operator_attributes()
        localctx = SwiftParser::Infix_operator_attributesContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 258, SwiftParser.RULE_infix_operator_attributes)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1268
            _la = self.input.LA(1)
            if _la==SwiftParser.T__86 then  # Ll1Optional Bloc Single Alt
                self.state = 1267 
                self.precedence_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1271
            _la = self.input.LA(1)
            if _la==SwiftParser.T__89 then  # Ll1Optional Bloc Single Alt
                self.state = 1270 
                self.associativity_clause()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Precedence_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def precedence_level() 
            getTypedRuleContext(SwiftParser::Precedence_levelContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_precedence_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrecedence_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrecedence_clause(self)
            end
        end
    end


    def precedence_clause()
        localctx = SwiftParser::Precedence_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 260, SwiftParser.RULE_precedence_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1273
             match(SwiftParser::T__86)
            self.state = 1274 
            self.precedence_level()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Precedence_levelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def integer_literal() 
            getTypedRuleContext(SwiftParser::Integer_literalContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_precedence_level
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrecedence_level(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrecedence_level(self)
            end
        end
    end


    def precedence_level()
        localctx = SwiftParser::Precedence_levelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 262, SwiftParser.RULE_precedence_level)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1276 
            self.integer_literal()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Associativity_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def associativity() 
            getTypedRuleContext(SwiftParser::AssociativityContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_associativity_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAssociativity_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAssociativity_clause(self)
            end
        end
    end


    def associativity_clause()
        localctx = SwiftParser::Associativity_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 264, SwiftParser.RULE_associativity_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1278
             match(SwiftParser::T__89)
            self.state = 1279 
            self.associativity()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class AssociativityContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_associativity
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAssociativity(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAssociativity(self)
            end
        end
    end


    def associativity()
        localctx = SwiftParser::AssociativityContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 266, SwiftParser.RULE_associativity)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1281
            _la = self.input.LA(1)
            if not (((((_la - 18)) & ~0x3f) == 0  and ((1 << (_la - 18)) & ((1 << (self.T__75 - 18)) | (1 << (self.T__71 - 18)) | (1 << (self.T__25 - 18)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator

    class PatternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def enum_case_pattern() 
            getTypedRuleContext(SwiftParser::Enum_case_patternContext,0)
        end


        def expression_pattern() 
            getTypedRuleContext(SwiftParser::Expression_patternContext,0)
        end


        def tuple_pattern() 
            getTypedRuleContext(SwiftParser::Tuple_patternContext,0)
        end


        def value_binding_pattern() 
            getTypedRuleContext(SwiftParser::Value_binding_patternContext,0)
        end


        def wildcard_pattern() 
            getTypedRuleContext(SwiftParser::Wildcard_patternContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def identifier_pattern() 
            getTypedRuleContext(SwiftParser::Identifier_patternContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPattern(self)
            end
        end
    end

    def pattern(_p=0)
        _parentctx = self.ctx
        _parentState = self.state
        localctx = SwiftParser::PatternContext.new(self, self.ctx, _parentState)
        _prevctx = localctx
        _startState = 268
        self.enterRecursionRule(localctx, 268, SwiftParser.RULE_pattern, _p)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1301
            la_ = self.interp.adaptivePredict(self.input,143,self.ctx)
            if la_ == 1 then
                self.state = 1284 
                self.wildcard_pattern()
                self.state = 1286
                la_ = self.interp.adaptivePredict(self.input,140,self.ctx)
                if la_ == 1
                    self.state = 1285 
                    self.type_annotation()

                end

            elsif la_ == 2 then
                self.state = 1288 
                self.identifier_pattern()
                self.state = 1290
                la_ = self.interp.adaptivePredict(self.input,141,self.ctx)
                if la_ == 1
                    self.state = 1289 
                    self.type_annotation()

                end

            elsif la_ == 3 then
                self.state = 1292 
                self.value_binding_pattern()

            elsif la_ == 4 then
                self.state = 1293 
                self.tuple_pattern()
                self.state = 1295
                la_ = self.interp.adaptivePredict(self.input,142,self.ctx)
                if la_ == 1
                    self.state = 1294 
                    self.type_annotation()

                end

            elsif la_ == 5 then
                self.state = 1297 
                self.enum_case_pattern()

            elsif la_ == 6 then
                self.state = 1298
                 match(SwiftParser::T__34)
                self.state = 1299 
                self.type(0)

            elsif la_ == 7 then
                self.state = 1300 
                self.expression_pattern()

            end
            self.ctx.stop = self.input.LT(-1)
            self.state = 1308
            self.errHandler.sync(self)
            _alt = self.interp.adaptivePredict(self.input,144,self.ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER do
                if _alt==1 then
                    if self.parseListeners  then 
                        self.triggerExitRuleEvent()
                    end
                    _prevctx = localctx
                    localctx = SwiftParser::PatternContext.new(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_pattern)
                    self.state = 1303
                    if not (self.precpred(self.ctx, 2)) then
                        raise FailedPredicateException.new(self, "self.precpred(self.ctx, 2)")
                    end
                    self.state = 1304
                     match(SwiftParser::T__48)
                    self.state = 1305 
                    self.type(0) 
                end
                self.state = 1310
                self.errHandler.sync(self)
                _alt = self.interp.adaptivePredict(self.input,144,self.ctx)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure
            self.unrollRecursionContexts(_parentctx)
        end
        return localctx
    end
    # RuleFucntion generator
    class Wildcard_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_wildcard_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWildcard_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWildcard_pattern(self)
            end
        end
    end


    def wildcard_pattern()
        localctx = SwiftParser::Wildcard_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 270, SwiftParser.RULE_wildcard_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1311
             match(SwiftParser::T__15)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Identifier_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_identifier_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIdentifier_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIdentifier_pattern(self)
            end
        end
    end


    def identifier_pattern()
        localctx = SwiftParser::Identifier_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 272, SwiftParser.RULE_identifier_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1313 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Value_binding_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_value_binding_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterValue_binding_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitValue_binding_pattern(self)
            end
        end
    end


    def value_binding_pattern()
        localctx = SwiftParser::Value_binding_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 274, SwiftParser.RULE_value_binding_pattern)
        begin
            self.state = 1319
            token = self.input.LA(1)
            if [self.T__68].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1315
                 match(SwiftParser::T__68)
                self.state = 1316 
                self.pattern(0)

            elsif [self.T__58].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1317
                 match(SwiftParser::T__58)
                self.state = 1318 
                self.pattern(0)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_pattern_element_list() 
            getTypedRuleContext(SwiftParser::Tuple_pattern_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_pattern(self)
            end
        end
    end


    def tuple_pattern()
        localctx = SwiftParser::Tuple_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 276, SwiftParser.RULE_tuple_pattern)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1321
             match(SwiftParser::T__74)
            self.state = 1323
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__34) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1322 
                self.tuple_pattern_element_list()
            end #LL1OptionalBlockSingleAlt

            self.state = 1325
             match(SwiftParser::T__5)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_pattern_element_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_pattern_element(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Tuple_pattern_elementContext)
            else
                getTypedRuleContext(SwiftParser::Tuple_pattern_elementContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_pattern_element_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_pattern_element_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_pattern_element_list(self)
            end
        end
    end


    def tuple_pattern_element_list()
        localctx = SwiftParser::Tuple_pattern_element_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 278, SwiftParser.RULE_tuple_pattern_element_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1327 
            self.tuple_pattern_element()
            self.state = 1332
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 1328
                 match(SwiftParser::T__72)
                self.state = 1329 
                self.tuple_pattern_element()
                self.state = 1334
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_pattern_elementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_pattern_element
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_pattern_element(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_pattern_element(self)
            end
        end
    end


    def tuple_pattern_element()
        localctx = SwiftParser::Tuple_pattern_elementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 280, SwiftParser.RULE_tuple_pattern_element)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1335 
            self.pattern(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Enum_case_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def tuple_pattern() 
            getTypedRuleContext(SwiftParser::Tuple_patternContext,0)
        end


        def enum_case_name() 
            getTypedRuleContext(SwiftParser::Enum_case_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_enum_case_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterEnum_case_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitEnum_case_pattern(self)
            end
        end
    end


    def enum_case_pattern()
        localctx = SwiftParser::Enum_case_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 282, SwiftParser.RULE_enum_case_pattern)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1338
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1337 
                self.type_identifier()
            end #LL1OptionalBlockSingleAlt

            self.state = 1340
             match(SwiftParser::T__29)
            self.state = 1341 
            self.enum_case_name()
            self.state = 1343
            la_ = self.interp.adaptivePredict(self.input,149,self.ctx)
            if la_ == 1
                self.state = 1342 
                self.tuple_pattern()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_casting_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def is_pattern() 
            getTypedRuleContext(SwiftParser::Is_patternContext,0)
        end


        def as_pattern() 
            getTypedRuleContext(SwiftParser::As_patternContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_casting_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_casting_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_casting_pattern(self)
            end
        end
    end


    def type_casting_pattern()
        localctx = SwiftParser::Type_casting_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 284, SwiftParser.RULE_type_casting_pattern)
        begin
            self.state = 1347
            la_ = self.interp.adaptivePredict(self.input,150,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1345 
                self.is_pattern()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1346 
                self.as_pattern()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Is_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_is_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIs_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIs_pattern(self)
            end
        end
    end


    def is_pattern()
        localctx = SwiftParser::Is_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 286, SwiftParser.RULE_is_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1349
             match(SwiftParser::T__34)
            self.state = 1350 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class As_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_as_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAs_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAs_pattern(self)
            end
        end
    end


    def as_pattern()
        localctx = SwiftParser::As_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 288, SwiftParser.RULE_as_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1352 
            self.pattern(0)
            self.state = 1353
             match(SwiftParser::T__48)
            self.state = 1354 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Expression_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression_pattern(self)
            end
        end
    end


    def expression_pattern()
        localctx = SwiftParser::Expression_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 290, SwiftParser.RULE_expression_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1356 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class AttributeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attribute_argument_clause() 
            getTypedRuleContext(SwiftParser::Attribute_argument_clauseContext,0)
        end


        def attribute_name() 
            getTypedRuleContext(SwiftParser::Attribute_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_attribute
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAttribute(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAttribute(self)
            end
        end
    end


    def attribute()
        localctx = SwiftParser::AttributeContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 292, SwiftParser.RULE_attribute)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1358
             match(SwiftParser::T__61)
            self.state = 1359 
            self.attribute_name()
            self.state = 1361
            la_ = self.interp.adaptivePredict(self.input,151,self.ctx)
            if la_ == 1
                self.state = 1360 
                self.attribute_argument_clause()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Attribute_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_attribute_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAttribute_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAttribute_name(self)
            end
        end
    end


    def attribute_name()
        localctx = SwiftParser::Attribute_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 294, SwiftParser.RULE_attribute_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1363 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Attribute_argument_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def balanced_tokens() 
            getTypedRuleContext(SwiftParser::Balanced_tokensContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_attribute_argument_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAttribute_argument_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAttribute_argument_clause(self)
            end
        end
    end


    def attribute_argument_clause()
        localctx = SwiftParser::Attribute_argument_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 296, SwiftParser.RULE_attribute_argument_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1365
             match(SwiftParser::T__74)
            self.state = 1367
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1366 
                self.balanced_tokens()
            end #LL1OptionalBlockSingleAlt

            self.state = 1369
             match(SwiftParser::T__5)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class AttributesContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attribute(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::AttributeContext)
            else
                getTypedRuleContext(SwiftParser::AttributeContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_attributes
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAttributes(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAttributes(self)
            end
        end
    end


    def attributes()
        localctx = SwiftParser::AttributesContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 298, SwiftParser.RULE_attributes)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1372 
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            # Trying to use Rubyism. This will probably break
            begin  # while true do
                self.state = 1371 
                self.attribute()
                self.state = 1374 
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            #    if not (_la==SwiftParser.T__61) then
            #        break
            #    end
            end until not (_la==SwiftParser.T__61)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Balanced_tokensContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def balanced_token(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Balanced_tokenContext)
            else
                getTypedRuleContext(SwiftParser::Balanced_tokenContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_balanced_tokens
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBalanced_tokens(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBalanced_tokens(self)
            end
        end
    end


    def balanced_tokens()
        localctx = SwiftParser::Balanced_tokensContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 300, SwiftParser.RULE_balanced_tokens)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1377 
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            # Trying to use Rubyism. This will probably break
            begin  # while true do
                self.state = 1376 
                self.balanced_token()
                self.state = 1379 
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            #    if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0)) then
            #        break
            #    end
            end until not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0))
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Balanced_tokenContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def balanced_tokens() 
            getTypedRuleContext(SwiftParser::Balanced_tokensContext,0)
        end


        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def literal() 
            getTypedRuleContext(SwiftParser::LiteralContext,0)
        end


        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def context_sensitive_keyword() 
            getTypedRuleContext(SwiftParser::Context_sensitive_keywordContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_balanced_token
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBalanced_token(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBalanced_token(self)
            end
        end
    end


    def balanced_token()
        localctx = SwiftParser::Balanced_tokenContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 302, SwiftParser.RULE_balanced_token)
        _la = 0 # Token type
        begin
            self.state = 1401
            la_ = self.interp.adaptivePredict(self.input,158,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1381
                 match(SwiftParser::T__74)
                self.state = 1383
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 1382 
                    self.balanced_tokens()
                end #LL1OptionalBlockSingleAlt

                self.state = 1385
                 match(SwiftParser::T__5)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1386
                 match(SwiftParser::T__19)
                self.state = 1388
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 1387 
                    self.balanced_tokens()
                end #LL1OptionalBlockSingleAlt

                self.state = 1390
                 match(SwiftParser::T__63)

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1391
                 match(SwiftParser::T__84)
                self.state = 1393
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 1392 
                    self.balanced_tokens()
                end #LL1OptionalBlockSingleAlt

                self.state = 1395
                 match(SwiftParser::T__41)

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1396 
                self.identifier()

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 1397 
                self.expression(0)

            elsif la_ == 6 then
                self.enterOuterAlt(localctx, 6)
                self.state = 1398 
                self.context_sensitive_keyword()

            elsif la_ == 7 then
                self.enterOuterAlt(localctx, 7)
                self.state = 1399 
                self.literal()

            elsif la_ == 8 then
                self.enterOuterAlt(localctx, 8)
                self.state = 1400 
                self.operator()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Expression_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression_list(self)
            end
        end
    end


    def expression_list()
        localctx = SwiftParser::Expression_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 304, SwiftParser.RULE_expression_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1403 
            self.expression(0)
            self.state = 1408
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 1404
                 match(SwiftParser::T__72)
                self.state = 1405 
                self.expression(0)
                self.state = 1410
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator

    class ExpressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def postfix_operator() 
            getTypedRuleContext(SwiftParser::Postfix_operatorContext,0)
        end


        def expression_list() 
            getTypedRuleContext(SwiftParser::Expression_listContext,0)
        end


        def type_casting_operator() 
            getTypedRuleContext(SwiftParser::Type_casting_operatorContext,0)
        end


        def primary_expression() 
            getTypedRuleContext(SwiftParser::Primary_expressionContext,0)
        end


        def assignment_operator() 
            getTypedRuleContext(SwiftParser::Assignment_operatorContext,0)
        end


        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def in_out_expression() 
            getTypedRuleContext(SwiftParser::In_out_expressionContext,0)
        end


        def trailing_closure() 
            getTypedRuleContext(SwiftParser::Trailing_closureContext,0)
        end


        def prefix_operator() 
            getTypedRuleContext(SwiftParser::Prefix_operatorContext,0)
        end


        def binary_operator() 
            getTypedRuleContext(SwiftParser::Binary_operatorContext,0)
        end


        def parenthesized_expression() 
            getTypedRuleContext(SwiftParser::Parenthesized_expressionContext,0)
        end


        def generic_argument_clause() 
            getTypedRuleContext(SwiftParser::Generic_argument_clauseContext,0)
        end


        def conditional_operator() 
            getTypedRuleContext(SwiftParser::Conditional_operatorContext,0)
        end


        def Decimal_literal()
            getToken(SwiftParser::Decimal_literal, 0)
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression(self)
            end
        end
    end

    def expression(_p=0)
        _parentctx = self.ctx
        _parentState = self.state
        localctx = SwiftParser::ExpressionContext.new(self, self.ctx, _parentState)
        _prevctx = localctx
        _startState = 306
        self.enterRecursionRule(localctx, 306, SwiftParser.RULE_expression, _p)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1417
            la_ = self.interp.adaptivePredict(self.input,160,self.ctx)
            if la_ == 1 then
                self.state = 1412 
                self.prefix_operator()
                self.state = 1413 
                self.expression(17)

            elsif la_ == 2 then
                self.state = 1415 
                self.in_out_expression()

            elsif la_ == 3 then
                self.state = 1416 
                self.primary_expression()

            end
            self.ctx.stop = self.input.LT(-1)
            self.state = 1469
            self.errHandler.sync(self)
            _alt = self.interp.adaptivePredict(self.input,164,self.ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER do
                if _alt==1 then
                    if self.parseListeners  then 
                        self.triggerExitRuleEvent()
                    end
                    _prevctx = localctx
                    self.state = 1467
                    la_ = self.interp.adaptivePredict(self.input,163,self.ctx)
                    if la_ == 1 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1419
                        if not (self.precpred(self.ctx, 14)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 14)")
                        end
                        self.state = 1420 
                        self.binary_operator()
                        self.state = 1421 
                        self.expression(15)

                    elsif la_ == 2 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1423
                        if not (self.precpred(self.ctx, 13)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 13)")
                        end
                        self.state = 1424 
                        self.assignment_operator()
                        self.state = 1425 
                        self.expression(14)

                    elsif la_ == 3 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1427
                        if not (self.precpred(self.ctx, 12)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 12)")
                        end
                        self.state = 1428 
                        self.conditional_operator()
                        self.state = 1429 
                        self.expression(13)

                    elsif la_ == 4 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1431
                        if not (self.precpred(self.ctx, 11)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 11)")
                        end
                        self.state = 1432 
                        self.type_casting_operator()

                    elsif la_ == 5 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1433
                        if not (self.precpred(self.ctx, 10)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 10)")
                        end
                        self.state = 1434 
                        self.postfix_operator()

                    elsif la_ == 6 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1435
                        if not (self.precpred(self.ctx, 9)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 9)")
                        end
                        self.state = 1436 
                        self.parenthesized_expression()
                        self.state = 1438
                        la_ = self.interp.adaptivePredict(self.input,161,self.ctx)
                        if la_ == 1
                            self.state = 1437 
                            self.trailing_closure()

                        end

                    elsif la_ == 7 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1440
                        if not (self.precpred(self.ctx, 8)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 8)")
                        end
                        self.state = 1441
                         match(SwiftParser::T__29)
                        self.state = 1442
                         match(SwiftParser::T__67)

                    elsif la_ == 8 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1443
                        if not (self.precpred(self.ctx, 7)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 7)")
                        end
                        self.state = 1444
                         match(SwiftParser::T__29)
                        self.state = 1445
                         match(SwiftParser::Decimal_literal)

                    elsif la_ == 9 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1446
                        if not (self.precpred(self.ctx, 6)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 6)")
                        end
                        self.state = 1447
                         match(SwiftParser::T__29)
                        self.state = 1448 
                        self.identifier()
                        self.state = 1450
                        la_ = self.interp.adaptivePredict(self.input,162,self.ctx)
                        if la_ == 1
                            self.state = 1449 
                            self.generic_argument_clause()

                        end

                    elsif la_ == 10 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1452
                        if not (self.precpred(self.ctx, 5)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 5)")
                        end
                        self.state = 1453
                         match(SwiftParser::T__29)
                        self.state = 1454
                         match(SwiftParser::T__6)

                    elsif la_ == 11 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1455
                        if not (self.precpred(self.ctx, 4)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 4)")
                        end
                        self.state = 1456
                         match(SwiftParser::T__29)
                        self.state = 1457
                         match(SwiftParser::T__66)

                    elsif la_ == 12 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1458
                        if not (self.precpred(self.ctx, 3)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 3)")
                        end
                        self.state = 1459
                         match(SwiftParser::T__19)
                        self.state = 1460 
                        self.expression_list()
                        self.state = 1461
                         match(SwiftParser::T__63)

                    elsif la_ == 13 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1463
                        if not (self.precpred(self.ctx, 2)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 2)")
                        end
                        self.state = 1464
                         match(SwiftParser::T__12)

                    elsif la_ == 14 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1465
                        if not (self.precpred(self.ctx, 1)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 1)")
                        end
                        self.state = 1466
                         match(SwiftParser::T__39)

                    end 
                end
                self.state = 1471
                self.errHandler.sync(self)
                _alt = self.interp.adaptivePredict(self.input,164,self.ctx)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure
            self.unrollRecursionContexts(_parentctx)
        end
        return localctx
    end
    # RuleFucntion generator
    class In_out_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_in_out_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIn_out_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIn_out_expression(self)
            end
        end
    end


    def in_out_expression()
        localctx = SwiftParser::In_out_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 308, SwiftParser.RULE_in_out_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1472
             match(SwiftParser::T__36)
            self.state = 1473 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Assignment_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_assignment_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAssignment_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAssignment_operator(self)
            end
        end
    end


    def assignment_operator()
        localctx = SwiftParser::Assignment_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 310, SwiftParser.RULE_assignment_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1475
             match(SwiftParser::T__82)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Conditional_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_conditional_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterConditional_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitConditional_operator(self)
            end
        end
    end


    def conditional_operator()
        localctx = SwiftParser::Conditional_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 312, SwiftParser.RULE_conditional_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1477
             match(SwiftParser::T__39)
            self.state = 1478 
            self.expression(0)
            self.state = 1479
             match(SwiftParser::T__20)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_casting_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_casting_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_casting_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_casting_operator(self)
            end
        end
    end


    def type_casting_operator()
        localctx = SwiftParser::Type_casting_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 314, SwiftParser.RULE_type_casting_operator)
        _la = 0 # Token type
        begin
            self.state = 1488
            token = self.input.LA(1)
            if [self.T__34].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1481
                 match(SwiftParser::T__34)
                self.state = 1482 
                self.type(0)

            elsif [self.T__48].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1483
                 match(SwiftParser::T__48)
                self.state = 1485
                _la = self.input.LA(1)
                if _la==SwiftParser.T__39 then  # Ll1Optional Bloc Single Alt
                    self.state = 1484
                     match(SwiftParser::T__39)
                end #LL1OptionalBlockSingleAlt

                self.state = 1487 
                self.type(0)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Trailing_closureContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def closure_expression() 
            getTypedRuleContext(SwiftParser::Closure_expressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_trailing_closure
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTrailing_closure(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTrailing_closure(self)
            end
        end
    end


    def trailing_closure()
        localctx = SwiftParser::Trailing_closureContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 316, SwiftParser.RULE_trailing_closure)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1490 
            self.closure_expression()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Primary_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def self_expression() 
            getTypedRuleContext(SwiftParser::Self_expressionContext,0)
        end


        def superclass_expression() 
            getTypedRuleContext(SwiftParser::Superclass_expressionContext,0)
        end


        def parenthesized_expression() 
            getTypedRuleContext(SwiftParser::Parenthesized_expressionContext,0)
        end


        def wildcard_expression() 
            getTypedRuleContext(SwiftParser::Wildcard_expressionContext,0)
        end


        def generic_argument_clause() 
            getTypedRuleContext(SwiftParser::Generic_argument_clauseContext,0)
        end


        def closure_expression() 
            getTypedRuleContext(SwiftParser::Closure_expressionContext,0)
        end


        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def implicit_member_expression() 
            getTypedRuleContext(SwiftParser::Implicit_member_expressionContext,0)
        end


        def literal_expression() 
            getTypedRuleContext(SwiftParser::Literal_expressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_primary_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrimary_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrimary_expression(self)
            end
        end
    end


    def primary_expression()
        localctx = SwiftParser::Primary_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 318, SwiftParser.RULE_primary_expression)
        begin
            self.state = 1503
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1492 
                self.identifier()
                self.state = 1494
                la_ = self.interp.adaptivePredict(self.input,167,self.ctx)
                if la_ == 1
                    self.state = 1493 
                    self.generic_argument_clause()

                end

            elsif [self.T__77, self.T__69, self.T__62, self.T__23, self.T__19, self.Binary_literal, self.Octal_literal, self.Decimal_literal, self.Hexadecimal_literal, self.Floating_point_literal, self.String_literal].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1496 
                self.literal_expression()

            elsif [self.T__6].member? token then 
                self.enterOuterAlt(localctx, 3)
                self.state = 1497 
                self.self_expression()

            elsif [self.T__7].member? token then 
                self.enterOuterAlt(localctx, 4)
                self.state = 1498 
                self.superclass_expression()

            elsif [self.T__84].member? token then 
                self.enterOuterAlt(localctx, 5)
                self.state = 1499 
                self.closure_expression()

            elsif [self.T__74].member? token then 
                self.enterOuterAlt(localctx, 6)
                self.state = 1500 
                self.parenthesized_expression()

            elsif [self.T__29].member? token then 
                self.enterOuterAlt(localctx, 7)
                self.state = 1501 
                self.implicit_member_expression()

            elsif [self.T__15].member? token then 
                self.enterOuterAlt(localctx, 8)
                self.state = 1502 
                self.wildcard_expression()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Literal_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def array_literal() 
            getTypedRuleContext(SwiftParser::Array_literalContext,0)
        end


        def literal() 
            getTypedRuleContext(SwiftParser::LiteralContext,0)
        end


        def dictionary_literal() 
            getTypedRuleContext(SwiftParser::Dictionary_literalContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_literal_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLiteral_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLiteral_expression(self)
            end
        end
    end


    def literal_expression()
        localctx = SwiftParser::Literal_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 320, SwiftParser.RULE_literal_expression)
        begin
            self.state = 1512
            la_ = self.interp.adaptivePredict(self.input,169,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1505 
                self.literal()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1506 
                self.array_literal()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1507 
                self.dictionary_literal()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1508
                 match(SwiftParser::T__69)

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 1509
                 match(SwiftParser::T__62)

            elsif la_ == 6 then
                self.enterOuterAlt(localctx, 6)
                self.state = 1510
                 match(SwiftParser::T__23)

            elsif la_ == 7 then
                self.enterOuterAlt(localctx, 7)
                self.state = 1511
                 match(SwiftParser::T__77)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Array_literalContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def array_literal_items() 
            getTypedRuleContext(SwiftParser::Array_literal_itemsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_array_literal
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterArray_literal(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitArray_literal(self)
            end
        end
    end


    def array_literal()
        localctx = SwiftParser::Array_literalContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 322, SwiftParser.RULE_array_literal)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1514
             match(SwiftParser::T__19)
            self.state = 1516
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1515 
                self.array_literal_items()
            end #LL1OptionalBlockSingleAlt

            self.state = 1518
             match(SwiftParser::T__63)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Array_literal_itemsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def array_literal_items() 
            getTypedRuleContext(SwiftParser::Array_literal_itemsContext,0)
        end


        def array_literal_item() 
            getTypedRuleContext(SwiftParser::Array_literal_itemContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_array_literal_items
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterArray_literal_items(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitArray_literal_items(self)
            end
        end
    end


    def array_literal_items()
        localctx = SwiftParser::Array_literal_itemsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 324, SwiftParser.RULE_array_literal_items)
        _la = 0 # Token type
        begin
            self.state = 1528
            la_ = self.interp.adaptivePredict(self.input,172,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1520 
                self.array_literal_item()
                self.state = 1522
                _la = self.input.LA(1)
                if _la==SwiftParser.T__72 then  # Ll1Optional Bloc Single Alt
                    self.state = 1521
                     match(SwiftParser::T__72)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1524 
                self.array_literal_item()
                self.state = 1525
                 match(SwiftParser::T__72)
                self.state = 1526 
                self.array_literal_items()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Array_literal_itemContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_array_literal_item
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterArray_literal_item(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitArray_literal_item(self)
            end
        end
    end


    def array_literal_item()
        localctx = SwiftParser::Array_literal_itemContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 326, SwiftParser.RULE_array_literal_item)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1530 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Dictionary_literalContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def dictionary_literal_items() 
            getTypedRuleContext(SwiftParser::Dictionary_literal_itemsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_dictionary_literal
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDictionary_literal(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDictionary_literal(self)
            end
        end
    end


    def dictionary_literal()
        localctx = SwiftParser::Dictionary_literalContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 328, SwiftParser.RULE_dictionary_literal)
        begin
            self.state = 1539
            la_ = self.interp.adaptivePredict(self.input,173,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1532
                 match(SwiftParser::T__19)
                self.state = 1533 
                self.dictionary_literal_items()
                self.state = 1534
                 match(SwiftParser::T__63)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1536
                 match(SwiftParser::T__19)
                self.state = 1537
                 match(SwiftParser::T__20)
                self.state = 1538
                 match(SwiftParser::T__63)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Dictionary_literal_itemsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def dictionary_literal_item(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Dictionary_literal_itemContext)
            else
                getTypedRuleContext(SwiftParser::Dictionary_literal_itemContext,i)
            end
        end

        def dictionary_literal_items() 
            getTypedRuleContext(SwiftParser::Dictionary_literal_itemsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_dictionary_literal_items
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDictionary_literal_items(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDictionary_literal_items(self)
            end
        end
    end


    def dictionary_literal_items()
        localctx = SwiftParser::Dictionary_literal_itemsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 330, SwiftParser.RULE_dictionary_literal_items)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1541 
            self.dictionary_literal_item()
            self.state = 1543
            _la = self.input.LA(1)
            if _la==SwiftParser.T__72 then  # Ll1Optional Bloc Single Alt
                self.state = 1542
                 match(SwiftParser::T__72)
            end #LL1OptionalBlockSingleAlt

            self.state = 1545 
            self.dictionary_literal_item()
            self.state = 1546
             match(SwiftParser::T__72)
            self.state = 1547 
            self.dictionary_literal_items()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Dictionary_literal_itemContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_dictionary_literal_item
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDictionary_literal_item(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDictionary_literal_item(self)
            end
        end
    end


    def dictionary_literal_item()
        localctx = SwiftParser::Dictionary_literal_itemContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 332, SwiftParser.RULE_dictionary_literal_item)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1549 
            self.expression(0)
            self.state = 1550
             match(SwiftParser::T__20)
            self.state = 1551 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Self_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_self_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSelf_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSelf_expression(self)
            end
        end
    end


    def self_expression()
        localctx = SwiftParser::Self_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 334, SwiftParser.RULE_self_expression)
        begin
            self.state = 1565
            la_ = self.interp.adaptivePredict(self.input,175,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1553
                 match(SwiftParser::T__6)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1554
                 match(SwiftParser::T__6)
                self.state = 1555
                 match(SwiftParser::T__29)
                self.state = 1556 
                self.identifier()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1557
                 match(SwiftParser::T__6)
                self.state = 1558
                 match(SwiftParser::T__19)
                self.state = 1559 
                self.expression(0)
                self.state = 1560
                 match(SwiftParser::T__63)

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1562
                 match(SwiftParser::T__6)
                self.state = 1563
                 match(SwiftParser::T__29)
                self.state = 1564
                 match(SwiftParser::T__67)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Superclass_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def superclass_subscript_expression() 
            getTypedRuleContext(SwiftParser::Superclass_subscript_expressionContext,0)
        end


        def superclass_initializer_expression() 
            getTypedRuleContext(SwiftParser::Superclass_initializer_expressionContext,0)
        end


        def superclass_method_expression() 
            getTypedRuleContext(SwiftParser::Superclass_method_expressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_superclass_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSuperclass_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSuperclass_expression(self)
            end
        end
    end


    def superclass_expression()
        localctx = SwiftParser::Superclass_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 336, SwiftParser.RULE_superclass_expression)
        begin
            self.state = 1571
            la_ = self.interp.adaptivePredict(self.input,176,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1567 
                self.superclass_method_expression()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1568 
                self.superclass_subscript_expression()
                self.state = 1569 
                self.superclass_initializer_expression()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Superclass_method_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_superclass_method_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSuperclass_method_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSuperclass_method_expression(self)
            end
        end
    end


    def superclass_method_expression()
        localctx = SwiftParser::Superclass_method_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 338, SwiftParser.RULE_superclass_method_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1573
             match(SwiftParser::T__7)
            self.state = 1574
             match(SwiftParser::T__29)
            self.state = 1575 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Superclass_subscript_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_superclass_subscript_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSuperclass_subscript_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSuperclass_subscript_expression(self)
            end
        end
    end


    def superclass_subscript_expression()
        localctx = SwiftParser::Superclass_subscript_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 340, SwiftParser.RULE_superclass_subscript_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1577
             match(SwiftParser::T__7)
            self.state = 1578
             match(SwiftParser::T__19)
            self.state = 1579 
            self.expression(0)
            self.state = 1580
             match(SwiftParser::T__63)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Superclass_initializer_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_superclass_initializer_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSuperclass_initializer_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSuperclass_initializer_expression(self)
            end
        end
    end


    def superclass_initializer_expression()
        localctx = SwiftParser::Superclass_initializer_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 342, SwiftParser.RULE_superclass_initializer_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1582
             match(SwiftParser::T__7)
            self.state = 1583
             match(SwiftParser::T__29)
            self.state = 1584
             match(SwiftParser::T__67)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Closure_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def statements() 
            getTypedRuleContext(SwiftParser::StatementsContext,0)
        end


        def closure_signature() 
            getTypedRuleContext(SwiftParser::Closure_signatureContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_closure_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClosure_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClosure_expression(self)
            end
        end
    end


    def closure_expression()
        localctx = SwiftParser::Closure_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 344, SwiftParser.RULE_closure_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1586
             match(SwiftParser::T__84)
            self.state = 1588
            la_ = self.interp.adaptivePredict(self.input,177,self.ctx)
            if la_ == 1
                self.state = 1587 
                self.closure_signature()

            end
            self.state = 1590 
            self.statements()
            self.state = 1591
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Closure_signatureContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def capture_list() 
            getTypedRuleContext(SwiftParser::Capture_listContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def function_result() 
            getTypedRuleContext(SwiftParser::Function_resultContext,0)
        end


        def identifier_list() 
            getTypedRuleContext(SwiftParser::Identifier_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_closure_signature
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClosure_signature(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClosure_signature(self)
            end
        end
    end


    def closure_signature()
        localctx = SwiftParser::Closure_signatureContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 346, SwiftParser.RULE_closure_signature)
        _la = 0 # Token type
        begin
            self.state = 1622
            la_ = self.interp.adaptivePredict(self.input,182,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1593 
                self.parameter_clause()
                self.state = 1595
                _la = self.input.LA(1)
                if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                    self.state = 1594 
                    self.function_result()
                end #LL1OptionalBlockSingleAlt

                self.state = 1597
                 match(SwiftParser::T__8)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1599 
                self.identifier_list()
                self.state = 1601
                _la = self.input.LA(1)
                if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                    self.state = 1600 
                    self.function_result()
                end #LL1OptionalBlockSingleAlt

                self.state = 1603
                 match(SwiftParser::T__8)

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1605 
                self.capture_list()
                self.state = 1606 
                self.parameter_clause()
                self.state = 1608
                _la = self.input.LA(1)
                if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                    self.state = 1607 
                    self.function_result()
                end #LL1OptionalBlockSingleAlt

                self.state = 1610
                 match(SwiftParser::T__8)

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1612 
                self.capture_list()
                self.state = 1613 
                self.identifier_list()
                self.state = 1615
                _la = self.input.LA(1)
                if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                    self.state = 1614 
                    self.function_result()
                end #LL1OptionalBlockSingleAlt

                self.state = 1617
                 match(SwiftParser::T__8)

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 1619 
                self.capture_list()
                self.state = 1620
                 match(SwiftParser::T__8)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Capture_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def capture_specifier() 
            getTypedRuleContext(SwiftParser::Capture_specifierContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_capture_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCapture_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCapture_list(self)
            end
        end
    end


    def capture_list()
        localctx = SwiftParser::Capture_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 348, SwiftParser.RULE_capture_list)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1624
             match(SwiftParser::T__19)
            self.state = 1625 
            self.capture_specifier()
            self.state = 1626 
            self.expression(0)
            self.state = 1627
             match(SwiftParser::T__63)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Capture_specifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_capture_specifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCapture_specifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCapture_specifier(self)
            end
        end
    end


    def capture_specifier()
        localctx = SwiftParser::Capture_specifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 350, SwiftParser.RULE_capture_specifier)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1629
            _la = self.input.LA(1)
            if not (((((_la - 23)) & ~0x3f) == 0  and ((1 << (_la - 23)) & ((1 << (self.T__70 - 23)) | (1 << (self.T__60 - 23)) | (1 << (self.T__30 - 23)) | (1 << (self.T__22 - 23)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Implicit_member_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_implicit_member_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImplicit_member_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImplicit_member_expression(self)
            end
        end
    end


    def implicit_member_expression()
        localctx = SwiftParser::Implicit_member_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 352, SwiftParser.RULE_implicit_member_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1631
             match(SwiftParser::T__29)
            self.state = 1632 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parenthesized_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression_element_list() 
            getTypedRuleContext(SwiftParser::Expression_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parenthesized_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParenthesized_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParenthesized_expression(self)
            end
        end
    end


    def parenthesized_expression()
        localctx = SwiftParser::Parenthesized_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 354, SwiftParser.RULE_parenthesized_expression)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1634
             match(SwiftParser::T__74)
            self.state = 1636
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1635 
                self.expression_element_list()
            end #LL1OptionalBlockSingleAlt

            self.state = 1638
             match(SwiftParser::T__5)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Expression_element_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression_element() 
            getTypedRuleContext(SwiftParser::Expression_elementContext,0)
        end


        def expression_element_list() 
            getTypedRuleContext(SwiftParser::Expression_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression_element_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression_element_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression_element_list(self)
            end
        end
    end


    def expression_element_list()
        localctx = SwiftParser::Expression_element_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 356, SwiftParser.RULE_expression_element_list)
        begin
            self.state = 1645
            la_ = self.interp.adaptivePredict(self.input,184,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1640 
                self.expression_element()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1641 
                self.expression_element()
                self.state = 1642
                 match(SwiftParser::T__72)
                self.state = 1643 
                self.expression_element_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Expression_elementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression_element
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression_element(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression_element(self)
            end
        end
    end


    def expression_element()
        localctx = SwiftParser::Expression_elementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 358, SwiftParser.RULE_expression_element)
        begin
            self.state = 1652
            la_ = self.interp.adaptivePredict(self.input,185,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1647 
                self.expression(0)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1648 
                self.identifier()
                self.state = 1649
                 match(SwiftParser::T__20)
                self.state = 1650 
                self.expression(0)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Wildcard_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_wildcard_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWildcard_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWildcard_expression(self)
            end
        end
    end


    def wildcard_expression()
        localctx = SwiftParser::Wildcard_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 360, SwiftParser.RULE_wildcard_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1654
             match(SwiftParser::T__15)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class OperatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterOperator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitOperator(self)
            end
        end
    end


    def operator()
        localctx = SwiftParser::OperatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 362, SwiftParser.RULE_operator)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1656
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__82) | (1 << self.T__81) | (1 << self.T__64) | (1 << self.T__56) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__32))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__3 - 64)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Binary_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_binary_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBinary_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBinary_operator(self)
            end
        end
    end


    def binary_operator()
        localctx = SwiftParser::Binary_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 364, SwiftParser.RULE_binary_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1658 
            self.operator()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Prefix_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_prefix_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrefix_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrefix_operator(self)
            end
        end
    end


    def prefix_operator()
        localctx = SwiftParser::Prefix_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 366, SwiftParser.RULE_prefix_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1660 
            self.operator()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Postfix_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_postfix_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPostfix_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPostfix_operator(self)
            end
        end
    end


    def postfix_operator()
        localctx = SwiftParser::Postfix_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 368, SwiftParser.RULE_postfix_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1662 
            self.operator()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator

    class TypeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def tuple_type() 
            getTypedRuleContext(SwiftParser::Tuple_typeContext,0)
        end


        def type(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::TypeContext)
            else
                getTypedRuleContext(SwiftParser::TypeContext,i)
            end
        end

        def protocol_composition_type() 
            getTypedRuleContext(SwiftParser::Protocol_composition_typeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType(self)
            end
        end
    end

    def type(_p=0)
        _parentctx = self.ctx
        _parentState = self.state
        localctx = SwiftParser::TypeContext.new(self, self.ctx, _parentState)
        _prevctx = localctx
        _startState = 370
        self.enterRecursionRule(localctx, 370, SwiftParser.RULE_type, _p)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1668
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.state = 1665 
                self.type_identifier()

            elsif [self.T__74].member? token then 
                self.state = 1666 
                self.tuple_type()

            elsif [self.T__50].member? token then 
                self.state = 1667 
                self.protocol_composition_type()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

            self.ctx.stop = self.input.LT(-1)
            self.state = 1688
            self.errHandler.sync(self)
            _alt = self.interp.adaptivePredict(self.input,188,self.ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER do
                if _alt==1 then
                    if self.parseListeners  then 
                        self.triggerExitRuleEvent()
                    end
                    _prevctx = localctx
                    self.state = 1686
                    la_ = self.interp.adaptivePredict(self.input,187,self.ctx)
                    if la_ == 1 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1670
                        if not (self.precpred(self.ctx, 8)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 8)")
                        end
                        self.state = 1671
                         match(SwiftParser::T__28)
                        self.state = 1672 
                        self.type(9)

                    elsif la_ == 2 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1673
                        if not (self.precpred(self.ctx, 9)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 9)")
                        end
                        self.state = 1674
                         match(SwiftParser::T__19)
                        self.state = 1675
                         match(SwiftParser::T__63)

                    elsif la_ == 3 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1676
                        if not (self.precpred(self.ctx, 5)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 5)")
                        end
                        self.state = 1677
                         match(SwiftParser::T__39)

                    elsif la_ == 4 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1678
                        if not (self.precpred(self.ctx, 4)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 4)")
                        end
                        self.state = 1679
                         match(SwiftParser::T__12)

                    elsif la_ == 5 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1680
                        if not (self.precpred(self.ctx, 2)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 2)")
                        end
                        self.state = 1681
                         match(SwiftParser::T__29)
                        self.state = 1682
                         match(SwiftParser::T__31)

                    elsif la_ == 6 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1683
                        if not (self.precpred(self.ctx, 1)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 1)")
                        end
                        self.state = 1684
                         match(SwiftParser::T__29)
                        self.state = 1685
                         match(SwiftParser::T__53)

                    end 
                end
                self.state = 1690
                self.errHandler.sync(self)
                _alt = self.interp.adaptivePredict(self.input,188,self.ctx)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure
            self.unrollRecursionContexts(_parentctx)
        end
        return localctx
    end
    # RuleFucntion generator
    class Type_annotationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_annotation
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_annotation(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_annotation(self)
            end
        end
    end


    def type_annotation()
        localctx = SwiftParser::Type_annotationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 372, SwiftParser.RULE_type_annotation)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1691
             match(SwiftParser::T__20)
            self.state = 1693
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1692 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1695 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_identifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def type_name() 
            getTypedRuleContext(SwiftParser::Type_nameContext,0)
        end


        def generic_argument_clause() 
            getTypedRuleContext(SwiftParser::Generic_argument_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_identifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_identifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_identifier(self)
            end
        end
    end


    def type_identifier()
        localctx = SwiftParser::Type_identifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 374, SwiftParser.RULE_type_identifier)
        _la = 0 # Token type
        begin
            self.state = 1708
            la_ = self.interp.adaptivePredict(self.input,192,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1697 
                self.type_name()
                self.state = 1699
                la_ = self.interp.adaptivePredict(self.input,190,self.ctx)
                if la_ == 1
                    self.state = 1698 
                    self.generic_argument_clause()

                end

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1701 
                self.type_name()
                self.state = 1703
                _la = self.input.LA(1)
                if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                    self.state = 1702 
                    self.generic_argument_clause()
                end #LL1OptionalBlockSingleAlt

                self.state = 1705
                 match(SwiftParser::T__29)
                self.state = 1706 
                self.type_identifier()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_name(self)
            end
        end
    end


    def type_name()
        localctx = SwiftParser::Type_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 376, SwiftParser.RULE_type_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1710 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_typeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_type_body() 
            getTypedRuleContext(SwiftParser::Tuple_type_bodyContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_type
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_type(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_type(self)
            end
        end
    end


    def tuple_type()
        localctx = SwiftParser::Tuple_typeContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 378, SwiftParser.RULE_tuple_type)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1712
             match(SwiftParser::T__74)
            self.state = 1714
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__50) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1713 
                self.tuple_type_body()
            end #LL1OptionalBlockSingleAlt

            self.state = 1716
             match(SwiftParser::T__5)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_type_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_type_element_list() 
            getTypedRuleContext(SwiftParser::Tuple_type_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_type_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_type_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_type_body(self)
            end
        end
    end


    def tuple_type_body()
        localctx = SwiftParser::Tuple_type_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 380, SwiftParser.RULE_tuple_type_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1718 
            self.tuple_type_element_list()
            self.state = 1720
            _la = self.input.LA(1)
            if _la==SwiftParser.T__26 then  # Ll1Optional Bloc Single Alt
                self.state = 1719
                 match(SwiftParser::T__26)
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_type_element_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_type_element() 
            getTypedRuleContext(SwiftParser::Tuple_type_elementContext,0)
        end


        def tuple_type_element_list() 
            getTypedRuleContext(SwiftParser::Tuple_type_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_type_element_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_type_element_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_type_element_list(self)
            end
        end
    end


    def tuple_type_element_list()
        localctx = SwiftParser::Tuple_type_element_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 382, SwiftParser.RULE_tuple_type_element_list)
        begin
            self.state = 1727
            la_ = self.interp.adaptivePredict(self.input,195,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1722 
                self.tuple_type_element()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1723 
                self.tuple_type_element()
                self.state = 1724
                 match(SwiftParser::T__72)
                self.state = 1725 
                self.tuple_type_element_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_type_elementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def element_name() 
            getTypedRuleContext(SwiftParser::Element_nameContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_type_element
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_type_element(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_type_element(self)
            end
        end
    end


    def tuple_type_element()
        localctx = SwiftParser::Tuple_type_elementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 384, SwiftParser.RULE_tuple_type_element)
        _la = 0 # Token type
        begin
            self.state = 1742
            la_ = self.interp.adaptivePredict(self.input,199,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1730
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 1729 
                    self.attributes()
                end #LL1OptionalBlockSingleAlt

                self.state = 1733
                la_ = self.interp.adaptivePredict(self.input,197,self.ctx)
                if la_ == 1
                    self.state = 1732
                     match(SwiftParser::T__35)

                end
                self.state = 1735 
                self.type(0)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1737
                la_ = self.interp.adaptivePredict(self.input,198,self.ctx)
                if la_ == 1
                    self.state = 1736
                     match(SwiftParser::T__35)

                end
                self.state = 1739 
                self.element_name()
                self.state = 1740 
                self.type_annotation()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Element_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_element_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterElement_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitElement_name(self)
            end
        end
    end


    def element_name()
        localctx = SwiftParser::Element_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 386, SwiftParser.RULE_element_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1744 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_composition_typeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_identifier_list() 
            getTypedRuleContext(SwiftParser::Protocol_identifier_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_composition_type
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_composition_type(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_composition_type(self)
            end
        end
    end


    def protocol_composition_type()
        localctx = SwiftParser::Protocol_composition_typeContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 388, SwiftParser.RULE_protocol_composition_type)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1746
             match(SwiftParser::T__50)
            self.state = 1747
             match(SwiftParser::T__64)
            self.state = 1749
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1748 
                self.protocol_identifier_list()
            end #LL1OptionalBlockSingleAlt

            self.state = 1751
             match(SwiftParser::T__16)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_identifier_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_identifier() 
            getTypedRuleContext(SwiftParser::Protocol_identifierContext,0)
        end


        def protocol_identifier_list() 
            getTypedRuleContext(SwiftParser::Protocol_identifier_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_identifier_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_identifier_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_identifier_list(self)
            end
        end
    end


    def protocol_identifier_list()
        localctx = SwiftParser::Protocol_identifier_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 390, SwiftParser.RULE_protocol_identifier_list)
        begin
            self.state = 1758
            la_ = self.interp.adaptivePredict(self.input,201,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1753 
                self.protocol_identifier()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1754 
                self.protocol_identifier()
                self.state = 1755
                 match(SwiftParser::T__72)
                self.state = 1756 
                self.protocol_identifier_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_identifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_identifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_identifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_identifier(self)
            end
        end
    end


    def protocol_identifier()
        localctx = SwiftParser::Protocol_identifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 392, SwiftParser.RULE_protocol_identifier)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1760 
            self.type_identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Metatype_typeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_metatype_type
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterMetatype_type(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitMetatype_type(self)
            end
        end
    end


    def metatype_type()
        localctx = SwiftParser::Metatype_typeContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 394, SwiftParser.RULE_metatype_type)
        begin
            self.state = 1770
            la_ = self.interp.adaptivePredict(self.input,202,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1762 
                self.type(0)
                self.state = 1763
                 match(SwiftParser::T__29)
                self.state = 1764
                 match(SwiftParser::T__31)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1766 
                self.type(0)
                self.state = 1767
                 match(SwiftParser::T__29)
                self.state = 1768
                 match(SwiftParser::T__53)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_inheritance_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_inheritance_list() 
            getTypedRuleContext(SwiftParser::Type_inheritance_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_inheritance_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_inheritance_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_inheritance_clause(self)
            end
        end
    end


    def type_inheritance_clause()
        localctx = SwiftParser::Type_inheritance_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 396, SwiftParser.RULE_type_inheritance_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1772
             match(SwiftParser::T__20)
            self.state = 1773 
            self.type_inheritance_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_inheritance_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Type_identifierContext)
            else
                getTypedRuleContext(SwiftParser::Type_identifierContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_inheritance_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_inheritance_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_inheritance_list(self)
            end
        end
    end


    def type_inheritance_list()
        localctx = SwiftParser::Type_inheritance_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 398, SwiftParser.RULE_type_inheritance_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1775 
            self.type_identifier()
            self.state = 1780
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 1776
                 match(SwiftParser::T__72)
                self.state = 1777 
                self.type_identifier()
                self.state = 1782
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class IdentifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def Identifier()
            getToken(SwiftParser::Identifier, 0)
        end

        def context_sensitive_keyword() 
            getTypedRuleContext(SwiftParser::Context_sensitive_keywordContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_identifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIdentifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIdentifier(self)
            end
        end
    end


    def identifier()
        localctx = SwiftParser::IdentifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 400, SwiftParser.RULE_identifier)
        begin
            self.state = 1785
            token = self.input.LA(1)
            if [self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1783
                 match(SwiftParser::Identifier)

            elsif [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1784 
                self.context_sensitive_keyword()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class KeywordContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_keyword
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterKeyword(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitKeyword(self)
            end
        end
    end


    def keyword()
        localctx = SwiftParser::KeywordContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 402, SwiftParser.RULE_keyword)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1787
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__92) | (1 << self.T__91) | (1 << self.T__90) | (1 << self.T__83) | (1 << self.T__80) | (1 << self.T__73) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__66) | (1 << self.T__65) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__48) | (1 << self.T__47) | (1 << self.T__46) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__40) | (1 << self.T__38) | (1 << self.T__37) | (1 << self.T__34) | (1 << self.T__33) | (1 << self.T__31))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__13 - 66)) | (1 << (self.T__11 - 66)) | (1 << (self.T__9 - 66)) | (1 << (self.T__8 - 66)) | (1 << (self.T__7 - 66)) | (1 << (self.T__6 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Context_sensitive_keywordContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_context_sensitive_keyword
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterContext_sensitive_keyword(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitContext_sensitive_keyword(self)
            end
        end
    end


    def context_sensitive_keyword()
        localctx = SwiftParser::Context_sensitive_keywordContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 404, SwiftParser.RULE_context_sensitive_keyword)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1789
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Identifier_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def identifier_list() 
            getTypedRuleContext(SwiftParser::Identifier_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_identifier_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIdentifier_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIdentifier_list(self)
            end
        end
    end


    def identifier_list()
        localctx = SwiftParser::Identifier_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 406, SwiftParser.RULE_identifier_list)
        begin
            self.state = 1796
            la_ = self.interp.adaptivePredict(self.input,205,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1791 
                self.identifier()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1792 
                self.identifier()
                self.state = 1793
                 match(SwiftParser::T__72)
                self.state = 1794 
                self.identifier_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class LiteralContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def integer_literal() 
            getTypedRuleContext(SwiftParser::Integer_literalContext,0)
        end


        def Floating_point_literal()
            getToken(SwiftParser::Floating_point_literal, 0)
        end

        def String_literal()
            getToken(SwiftParser::String_literal, 0)
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_literal
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLiteral(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLiteral(self)
            end
        end
    end


    def literal()
        localctx = SwiftParser::LiteralContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 408, SwiftParser.RULE_literal)
        begin
            self.state = 1801
            token = self.input.LA(1)
            if [self.Binary_literal, self.Octal_literal, self.Decimal_literal, self.Hexadecimal_literal].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1798 
                self.integer_literal()

            elsif [self.Floating_point_literal].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1799
                 match(SwiftParser::Floating_point_literal)

            elsif [self.String_literal].member? token then 
                self.enterOuterAlt(localctx, 3)
                self.state = 1800
                 match(SwiftParser::String_literal)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Integer_literalContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def Hexadecimal_literal()
            getToken(SwiftParser::Hexadecimal_literal, 0)
        end

        def Binary_literal()
            getToken(SwiftParser::Binary_literal, 0)
        end

        def Octal_literal()
            getToken(SwiftParser::Octal_literal, 0)
        end

        def Decimal_literal()
            getToken(SwiftParser::Decimal_literal, 0)
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_integer_literal
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInteger_literal(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInteger_literal(self)
            end
        end
    end


    def integer_literal()
        localctx = SwiftParser::Integer_literalContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 410, SwiftParser.RULE_integer_literal)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1803
            _la = self.input.LA(1)
            if not (((((_la - 96)) & ~0x3f) == 0  and ((1 << (_la - 96)) & ((1 << (self.Binary_literal - 96)) | (1 << (self.Octal_literal - 96)) | (1 << (self.Decimal_literal - 96)) | (1 << (self.Hexadecimal_literal - 96)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator


    def sempred(localctx, ruleIndex, predIndex)
        if self.predicates.nil? then
            self.predicates = Hash.new
        end
        self.predicates[134] = self.pattern_sempred
        self.predicates[153] = self.expression_sempred
        self.predicates[185] = self.type_sempred
        pred = self.predicates[ruleIndex] 
        if pred.nil? then
            raise Exception.new("No predicate with index: #{ruleIndex}")
        else
            return pred(localctx, predIndex)
        end
    end
    def expression_sempred(localctx, predIndex)
            if predIndex == 1 then
                return self.precpred(self.ctx, 14)
         
            end

            if predIndex == 2 then
                return self.precpred(self.ctx, 13)
         
            end

            if predIndex == 3 then
                return self.precpred(self.ctx, 12)
         
            end

            if predIndex == 4 then
                return self.precpred(self.ctx, 11)
         
            end

            if predIndex == 5 then
                return self.precpred(self.ctx, 10)
         
            end

            if predIndex == 6 then
                return self.precpred(self.ctx, 9)
         
            end

            if predIndex == 7 then
                return self.precpred(self.ctx, 8)
         
            end

            if predIndex == 8 then
                return self.precpred(self.ctx, 7)
         
            end

            if predIndex == 9 then
                return self.precpred(self.ctx, 6)
         
            end

            if predIndex == 10 then
                return self.precpred(self.ctx, 5)
         
            end

            if predIndex == 11 then
                return self.precpred(self.ctx, 4)
         
            end

            if predIndex == 12 then
                return self.precpred(self.ctx, 3)
         
            end

            if predIndex == 13 then
                return self.precpred(self.ctx, 2)
         
            end

            if predIndex == 14 then
                return self.precpred(self.ctx, 1)
         
            end

    end
    def pattern_sempred(localctx, predIndex)
            if predIndex == 0 then
                return self.precpred(self.ctx, 2)
         
            end

    end
    def type_sempred(localctx, predIndex)
            if predIndex == 16 then
                return self.precpred(self.ctx, 9)
         
            end

            if predIndex == 17 then
                return self.precpred(self.ctx, 5)
         
            end

            if predIndex == 18 then
                return self.precpred(self.ctx, 4)
         
            end

            if predIndex == 19 then
                return self.precpred(self.ctx, 2)
         
            end

            if predIndex == 20 then
                return self.precpred(self.ctx, 1)
         
            end

            if predIndex == 15 then
                return self.precpred(self.ctx, 8)
         
            end

    end


end # class SwiftParser 
