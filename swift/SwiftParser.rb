# Generated from java-escape by ANTLR 4.4
require 'antlr4'
# how to handle package names?
# package = globals().get("__package__", None)
ischild = true # len(package)>0 if package is not None else False
if ischild then 
    require 'SwiftListener'
else
    require 'SwiftListener'
end

class SwiftParser < Parser 
    attr_accessor :grammarFileName 
    attr_accessor :atn, :decisionsToDFA,:sharedContextCache 
    attr_accessor :predicates, :interp
    attr_accessor :ruleNames, :tokenNames

      def self.serializedATN()
      "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3k\u0710\4\2\t"\
      "\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4\t\t\t\4\n\t\n"\
      "\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21"\
      "\4\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30"\
      "\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36"\
      "\4\37\t\37\4 \t \4!\t!\4\"\t\"\4\#\t\#\4$\t$\4%\t%\4&\t&\4\'\t\'\4"\
      "(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t\61"\
      "\4\62\t\62\4\63\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t"\
      "8\49\t9\4:\t:\4;\t;\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\t"\
      "C\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\tM\4N\t"\
      "N\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\tV\4W\tW\4X\tX\4Y\t"\
      "Y\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4"\
      "d\td\4e\te\4f\tf\4g\tg\4h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4"\
      "o\to\4p\tp\4q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4"\
      "z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080\4\u0081\t"\
      "\u0081\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084\t\u0084\4\u0085\t\u0085"\
      "\4\u0086\t\u0086\4\u0087\t\u0087\4\u0088\t\u0088\4\u0089\t\u0089\4"\
      "\u008a\t\u008a\4\u008b\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e"\
      "\t\u008e\4\u008f\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092\t"\
      "\u0092\4\u0093\t\u0093\4\u0094\t\u0094\4\u0095\t\u0095\4\u0096\t\u0096"\
      "\4\u0097\t\u0097\4\u0098\t\u0098\4\u0099\t\u0099\4\u009a\t\u009a\4"\
      "\u009b\t\u009b\4\u009c\t\u009c\4\u009d\t\u009d\4\u009e\t\u009e\4\u009f"\
      "\t\u009f\4\u00a0\t\u00a0\4\u00a1\t\u00a1\4\u00a2\t\u00a2\4\u00a3\t"\
      "\u00a3\4\u00a4\t\u00a4\4\u00a5\t\u00a5\4\u00a6\t\u00a6\4\u00a7\t\u00a7"\
      "\4\u00a8\t\u00a8\4\u00a9\t\u00a9\4\u00aa\t\u00aa\4\u00ab\t\u00ab\4"\
      "\u00ac\t\u00ac\4\u00ad\t\u00ad\4\u00ae\t\u00ae\4\u00af\t\u00af\4\u00b0"\
      "\t\u00b0\4\u00b1\t\u00b1\4\u00b2\t\u00b2\4\u00b3\t\u00b3\4\u00b4\t"\
      "\u00b4\4\u00b5\t\u00b5\4\u00b6\t\u00b6\4\u00b7\t\u00b7\4\u00b8\t\u00b8"\
      "\4\u00b9\t\u00b9\4\u00ba\t\u00ba\4\u00bb\t\u00bb\4\u00bc\t\u00bc\4"\
      "\u00bd\t\u00bd\4\u00be\t\u00be\4\u00bf\t\u00bf\4\u00c0\t\u00c0\4\u00c1"\
      "\t\u00c1\4\u00c2\t\u00c2\4\u00c3\t\u00c3\4\u00c4\t\u00c4\4\u00c5\t"\
      "\u00c5\4\u00c6\t\u00c6\4\u00c7\t\u00c7\4\u00c8\t\u00c8\4\u00c9\t\u00c9"\
      "\4\u00ca\t\u00ca\4\u00cb\t\u00cb\4\u00cc\t\u00cc\4\u00cd\t\u00cd\4"\
      "\u00ce\t\u00ce\4\u00cf\t\u00cf\3\2\3\2\7\2\u01a1\n\2\f\2\16\2\u01a4"\
      "\13\2\3\2\3\2\3\3\3\3\5\3\u01aa\n\3\3\3\3\3\5\3\u01ae\n\3\3\3\3\3"\
      "\5\3\u01b2\n\3\3\3\3\3\5\3\u01b6\n\3\3\3\3\3\3\3\5\3\u01bb\n\3\5\3"\
      "\u01bd\n\3\3\4\6\4\u01c0\n\4\r\4\16\4\u01c1\3\5\3\5\3\5\3\5\5\5\u01c8"\
      "\n\5\3\6\3\6\5\6\u01cc\n\6\3\6\3\6\5\6\u01d0\n\6\3\6\3\6\5\6\u01d4"\
      "\n\6\3\6\3\6\3\6\5\6\u01d9\n\6\3\6\3\6\5\6\u01dd\n\6\3\6\3\6\5\6\u01e1"\
      "\n\6\3\6\5\6\u01e4\n\6\3\7\3\7\5\7\u01e8\n\7\3\b\3\b\3\b\3\b\3\b\3"\
      "\b\3\t\3\t\3\t\3\t\3\n\3\n\5\n\u01f6\n\n\3\13\3\13\3\13\3\13\3\13"\
      "\3\f\3\f\5\f\u01ff\n\f\3\r\3\r\3\r\3\r\5\r\u0205\n\r\3\16\3\16\5\16"\
      "\u0209\n\16\3\17\3\17\3\17\3\17\5\17\u020f\n\17\3\20\3\20\3\20\3\20"\
      "\5\20\u0215\n\20\3\20\3\20\3\21\3\21\5\21\u021b\n\21\3\22\3\22\3\22"\
      "\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u0229\n\22\3\23"\
      "\3\23\3\23\3\23\3\24\3\24\5\24\u0231\n\24\3\24\3\24\5\24\u0235\n\24"\
      "\3\24\3\24\3\24\3\25\3\25\3\25\3\26\3\26\3\26\3\27\3\27\3\30\3\30"\
      "\3\30\3\30\3\30\3\30\5\30\u0248\n\30\3\31\3\31\3\31\3\32\3\32\3\33"\
      "\3\33\3\33\3\33\5\33\u0253\n\33\3\34\3\34\5\34\u0257\n\34\3\35\3\35"\
      "\5\35\u025b\n\35\3\36\3\36\3\37\3\37\5\37\u0261\n\37\3 \3 \3 \5 \u0266"\
      "\n \3 \3 \3!\3!\3!\3!\3!\5!\u026f\n!\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3"\
      "\"\3\"\5\"\u027a\n\"\3\#\3\#\3\#\3$\3$\3$\3$\3$\5$\u0284\n$\3%\3%"\
      "\5%\u0288\n%\3&\3&\3&\3&\3&\3&\3&\3&\5&\u0292\n&\3\'\3\'\3\'\3\'\3"\
      "(\3(\3(\3(\3)\3)\3)\7)\u029f\n)\f)\16)\u02a2\13)\3*\3*\3+\3+\3+\3"\
      "+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\5+\u02b4\n+\3,\3,\5,\u02b8\n,\3-\3"\
      "-\5-\u02bc\n-\3.\3.\3/\3/\5/\u02c2\n/\3/\3/\3\60\5\60\u02c7\n\60\3"\
      "\60\3\60\5\60\u02cb\n\60\3\60\3\60\3\61\3\61\3\62\3\62\3\62\3\62\3"\
      "\62\5\62\u02d6\n\62\3\63\3\63\5\63\u02da\n\63\3\64\5\64\u02dd\n\64"\
      "\3\64\5\64\u02e0\n\64\3\64\3\64\3\64\3\65\3\65\3\65\7\65\u02e8\n\65"\
      "\f\65\16\65\u02eb\13\65\3\66\3\66\5\66\u02ef\n\66\3\67\3\67\3\67\3"\
      "8\38\38\38\38\38\38\38\38\38\38\38\38\38\38\38\38\38\38\38\38\38\5"\
      "8\u030a\n8\38\38\58\u030e\n8\39\59\u0311\n9\39\59\u0314\n9\39\39\3"\
      ":\3:\3;\3;\3;\5;\u031d\n;\3;\3;\3;\3;\3;\3;\3;\5;\u0326\n;\3<\5<\u0329"\
      "\n<\3<\3<\3<\3=\5=\u032f\n=\3=\3=\5=\u0333\n=\3=\3=\3>\3>\3?\3?\3"\
      "?\5?\u033c\n?\3?\3?\3?\3?\3?\3?\3?\5?\u0345\n?\3@\5@\u0348\n@\3@\3"\
      "@\3A\5A\u034d\nA\3A\3A\3B\3B\3B\5B\u0354\nB\3B\3B\3B\3B\3B\3B\3B\5"\
      "B\u035d\nB\3C\5C\u0360\nC\3C\3C\5C\u0364\nC\3C\3C\3D\5D\u0369\nD\3"\
      "D\3D\5D\u036d\nD\3D\3D\3E\3E\3E\3F\3F\3F\3G\3G\3H\3H\3H\3I\3I\3I\5"\
      "I\u037f\nI\3I\3I\3I\3J\5J\u0385\nJ\3J\5J\u0388\nJ\3J\3J\3K\3K\5K\u038e"\
      "\nK\3L\3L\5L\u0392\nL\3M\3M\5M\u0396\nM\3M\3M\3N\3N\3O\3O\5O\u039e"\
      "\nO\3P\3P\3P\3P\3P\5P\u03a5\nP\3P\3P\5P\u03a9\nP\3Q\3Q\3Q\3Q\3Q\5"\
      "Q\u03b0\nQ\3R\5R\u03b3\nR\3R\5R\u03b6\nR\3R\5R\u03b9\nR\3R\3R\5R\u03bd"\
      "\nR\3R\3R\5R\u03c1\nR\3R\5R\u03c4\nR\3R\3R\5R\u03c8\nR\3R\3R\5R\u03cc"\
      "\nR\3R\3R\5R\u03d0\nR\3R\5R\u03d3\nR\3R\5R\u03d6\nR\3S\3S\5S\u03da"\
      "\nS\3T\3T\5T\u03de\nT\3U\3U\3U\3V\5V\u03e4\nV\3V\3V\5V\u03e8\nV\3"\
      "V\5V\u03eb\nV\3W\3W\5W\u03ef\nW\3W\3W\5W\u03f3\nW\3W\3W\3X\3X\5X\u03f9"\
      "\nX\3Y\3Y\5Y\u03fd\nY\3Z\5Z\u0400\nZ\3Z\3Z\3Z\3[\3[\3[\3[\3[\5[\u040a"\
      "\n[\3\\\3\\\5\\\u040e\n\\\3]\3]\3^\3^\3_\3_\5_\u0416\n_\3_\3_\3_\3"\
      "_\5_\u041c\n_\3_\3_\3`\3`\5`\u0422\n`\3a\3a\5a\u0426\na\3b\5b\u0429"\
      "\nb\3b\3b\3b\3c\3c\3c\3c\3c\5c\u0433\nc\3d\3d\5d\u0437\nd\3e\3e\3"\
      "e\3f\5f\u043d\nf\3f\3f\3f\5f\u0442\nf\3f\5f\u0445\nf\3f\3f\3g\3g\3"\
      "h\3h\5h\u044d\nh\3h\3h\3i\5i\u0452\ni\3i\3i\3i\5i\u0457\ni\3i\5i\u045a"\
      "\ni\3i\3i\3j\3j\3k\3k\5k\u0462\nk\3k\3k\3l\5l\u0467\nl\3l\3l\3l\5"\
      "l\u046c\nl\3l\3l\3m\3m\3n\3n\5n\u0474\nn\3n\3n\3o\3o\3o\3o\3o\5o\u047d"\
      "\no\3p\3p\5p\u0481\np\3q\3q\3q\3q\3q\3r\3r\3r\5r\u048b\nr\3r\3r\3"\
      "s\3s\5s\u0491\ns\3s\3s\3t\3t\3t\3t\3u\3u\5u\u049b\nu\3u\5u\u049e\n"\
      "u\3v\3v\5v\u04a2\nv\3v\3v\3v\3w\5w\u04a8\nw\3w\5w\u04ab\nw\3w\3w\3"\
      "x\3x\3y\5y\u04b2\ny\3y\3y\3y\3z\3z\3z\5z\u04ba\nz\3z\3z\3{\3{\5{\u04c0"\
      "\n{\3{\3{\3|\3|\3|\3|\3|\3|\3|\3|\3|\3|\3|\3|\5|\u04d0\n|\3}\5}\u04d3"\
      "\n}\3}\3}\3}\3~\3~\5~\u04da\n~\3~\3~\3\177\3\177\3\177\5\177\u04e1"\
      "\n\177\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080\3\u0081\3\u0081"\
      "\3\u0081\3\u0081\3\u0081\3\u0081\3\u0082\3\u0082\3\u0082\3\u0082\3"\
      "\u0082\3\u0082\3\u0082\3\u0083\5\u0083\u04f7\n\u0083\3\u0083\5\u0083"\
      "\u04fa\n\u0083\3\u0084\3\u0084\3\u0084\3\u0085\3\u0085\3\u0086\3\u0086"\
      "\3\u0086\3\u0087\3\u0087\3\u0088\3\u0088\3\u0088\5\u0088\u0509\n\u0088"\
      "\3\u0088\3\u0088\5\u0088\u050d\n\u0088\3\u0088\3\u0088\3\u0088\5\u0088"\
      "\u0512\n\u0088\3\u0088\3\u0088\3\u0088\3\u0088\5\u0088\u0518\n\u0088"\
      "\3\u0088\3\u0088\3\u0088\7\u0088\u051d\n\u0088\f\u0088\16\u0088\u0520"\
      "\13\u0088\3\u0089\3\u0089\3\u008a\3\u008a\3\u008b\3\u008b\3\u008b"\
      "\3\u008b\5\u008b\u052a\n\u008b\3\u008c\3\u008c\5\u008c\u052e\n\u008c"\
      "\3\u008c\3\u008c\3\u008d\3\u008d\3\u008d\7\u008d\u0535\n\u008d\f\u008d"\
      "\16\u008d\u0538\13\u008d\3\u008e\3\u008e\3\u008f\5\u008f\u053d\n\u008f"\
      "\3\u008f\3\u008f\3\u008f\5\u008f\u0542\n\u008f\3\u0090\3\u0090\5\u0090"\
      "\u0546\n\u0090\3\u0091\3\u0091\3\u0091\3\u0092\3\u0092\3\u0092\3\u0092"\
      "\3\u0093\3\u0093\3\u0094\3\u0094\3\u0094\5\u0094\u0554\n\u0094\3\u0095"\
      "\3\u0095\3\u0096\3\u0096\5\u0096\u055a\n\u0096\3\u0096\3\u0096\3\u0097"\
      "\6\u0097\u055f\n\u0097\r\u0097\16\u0097\u0560\3\u0098\6\u0098\u0564"\
      "\n\u0098\r\u0098\16\u0098\u0565\3\u0099\3\u0099\5\u0099\u056a\n\u0099"\
      "\3\u0099\3\u0099\3\u0099\5\u0099\u056f\n\u0099\3\u0099\3\u0099\3\u0099"\
      "\5\u0099\u0574\n\u0099\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099"\
      "\5\u0099\u057c\n\u0099\3\u009a\3\u009a\3\u009a\7\u009a\u0581\n\u009a"\
      "\f\u009a\16\u009a\u0584\13\u009a\3\u009b\3\u009b\3\u009b\3\u009b\3"\
      "\u009b\3\u009b\5\u009b\u058c\n\u009b\3\u009b\3\u009b\3\u009b\3\u009b"\
      "\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3"\
      "\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\5\u009b\u05a1"\
      "\n\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3"\
      "\u009b\3\u009b\3\u009b\5\u009b\u05ad\n\u009b\3\u009b\3\u009b\3\u009b"\
      "\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3\u009b\3"\
      "\u009b\3\u009b\3\u009b\3\u009b\7\u009b\u05be\n\u009b\f\u009b\16\u009b"\
      "\u05c1\13\u009b\3\u009c\3\u009c\3\u009c\3\u009d\3\u009d\3\u009e\3"\
      "\u009e\3\u009e\3\u009e\3\u009f\3\u009f\3\u009f\3\u009f\5\u009f\u05d0"\
      "\n\u009f\3\u009f\5\u009f\u05d3\n\u009f\3\u00a0\3\u00a0\3\u00a1\3\u00a1"\
      "\5\u00a1\u05d9\n\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1"\
      "\3\u00a1\5\u00a1\u05e2\n\u00a1\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2"\
      "\3\u00a2\3\u00a2\5\u00a2\u05eb\n\u00a2\3\u00a3\3\u00a3\5\u00a3\u05ef"\
      "\n\u00a3\3\u00a3\3\u00a3\3\u00a4\3\u00a4\5\u00a4\u05f5\n\u00a4\3\u00a4"\
      "\3\u00a4\3\u00a4\3\u00a4\5\u00a4\u05fb\n\u00a4\3\u00a5\3\u00a5\3\u00a6"\
      "\3\u00a6\3\u00a6\3\u00a6\3\u00a6\3\u00a6\3\u00a6\5\u00a6\u0606\n\u00a6"\
      "\3\u00a7\3\u00a7\5\u00a7\u060a\n\u00a7\3\u00a7\3\u00a7\3\u00a7\3\u00a7"\
      "\3\u00a8\3\u00a8\3\u00a8\3\u00a8\3\u00a9\3\u00a9\3\u00a9\3\u00a9\3"\
      "\u00a9\3\u00a9\3\u00a9\3\u00a9\3\u00a9\3\u00a9\3\u00a9\3\u00a9\5\u00a9"\
      "\u0620\n\u00a9\3\u00aa\3\u00aa\3\u00aa\3\u00aa\5\u00aa\u0626\n\u00aa"\
      "\3\u00ab\3\u00ab\3\u00ab\3\u00ab\3\u00ac\3\u00ac\3\u00ac\3\u00ac\3"\
      "\u00ac\3\u00ad\3\u00ad\3\u00ad\3\u00ad\3\u00ae\3\u00ae\5\u00ae\u0637"\
      "\n\u00ae\3\u00ae\3\u00ae\3\u00ae\3\u00af\3\u00af\5\u00af\u063e\n\u00af"\
      "\3\u00af\3\u00af\3\u00af\3\u00af\5\u00af\u0644\n\u00af\3\u00af\3\u00af"\
      "\3\u00af\3\u00af\3\u00af\5\u00af\u064b\n\u00af\3\u00af\3\u00af\3\u00af"\
      "\3\u00af\3\u00af\5\u00af\u0652\n\u00af\3\u00af\3\u00af\3\u00af\3\u00af"\
      "\3\u00af\5\u00af\u0659\n\u00af\3\u00b0\3\u00b0\3\u00b0\3\u00b0\3\u00b0"\
      "\3\u00b1\3\u00b1\3\u00b2\3\u00b2\3\u00b2\3\u00b3\3\u00b3\5\u00b3\u0667"\
      "\n\u00b3\3\u00b3\3\u00b3\3\u00b4\3\u00b4\3\u00b4\3\u00b4\3\u00b4\5"\
      "\u00b4\u0670\n\u00b4\3\u00b5\3\u00b5\3\u00b5\3\u00b5\3\u00b5\5\u00b5"\
      "\u0677\n\u00b5\3\u00b6\3\u00b6\3\u00b7\3\u00b7\3\u00b8\3\u00b8\3\u00b9"\
      "\3\u00b9\3\u00ba\3\u00ba\3\u00bb\3\u00bb\3\u00bb\3\u00bb\5\u00bb\u0687"\
      "\n\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb\3"\
      "\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb"\
      "\7\u00bb\u0699\n\u00bb\f\u00bb\16\u00bb\u069c\13\u00bb\3\u00bc\3\u00bc"\
      "\5\u00bc\u06a0\n\u00bc\3\u00bc\3\u00bc\3\u00bd\3\u00bd\5\u00bd\u06a6"\
      "\n\u00bd\3\u00bd\3\u00bd\5\u00bd\u06aa\n\u00bd\3\u00bd\3\u00bd\3\u00bd"\
      "\5\u00bd\u06af\n\u00bd\3\u00be\3\u00be\3\u00bf\3\u00bf\5\u00bf\u06b5"\
      "\n\u00bf\3\u00bf\3\u00bf\3\u00c0\3\u00c0\5\u00c0\u06bb\n\u00c0\3\u00c1"\
      "\3\u00c1\3\u00c1\3\u00c1\3\u00c1\5\u00c1\u06c2\n\u00c1\3\u00c2\5\u00c2"\
      "\u06c5\n\u00c2\3\u00c2\5\u00c2\u06c8\n\u00c2\3\u00c2\3\u00c2\5\u00c2"\
      "\u06cc\n\u00c2\3\u00c2\3\u00c2\3\u00c2\5\u00c2\u06d1\n\u00c2\3\u00c3"\
      "\3\u00c3\3\u00c4\3\u00c4\3\u00c4\5\u00c4\u06d8\n\u00c4\3\u00c4\3\u00c4"\
      "\3\u00c5\3\u00c5\3\u00c5\3\u00c5\3\u00c5\5\u00c5\u06e1\n\u00c5\3\u00c6"\
      "\3\u00c6\3\u00c7\3\u00c7\3\u00c7\3\u00c7\3\u00c7\3\u00c7\3\u00c7\3"\
      "\u00c7\5\u00c7\u06ed\n\u00c7\3\u00c8\3\u00c8\3\u00c8\3\u00c9\3\u00c9"\
      "\3\u00c9\7\u00c9\u06f5\n\u00c9\f\u00c9\16\u00c9\u06f8\13\u00c9\3\u00ca"\
      "\3\u00ca\5\u00ca\u06fc\n\u00ca\3\u00cb\3\u00cb\3\u00cc\3\u00cc\3\u00cd"\
      "\3\u00cd\3\u00cd\3\u00cd\3\u00cd\5\u00cd\u0707\n\u00cd\3\u00ce\3\u00ce"\
      "\3\u00ce\5\u00ce\u070c\n\u00ce\3\u00cf\3\u00cf\3\u00cf\2\5\u010e\u0134"\
      "\u0174\u00d0\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62"\
      "\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086"\
      "\u0088\u008a\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u009a\u009c"\
      "\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae\u00b0\u00b2"\
      "\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0\u00c2\u00c4\u00c6\u00c8"\
      "\u00ca\u00cc\u00ce\u00d0\u00d2\u00d4\u00d6\u00d8\u00da\u00dc\u00de"\
      "\u00e0\u00e2\u00e4\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0\u00f2\u00f4"\
      "\u00f6\u00f8\u00fa\u00fc\u00fe\u0100\u0102\u0104\u0106\u0108\u010a"\
      "\u010c\u010e\u0110\u0112\u0114\u0116\u0118\u011a\u011c\u011e\u0120"\
      "\u0122\u0124\u0126\u0128\u012a\u012c\u012e\u0130\u0132\u0134\u0136"\
      "\u0138\u013a\u013c\u013e\u0140\u0142\u0144\u0146\u0148\u014a\u014c"\
      "\u014e\u0150\u0152\u0154\u0156\u0158\u015a\u015c\u015e\u0160\u0162"\
      "\u0164\u0166\u0168\u016a\u016c\u016e\u0170\u0172\u0174\u0176\u0178"\
      "\u017a\u017c\u017e\u0180\u0182\u0184\u0186\u0188\u018a\u018c\u018e"\
      "\u0190\u0192\u0194\u0196\u0198\u019a\u019c\2\n\n\2\23\23\31\31\#\#"\
      "&&\63\63AAIJ[[\t\2\4\4\33\33))--\63\6399^^\5\2\24\24\30\30FF\6\2\31"\
      "\31\#\#AAII\17\2\r\16\37\37\'\',,\64\64;;??BBMMOOSSUU\\\\\25\2\3\5"\
      "\f\f\17\17\26\26\33\36%&))++-\63\67\679:=>@@DDGGRRTTVY^_\17\2\6\n"\
      "\20\21\23\24\30\31\#\#((<<AAFFIJQQ[[]]\3\2be\u075e\2\u01a2\3\2\2\2"\
      "\4\u01bc\3\2\2\2\6\u01bf\3\2\2\2\b\u01c7\3\2\2\2\n\u01e3\3\2\2\2\f"\
      "\u01e7\3\2\2\2\16\u01e9\3\2\2\2\20\u01ef\3\2\2\2\22\u01f5\3\2\2\2"\
      "\24\u01f7\3\2\2\2\26\u01fe\3\2\2\2\30\u0200\3\2\2\2\32\u0208\3\2\2"\
      "\2\34\u020e\3\2\2\2\36\u0210\3\2\2\2 \u0218\3\2\2\2\"\u0228\3\2\2"\
      "\2$\u022a\3\2\2\2&\u022e\3\2\2\2(\u0239\3\2\2\2*\u023c\3\2\2\2,\u023f"\
      "\3\2\2\2.\u0247\3\2\2\2\60\u0249\3\2\2\2\62\u024c\3\2\2\2\64\u0252"\
      "\3\2\2\2\66\u0254\3\2\2\28\u0258\3\2\2\2:\u025c\3\2\2\2<\u025e\3\2"\
      "\2\2>\u0262\3\2\2\2@\u026e\3\2\2\2B\u0279\3\2\2\2D\u027b\3\2\2\2F"\
      "\u0283\3\2\2\2H\u0287\3\2\2\2J\u0291\3\2\2\2L\u0293\3\2\2\2N\u0297"\
      "\3\2\2\2P\u029b\3\2\2\2R\u02a3\3\2\2\2T\u02b3\3\2\2\2V\u02b5\3\2\2"\
      "\2X\u02b9\3\2\2\2Z\u02bd\3\2\2\2\\\u02bf\3\2\2\2^\u02c6\3\2\2\2`\u02ce"\
      "\3\2\2\2b\u02d5\3\2\2\2d\u02d9\3\2\2\2f\u02dc\3\2\2\2h\u02e4\3\2\2"\
      "\2j\u02ec\3\2\2\2l\u02f0\3\2\2\2n\u030d\3\2\2\2p\u0310\3\2\2\2r\u0317"\
      "\3\2\2\2t\u0325\3\2\2\2v\u0328\3\2\2\2x\u032e\3\2\2\2z\u0336\3\2\2"\
      "\2|\u0344\3\2\2\2~\u0347\3\2\2\2\u0080\u034c\3\2\2\2\u0082\u035c\3"\
      "\2\2\2\u0084\u035f\3\2\2\2\u0086\u0368\3\2\2\2\u0088\u0370\3\2\2\2"\
      "\u008a\u0373\3\2\2\2\u008c\u0376\3\2\2\2\u008e\u0378\3\2\2\2\u0090"\
      "\u037b\3\2\2\2\u0092\u0384\3\2\2\2\u0094\u038d\3\2\2\2\u0096\u038f"\
      "\3\2\2\2\u0098\u0393\3\2\2\2\u009a\u0399\3\2\2\2\u009c\u039b\3\2\2"\
      "\2\u009e\u03a8\3\2\2\2\u00a0\u03af\3\2\2\2\u00a2\u03d5\3\2\2\2\u00a4"\
      "\u03d9\3\2\2\2\u00a6\u03dd\3\2\2\2\u00a8\u03df\3\2\2\2\u00aa\u03ea"\
      "\3\2\2\2\u00ac\u03ec\3\2\2\2\u00ae\u03f6\3\2\2\2\u00b0\u03fc\3\2\2"\
      "\2\u00b2\u03ff\3\2\2\2\u00b4\u0409\3\2\2\2\u00b6\u040b\3\2\2\2\u00b8"\
      "\u040f\3\2\2\2\u00ba\u0411\3\2\2\2\u00bc\u0413\3\2\2\2\u00be\u041f"\
      "\3\2\2\2\u00c0\u0425\3\2\2\2\u00c2\u0428\3\2\2\2\u00c4\u0432\3\2\2"\
      "\2\u00c6\u0434\3\2\2\2\u00c8\u0438\3\2\2\2\u00ca\u043c\3\2\2\2\u00cc"\
      "\u0448\3\2\2\2\u00ce\u044a\3\2\2\2\u00d0\u0451\3\2\2\2\u00d2\u045d"\
      "\3\2\2\2\u00d4\u045f\3\2\2\2\u00d6\u0466\3\2\2\2\u00d8\u046f\3\2\2"\
      "\2\u00da\u0471\3\2\2\2\u00dc\u047c\3\2\2\2\u00de\u047e\3\2\2\2\u00e0"\
      "\u0482\3\2\2\2\u00e2\u0487\3\2\2\2\u00e4\u048e\3\2\2\2\u00e6\u0494"\
      "\3\2\2\2\u00e8\u0498\3\2\2\2\u00ea\u049f\3\2\2\2\u00ec\u04a7\3\2\2"\
      "\2\u00ee\u04ae\3\2\2\2\u00f0\u04b1\3\2\2\2\u00f2\u04b6\3\2\2\2\u00f4"\
      "\u04bd\3\2\2\2\u00f6\u04cf\3\2\2\2\u00f8\u04d2\3\2\2\2\u00fa\u04d7"\
      "\3\2\2\2\u00fc\u04e0\3\2\2\2\u00fe\u04e2\3\2\2\2\u0100\u04e8\3\2\2"\
      "\2\u0102\u04ee\3\2\2\2\u0104\u04f6\3\2\2\2\u0106\u04fb\3\2\2\2\u0108"\
      "\u04fe\3\2\2\2\u010a\u0500\3\2\2\2\u010c\u0503\3\2\2\2\u010e\u0517"\
      "\3\2\2\2\u0110\u0521\3\2\2\2\u0112\u0523\3\2\2\2\u0114\u0529\3\2\2"\
      "\2\u0116\u052b\3\2\2\2\u0118\u0531\3\2\2\2\u011a\u0539\3\2\2\2\u011c"\
      "\u053c\3\2\2\2\u011e\u0545\3\2\2\2\u0120\u0547\3\2\2\2\u0122\u054a"\
      "\3\2\2\2\u0124\u054e\3\2\2\2\u0126\u0550\3\2\2\2\u0128\u0555\3\2\2"\
      "\2\u012a\u0557\3\2\2\2\u012c\u055e\3\2\2\2\u012e\u0563\3\2\2\2\u0130"\
      "\u057b\3\2\2\2\u0132\u057d\3\2\2\2\u0134\u058b\3\2\2\2\u0136\u05c2"\
      "\3\2\2\2\u0138\u05c5\3\2\2\2\u013a\u05c7\3\2\2\2\u013c\u05d2\3\2\2"\
      "\2\u013e\u05d4\3\2\2\2\u0140\u05e1\3\2\2\2\u0142\u05ea\3\2\2\2\u0144"\
      "\u05ec\3\2\2\2\u0146\u05fa\3\2\2\2\u0148\u05fc\3\2\2\2\u014a\u0605"\
      "\3\2\2\2\u014c\u0607\3\2\2\2\u014e\u060f\3\2\2\2\u0150\u061f\3\2\2"\
      "\2\u0152\u0625\3\2\2\2\u0154\u0627\3\2\2\2\u0156\u062b\3\2\2\2\u0158"\
      "\u0630\3\2\2\2\u015a\u0634\3\2\2\2\u015c\u0658\3\2\2\2\u015e\u065a"\
      "\3\2\2\2\u0160\u065f\3\2\2\2\u0162\u0661\3\2\2\2\u0164\u0664\3\2\2"\
      "\2\u0166\u066f\3\2\2\2\u0168\u0676\3\2\2\2\u016a\u0678\3\2\2\2\u016c"\
      "\u067a\3\2\2\2\u016e\u067c\3\2\2\2\u0170\u067e\3\2\2\2\u0172\u0680"\
      "\3\2\2\2\u0174\u0686\3\2\2\2\u0176\u069d\3\2\2\2\u0178\u06ae\3\2\2"\
      "\2\u017a\u06b0\3\2\2\2\u017c\u06b2\3\2\2\2\u017e\u06b8\3\2\2\2\u0180"\
      "\u06c1\3\2\2\2\u0182\u06d0\3\2\2\2\u0184\u06d2\3\2\2\2\u0186\u06d4"\
      "\3\2\2\2\u0188\u06e0\3\2\2\2\u018a\u06e2\3\2\2\2\u018c\u06ec\3\2\2"\
      "\2\u018e\u06ee\3\2\2\2\u0190\u06f1\3\2\2\2\u0192\u06fb\3\2\2\2\u0194"\
      "\u06fd\3\2\2\2\u0196\u06ff\3\2\2\2\u0198\u0706\3\2\2\2\u019a\u070b"\
      "\3\2\2\2\u019c\u070d\3\2\2\2\u019e\u01a1\5\4\3\2\u019f\u01a1\5\u0134"\
      "\u009b\2\u01a0\u019e\3\2\2\2\u01a0\u019f\3\2\2\2\u01a1\u01a4\3\2\2"\
      "\2\u01a2\u01a0\3\2\2\2\u01a2\u01a3\3\2\2\2\u01a3\u01a5\3\2\2\2\u01a4"\
      "\u01a2\3\2\2\2\u01a5\u01a6\7\2\2\3\u01a6\3\3\2\2\2\u01a7\u01a9\5\u0134"\
      "\u009b\2\u01a8\u01aa\7\65\2\2\u01a9\u01a8\3\2\2\2\u01a9\u01aa\3\2"\
      "\2\2\u01aa\u01bd\3\2\2\2\u01ab\u01ad\5T+\2\u01ac\u01ae\7\65\2\2\u01ad"\
      "\u01ac\3\2\2\2\u01ad\u01ae\3\2\2\2\u01ae\u01bd\3\2\2\2\u01af\u01b1"\
      "\5\b\5\2\u01b0\u01b2\7\65\2\2\u01b1\u01b0\3\2\2\2\u01b1\u01b2\3\2"\
      "\2\2\u01b2\u01bd\3\2\2\2\u01b3\u01b5\5\26\f\2\u01b4\u01b6\7\65\2\2"\
      "\u01b5\u01b4\3\2\2\2\u01b5\u01b6\3\2\2\2\u01b6\u01bd\3\2\2\2\u01b7"\
      "\u01bd\5.\30\2\u01b8\u01ba\5\64\33\2\u01b9\u01bb\7\65\2\2\u01ba\u01b9"\
      "\3\2\2\2\u01ba\u01bb\3\2\2\2\u01bb\u01bd\3\2\2\2\u01bc\u01a7\3\2\2"\
      "\2\u01bc\u01ab\3\2\2\2\u01bc\u01af\3\2\2\2\u01bc\u01b3\3\2\2\2\u01bc"\
      "\u01b7\3\2\2\2\u01bc\u01b8\3\2\2\2\u01bd\5\3\2\2\2\u01be\u01c0\5\4"\
      "\3\2\u01bf\u01be\3\2\2\2\u01c0\u01c1\3\2\2\2\u01c1\u01bf\3\2\2\2\u01c1"\
      "\u01c2\3\2\2\2\u01c2\7\3\2\2\2\u01c3\u01c8\5\n\6\2\u01c4\u01c8\5\16"\
      "\b\2\u01c5\u01c8\5\20\t\2\u01c6\u01c8\5\24\13\2\u01c7\u01c3\3\2\2"\
      "\2\u01c7\u01c4\3\2\2\2\u01c7\u01c5\3\2\2\2\u01c7\u01c6\3\2\2\2\u01c8"\
      "\t\3\2\2\2\u01c9\u01cb\7\17\2\2\u01ca\u01cc\5\f\7\2\u01cb\u01ca\3"\
      "\2\2\2\u01cb\u01cc\3\2\2\2\u01cc\u01cd\3\2\2\2\u01cd\u01cf\7\65\2"\
      "\2\u01ce\u01d0\5\u0134\u009b\2\u01cf\u01ce\3\2\2\2\u01cf\u01d0\3\2"\
      "\2\2\u01d0\u01d1\3\2\2\2\u01d1\u01d3\7\65\2\2\u01d2\u01d4\5\u0134"\
      "\u009b\2\u01d3\u01d2\3\2\2\2\u01d3\u01d4\3\2\2\2\u01d4\u01d5\3\2\2"\
      "\2\u01d5\u01e4\5\\/\2\u01d6\u01d8\7\17\2\2\u01d7\u01d9\5\f\7\2\u01d8"\
      "\u01d7\3\2\2\2\u01d8\u01d9\3\2\2\2\u01d9\u01da\3\2\2\2\u01da\u01dc"\
      "\7\65\2\2\u01db\u01dd\5\u0134\u009b\2\u01dc\u01db\3\2\2\2\u01dc\u01dd"\
      "\3\2\2\2\u01dd\u01de\3\2\2\2\u01de\u01e0\7\65\2\2\u01df\u01e1\5\u0134"\
      "\u009b\2\u01e0\u01df\3\2\2\2\u01e0\u01e1\3\2\2\2\u01e1\u01e2\3\2\2"\
      "\2\u01e2\u01e4\5\\/\2\u01e3\u01c9\3\2\2\2\u01e3\u01d6\3\2\2\2\u01e4"\
      "\13\3\2\2\2\u01e5\u01e8\5n8\2\u01e6\u01e8\5\u0132\u009a\2\u01e7\u01e5"\
      "\3\2\2\2\u01e7\u01e6\3\2\2\2\u01e8\r\3\2\2\2\u01e9\u01ea\7\17\2\2"\
      "\u01ea\u01eb\5\u010e\u0088\2\u01eb\u01ec\7W\2\2\u01ec\u01ed\5\u0134"\
      "\u009b\2\u01ed\u01ee\5\\/\2\u01ee\17\3\2\2\2\u01ef\u01f0\7\f\2\2\u01f0"\
      "\u01f1\5\22\n\2\u01f1\u01f2\5\\/\2\u01f2\21\3\2\2\2\u01f3\u01f6\5"\
      "\u0134\u009b\2\u01f4\u01f6\5T+\2\u01f5\u01f3\3\2\2\2\u01f5\u01f4\3"\
      "\2\2\2\u01f6\23\3\2\2\2\u01f7\u01f8\7\26\2\2\u01f8\u01f9\5\\/\2\u01f9"\
      "\u01fa\7\f\2\2\u01fa\u01fb\5\22\n\2\u01fb\25\3\2\2\2\u01fc\u01ff\5"\
      "\30\r\2\u01fd\u01ff\5\36\20\2\u01fe\u01fc\3\2\2\2\u01fe\u01fd\3\2"\
      "\2\2\u01ff\27\3\2\2\2\u0200\u0201\7\67\2\2\u0201\u0202\5\32\16\2\u0202"\
      "\u0204\5\\/\2\u0203\u0205\5\34\17\2\u0204\u0203\3\2\2\2\u0204\u0205"\
      "\3\2\2\2\u0205\31\3\2\2\2\u0206\u0209\5\u0134\u009b\2\u0207\u0209"\
      "\5T+\2\u0208\u0206\3\2\2\2\u0208\u0207\3\2\2\2\u0209\33\3\2\2\2\u020a"\
      "\u020b\7V\2\2\u020b\u020f\5\\/\2\u020c\u020d\7V\2\2\u020d\u020f\5"\
      "\30\r\2\u020e\u020a\3\2\2\2\u020e\u020c\3\2\2\2\u020f\35\3\2\2\2\u0210"\
      "\u0211\7>\2\2\u0211\u0212\5\u0134\u009b\2\u0212\u0214\7\13\2\2\u0213"\
      "\u0215\5 \21\2\u0214\u0213\3\2\2\2\u0214\u0215\3\2\2\2\u0215\u0216"\
      "\3\2\2\2\u0216\u0217\7\66\2\2\u0217\37\3\2\2\2\u0218\u021a\5\"\22"\
      "\2\u0219\u021b\5 \21\2\u021a\u0219\3\2\2\2\u021a\u021b\3\2\2\2\u021b"\
      "!\3\2\2\2\u021c\u021d\5$\23\2\u021d\u021e\5\6\4\2\u021e\u0229\3\2"\
      "\2\2\u021f\u0220\5(\25\2\u0220\u0221\5\6\4\2\u0221\u0229\3\2\2\2\u0222"\
      "\u0223\5$\23\2\u0223\u0224\7\65\2\2\u0224\u0229\3\2\2\2\u0225\u0226"\
      "\5(\25\2\u0226\u0227\7\65\2\2\u0227\u0229\3\2\2\2\u0228\u021c\3\2"\
      "\2\2\u0228\u021f\3\2\2\2\u0228\u0222\3\2\2\2\u0228\u0225\3\2\2\2\u0229"\
      "\#\3\2\2\2\u022a\u022b\7D\2\2\u022b\u022c\5&\24\2\u022c\u022d\7K\2"\
      "\2\u022d%\3\2\2\2\u022e\u0230\5\u010e\u0088\2\u022f\u0231\5*\26\2"\
      "\u0230\u022f\3\2\2\2\u0230\u0231\3\2\2\2\u0231\u0232\3\2\2\2\u0232"\
      "\u0234\5\u010e\u0088\2\u0233\u0235\5*\26\2\u0234\u0233\3\2\2\2\u0234"\
      "\u0235\3\2\2\2\u0235\u0236\3\2\2\2\u0236\u0237\7\27\2\2\u0237\u0238"\
      "\5&\24\2\u0238\'\3\2\2\2\u0239\u023a\7\3\2\2\u023a\u023b\7K\2\2\u023b"\
      ")\3\2\2\2\u023c\u023d\7T\2\2\u023d\u023e\5,\27\2\u023e+\3\2\2\2\u023f"\
      "\u0240\5\u0134\u009b\2\u0240-\3\2\2\2\u0241\u0242\5\60\31\2\u0242"\
      "\u0243\5\b\5\2\u0243\u0248\3\2\2\2\u0244\u0245\5\60\31\2\u0245\u0246"\
      "\5\36\20\2\u0246\u0248\3\2\2\2\u0247\u0241\3\2\2\2\u0247\u0244\3\2"\
      "\2\2\u0248/\3\2\2\2\u0249\u024a\5\62\32\2\u024a\u024b\7K\2\2\u024b"\
      "\61\3\2\2\2\u024c\u024d\5\u0192\u00ca\2\u024d\63\3\2\2\2\u024e\u0253"\
      "\5\66\34\2\u024f\u0253\58\35\2\u0250\u0253\5:\36\2\u0251\u0253\5<"\
      "\37\2\u0252\u024e\3\2\2\2\u0252\u024f\3\2\2\2\u0252\u0250\3\2\2\2"\
      "\u0252\u0251\3\2\2\2\u0253\65\3\2\2\2\u0254\u0256\7:\2\2\u0255\u0257"\
      "\5\62\32\2\u0256\u0255\3\2\2\2\u0256\u0257\3\2\2\2\u0257\67\3\2\2"\
      "\2\u0258\u025a\7\60\2\2\u0259\u025b\5\62\32\2\u025a\u0259\3\2\2\2"\
      "\u025a\u025b\3\2\2\2\u025b9\3\2\2\2\u025c\u025d\7R\2\2\u025d;\3\2"\
      "\2\2\u025e\u0260\7\62\2\2\u025f\u0261\5\u0134\u009b\2\u0260\u025f"\
      "\3\2\2\2\u0260\u0261\3\2\2\2\u0261=\3\2\2\2\u0262\u0263\7\37\2\2\u0263"\
      "\u0265\5@!\2\u0264\u0266\5D\#\2\u0265\u0264\3\2\2\2\u0265\u0266\3"\
      "\2\2\2\u0266\u0267\3\2\2\2\u0267\u0268\7O\2\2\u0268?\3\2\2\2\u0269"\
      "\u026f\5B\"\2\u026a\u026b\5B\"\2\u026b\u026c\7\27\2\2\u026c\u026d"\
      "\5@!\2\u026d\u026f\3\2\2\2\u026e\u0269\3\2\2\2\u026e\u026a\3\2\2\2"\
      "\u026fA\3\2\2\2\u0270\u027a\5\u017a\u00be\2\u0271\u0272\5\u017a\u00be"\
      "\2\u0272\u0273\7K\2\2\u0273\u0274\5\u0178\u00bd\2\u0274\u027a\3\2"\
      "\2\2\u0275\u0276\5\u017a\u00be\2\u0276\u0277\7K\2\2\u0277\u0278\5"\
      "\u0186\u00c4\2\u0278\u027a\3\2\2\2\u0279\u0270\3\2\2\2\u0279\u0271"\
      "\3\2\2\2\u0279\u0275\3\2\2\2\u027aC\3\2\2\2\u027b\u027c\7T\2\2\u027c"\
      "\u027d\5F$\2\u027dE\3\2\2\2\u027e\u0284\5H%\2\u027f\u0280\5H%\2\u0280"\
      "\u0281\7\27\2\2\u0281\u0282\5F$\2\u0282\u0284\3\2\2\2\u0283\u027e"\
      "\3\2\2\2\u0283\u027f\3\2\2\2\u0284G\3\2\2\2\u0285\u0288\5J&\2\u0286"\
      "\u0288\5L\'\2\u0287\u0285\3\2\2\2\u0287\u0286\3\2\2\2\u0288I\3\2\2"\
      "\2\u0289\u028a\5\u0178\u00bd\2\u028a\u028b\7K\2\2\u028b\u028c\5\u0178"\
      "\u00bd\2\u028c\u0292\3\2\2\2\u028d\u028e\5\u0178\u00bd\2\u028e\u028f"\
      "\7K\2\2\u028f\u0290\5\u0186\u00c4\2\u0290\u0292\3\2\2\2\u0291\u0289"\
      "\3\2\2\2\u0291\u028d\3\2\2\2\u0292K\3\2\2\2\u0293\u0294\5\u0178\u00bd"\
      "\2\u0294\u0295\7N\2\2\u0295\u0296\5\u0178\u00bd\2\u0296M\3\2\2\2\u0297"\
      "\u0298\7\37\2\2\u0298\u0299\5P)\2\u0299\u029a\7O\2\2\u029aO\3\2\2"\
      "\2\u029b\u02a0\5R*\2\u029c\u029d\7\27\2\2\u029d\u029f\5R*\2\u029e"\
      "\u029c\3\2\2\2\u029f\u02a2\3\2\2\2\u02a0\u029e\3\2\2\2\u02a0\u02a1"\
      "\3\2\2\2\u02a1Q\3\2\2\2\u02a2\u02a0\3\2\2\2\u02a3\u02a4\5\u0174\u00bb"\
      "\2\u02a4S\3\2\2\2\u02a5\u02b4\5^\60\2\u02a6\u02b4\5f\64\2\u02a7\u02b4"\
      "\5n8\2\u02a8\u02b4\5\u0088E\2\u02a9\u02b4\5\u0090I\2\u02aa\u02b4\5"\
      "\u00aaV\2\u02ab\u02b4\5\u00caf\2\u02ac\u02b4\5\u00d0i\2\u02ad\u02b4"\
      "\5\u00d6l\2\u02ae\u02b4\5\u00eav\2\u02af\u02b4\5\u00f0y\2\u02b0\u02b4"\
      "\5\u00f2z\2\u02b1\u02b4\5\u00f6|\2\u02b2\u02b4\5\u00fc\177\2\u02b3"\
      "\u02a5\3\2\2\2\u02b3\u02a6\3\2\2\2\u02b3\u02a7\3\2\2\2\u02b3\u02a8"\
      "\3\2\2\2\u02b3\u02a9\3\2\2\2\u02b3\u02aa\3\2\2\2\u02b3\u02ab\3\2\2"\
      "\2\u02b3\u02ac\3\2\2\2\u02b3\u02ad\3\2\2\2\u02b3\u02ae\3\2\2\2\u02b3"\
      "\u02af\3\2\2\2\u02b3\u02b0\3\2\2\2\u02b3\u02b1\3\2\2\2\u02b3\u02b2"\
      "\3\2\2\2\u02b4U\3\2\2\2\u02b5\u02b7\5T+\2\u02b6\u02b8\5V,\2\u02b7"\
      "\u02b6\3\2\2\2\u02b7\u02b8\3\2\2\2\u02b8W\3\2\2\2\u02b9\u02bb\5Z."\
      "\2\u02ba\u02bc\5X-\2\u02bb\u02ba\3\2\2\2\u02bb\u02bc\3\2\2\2\u02bc"\
      "Y\3\2\2\2\u02bd\u02be\t\2\2\2\u02be[\3\2\2\2\u02bf\u02c1\7\13\2\2"\
      "\u02c0\u02c2\5\6\4\2\u02c1\u02c0\3\2\2\2\u02c1\u02c2\3\2\2\2\u02c2"\
      "\u02c3\3\2\2\2\u02c3\u02c4\7\66\2\2\u02c4]\3\2\2\2\u02c5\u02c7\5\u012c"\
      "\u0097\2\u02c6\u02c5\3\2\2\2\u02c6\u02c7\3\2\2\2\u02c7\u02c8\3\2\2"\
      "\2\u02c8\u02ca\7_\2\2\u02c9\u02cb\5`\61\2\u02ca\u02c9\3\2\2\2\u02ca"\
      "\u02cb\3\2\2\2\u02cb\u02cc\3\2\2\2\u02cc\u02cd\5b\62\2\u02cd_\3\2"\
      "\2\2\u02ce\u02cf\t\3\2\2\u02cfa\3\2\2\2\u02d0\u02d6\5d\63\2\u02d1"\
      "\u02d2\5d\63\2\u02d2\u02d3\7B\2\2\u02d3\u02d4\5b\62\2\u02d4\u02d6"\
      "\3\2\2\2\u02d5\u02d0\3\2\2\2\u02d5\u02d1\3\2\2\2\u02d6c\3\2\2\2\u02d7"\
      "\u02da\5\u0192\u00ca\2\u02d8\u02da\5\u016c\u00b7\2\u02d9\u02d7\3\2"\
      "\2\2\u02d9\u02d8\3\2\2\2\u02dae\3\2\2\2\u02db\u02dd\5\u012c\u0097"\
      "\2\u02dc\u02db\3\2\2\2\u02dc\u02dd\3\2\2\2\u02dd\u02df\3\2\2\2\u02de"\
      "\u02e0\5X-\2\u02df\u02de\3\2\2\2\u02df\u02e0\3\2\2\2\u02e0\u02e1\3"\
      "\2\2\2\u02e1\u02e2\7%\2\2\u02e2\u02e3\5h\65\2\u02e3g\3\2\2\2\u02e4"\
      "\u02e9\5j\66\2\u02e5\u02e6\7\27\2\2\u02e6\u02e8\5j\66\2\u02e7\u02e5"\
      "\3\2\2\2\u02e8\u02eb\3\2\2\2\u02e9\u02e7\3\2\2\2\u02e9\u02ea\3\2\2"\
      "\2\u02eai\3\2\2\2\u02eb\u02e9\3\2\2\2\u02ec\u02ee\5\u010e\u0088\2"\
      "\u02ed\u02ef\5l\67\2\u02ee\u02ed\3\2\2\2\u02ee\u02ef\3\2\2\2\u02ef"\
      "k\3\2\2\2\u02f0\u02f1\7\r\2\2\u02f1\u02f2\5\u0134\u009b\2\u02f2m\3"\
      "\2\2\2\u02f3\u02f4\5p9\2\u02f4\u02f5\5h\65\2\u02f5\u030e\3\2\2\2\u02f6"\
      "\u02f7\5p9\2\u02f7\u02f8\5r:\2\u02f8\u02f9\5\u0176\u00bc\2\u02f9\u02fa"\
      "\5\\/\2\u02fa\u030e\3\2\2\2\u02fb\u02fc\5p9\2\u02fc\u02fd\5r:\2\u02fd"\
      "\u02fe\5\u0176\u00bc\2\u02fe\u02ff\5t;\2\u02ff\u030e\3\2\2\2\u0300"\
      "\u0301\5p9\2\u0301\u0302\5r:\2\u0302\u0303\5\u0176\u00bc\2\u0303\u0304"\
      "\5|?\2\u0304\u030e\3\2\2\2\u0305\u0306\5p9\2\u0306\u0307\5r:\2\u0307"\
      "\u0309\5\u0176\u00bc\2\u0308\u030a\5l\67\2\u0309\u0308\3\2\2\2\u0309"\
      "\u030a\3\2\2\2\u030a\u030b\3\2\2\2\u030b\u030c\5\u0082B\2\u030c\u030e"\
      "\3\2\2\2\u030d\u02f3\3\2\2\2\u030d\u02f6\3\2\2\2\u030d\u02fb\3\2\2"\
      "\2\u030d\u0300\3\2\2\2\u030d\u0305\3\2\2\2\u030eo\3\2\2\2\u030f\u0311"\
      "\5\u012c\u0097\2\u0310\u030f\3\2\2\2\u0310\u0311\3\2\2\2\u0311\u0313"\
      "\3\2\2\2\u0312\u0314\5X-\2\u0313\u0312\3\2\2\2\u0313\u0314\3\2\2\2"\
      "\u0314\u0315\3\2\2\2\u0315\u0316\7\33\2\2\u0316q\3\2\2\2\u0317\u0318"\
      "\5\u0192\u00ca\2\u0318s\3\2\2\2\u0319\u031a\7\13\2\2\u031a\u031c\5"\
      "v<\2\u031b\u031d\5x=\2\u031c\u031b\3\2\2\2\u031c\u031d\3\2\2\2\u031d"\
      "\u031e\3\2\2\2\u031e\u031f\7\66\2\2\u031f\u0326\3\2\2\2\u0320\u0321"\
      "\7\13\2\2\u0321\u0322\5x=\2\u0322\u0323\5v<\2\u0323\u0324\7\66\2\2"\
      "\u0324\u0326\3\2\2\2\u0325\u0319\3\2\2\2\u0325\u0320\3\2\2\2\u0326"\
      "u\3\2\2\2\u0327\u0329\5\u012c\u0097\2\u0328\u0327\3\2\2\2\u0328\u0329"\
      "\3\2\2\2\u0329\u032a\3\2\2\2\u032a\u032b\7\21\2\2\u032b\u032c\5\\"\
      "/\2\u032cw\3\2\2\2\u032d\u032f\5\u012c\u0097\2\u032e\u032d\3\2\2\2"\
      "\u032e\u032f\3\2\2\2\u032f\u0330\3\2\2\2\u0330\u0332\7\b\2\2\u0331"\
      "\u0333\5z>\2\u0332\u0331\3\2\2\2\u0332\u0333\3\2\2\2\u0333\u0334\3"\
      "\2\2\2\u0334\u0335\5\\/\2\u0335y\3\2\2\2\u0336\u0337\5\u0192\u00ca"\
      "\2\u0337{\3\2\2\2\u0338\u0339\7\13\2\2\u0339\u033b\5~@\2\u033a\u033c"\
      "\5\u0080A\2\u033b\u033a\3\2\2\2\u033b\u033c\3\2\2\2\u033c\u033d\3"\
      "\2\2\2\u033d\u033e\7\66\2\2\u033e\u0345\3\2\2\2\u033f\u0340\7\13\2"\
      "\2\u0340\u0341\5\u0080A\2\u0341\u0342\5~@\2\u0342\u0343\7\66\2\2\u0343"\
      "\u0345\3\2\2\2\u0344\u0338\3\2\2\2\u0344\u033f\3\2\2\2\u0345}\3\2"\
      "\2\2\u0346\u0348\5\u012c\u0097\2\u0347\u0346\3\2\2\2\u0347\u0348\3"\
      "\2\2\2\u0348\u0349\3\2\2\2\u0349\u034a\7\21\2\2\u034a\177\3\2\2\2"\
      "\u034b\u034d\5\u012c\u0097\2\u034c\u034b\3\2\2\2\u034c\u034d\3\2\2"\
      "\2\u034d\u034e\3\2\2\2\u034e\u034f\7\b\2\2\u034f\u0081\3\2\2\2\u0350"\
      "\u0351\7\13\2\2\u0351\u0353\5\u0084C\2\u0352\u0354\5\u0086D\2\u0353"\
      "\u0352\3\2\2\2\u0353\u0354\3\2\2\2\u0354\u0355\3\2\2\2\u0355\u0356"\
      "\7\66\2\2\u0356\u035d\3\2\2\2\u0357\u0358\7\13\2\2\u0358\u0359\5\u0086"\
      "D\2\u0359\u035a\5\u0084C\2\u035a\u035b\7\66\2\2\u035b\u035d\3\2\2"\
      "\2\u035c\u0350\3\2\2\2\u035c\u0357\3\2\2\2\u035d\u0083\3\2\2\2\u035e"\
      "\u0360\5\u012c\u0097\2\u035f\u035e\3\2\2\2\u035f\u0360\3\2\2\2\u0360"\
      "\u0361\3\2\2\2\u0361\u0363\7\n\2\2\u0362\u0364\5z>\2\u0363\u0362\3"\
      "\2\2\2\u0363\u0364\3\2\2\2\u0364\u0365\3\2\2\2\u0365\u0366\5\\/\2"\
      "\u0366\u0085\3\2\2\2\u0367\u0369\5\u012c\u0097\2\u0368\u0367\3\2\2"\
      "\2\u0368\u0369\3\2\2\2\u0369\u036a\3\2\2\2\u036a\u036c\7Q\2\2\u036b"\
      "\u036d\5z>\2\u036c\u036b\3\2\2\2\u036c\u036d\3\2\2\2\u036d\u036e\3"\
      "\2\2\2\u036e\u036f\5\\/\2\u036f\u0087\3\2\2\2\u0370\u0371\5\u008a"\
      "F\2\u0371\u0372\5\u008eH\2\u0372\u0089\3\2\2\2\u0373\u0374\7^\2\2"\
      "\u0374\u0375\5\u008cG\2\u0375\u008b\3\2\2\2\u0376\u0377\5\u0192\u00ca"\
      "\2\u0377\u008d\3\2\2\2\u0378\u0379\7\r\2\2\u0379\u037a\5\u0174\u00bb"\
      "\2\u037a\u008f\3\2\2\2\u037b\u037c\5\u0092J\2\u037c\u037e\5\u0094"\
      "K\2\u037d\u037f\5> \2\u037e\u037d\3\2\2\2\u037e\u037f\3\2\2\2\u037f"\
      "\u0380\3\2\2\2\u0380\u0381\5\u0096L\2\u0381\u0382\5\u009aN\2\u0382"\
      "\u0091\3\2\2\2\u0383\u0385\5\u012c\u0097\2\u0384\u0383\3\2\2\2\u0384"\
      "\u0385\3\2\2\2\u0385\u0387\3\2\2\2\u0386\u0388\5X-\2\u0387\u0386\3"\
      "\2\2\2\u0387\u0388\3\2\2\2\u0388\u0389\3\2\2\2\u0389\u038a\7\4\2\2"\
      "\u038a\u0093\3\2\2\2\u038b\u038e\5\u0192\u00ca\2\u038c\u038e\5\u016c"\
      "\u00b7\2\u038d\u038b\3\2\2\2\u038d\u038c\3\2\2\2\u038e\u0095\3\2\2"\
      "\2\u038f\u0391\5\u009cO\2\u0390\u0392\5\u0098M\2\u0391\u0390\3\2\2"\
      "\2\u0391\u0392\3\2\2\2\u0392\u0097\3\2\2\2\u0393\u0395\7C\2\2\u0394"\
      "\u0396\5\u012c\u0097\2\u0395\u0394\3\2\2\2\u0395\u0396\3\2\2\2\u0396"\
      "\u0397\3\2\2\2\u0397\u0398\5\u0174\u00bb\2\u0398\u0099\3\2\2\2\u0399"\
      "\u039a\5\\/\2\u039a\u009b\3\2\2\2\u039b\u039d\5\u009eP\2\u039c\u039e"\
      "\5\u009cO\2\u039d\u039c\3\2\2\2\u039d\u039e\3\2\2\2\u039e\u009d\3"\
      "\2\2\2\u039f\u03a0\7\25\2\2\u03a0\u03a9\7Z\2\2\u03a1\u03a2\7\25\2"\
      "\2\u03a2\u03a4\5\u00a0Q\2\u03a3\u03a5\7E\2\2\u03a4\u03a3\3\2\2\2\u03a4"\
      "\u03a5\3\2\2\2\u03a5\u03a6\3\2\2\2\u03a6\u03a7\7Z\2\2\u03a7\u03a9"\
      "\3\2\2\2\u03a8\u039f\3\2\2\2\u03a8\u03a1\3\2\2\2\u03a9\u009f\3\2\2"\
      "\2\u03aa\u03b0\5\u00a2R\2\u03ab\u03ac\5\u00a2R\2\u03ac\u03ad\7\27"\
      "\2\2\u03ad\u03ae\5\u00a0Q\2\u03ae\u03b0\3\2\2\2\u03af\u03aa\3\2\2"\
      "\2\u03af\u03ab\3\2\2\2\u03b0\u00a1\3\2\2\2\u03b1\u03b3\7<\2\2\u03b2"\
      "\u03b1\3\2\2\2\u03b2\u03b3\3\2\2\2\u03b3\u03b5\3\2\2\2\u03b4\u03b6"\
      "\7%\2\2\u03b5\u03b4\3\2\2\2\u03b5\u03b6\3\2\2\2\u03b6\u03b8\3\2\2"\
      "\2\u03b7\u03b9\7$\2\2\u03b8\u03b7\3\2\2\2\u03b8\u03b9\3\2\2\2\u03b9"\
      "\u03ba\3\2\2\2\u03ba\u03bc\5\u00a4S\2\u03bb\u03bd\5\u00a6T\2\u03bc"\
      "\u03bb\3\2\2\2\u03bc\u03bd\3\2\2\2\u03bd\u03be\3\2\2\2\u03be\u03c0"\
      "\5\u0176\u00bc\2\u03bf\u03c1\5\u00a8U\2\u03c0\u03bf\3\2\2\2\u03c0"\
      "\u03c1\3\2\2\2\u03c1\u03d6\3\2\2\2\u03c2\u03c4\7<\2\2\u03c3\u03c2"\
      "\3\2\2\2\u03c3\u03c4\3\2\2\2\u03c4\u03c5\3\2\2\2\u03c5\u03c7\7\33"\
      "\2\2\u03c6\u03c8\7$\2\2\u03c7\u03c6\3\2\2\2\u03c7\u03c8\3\2\2\2\u03c8"\
      "\u03c9\3\2\2\2\u03c9\u03cb\5\u00a4S\2\u03ca\u03cc\5\u00a6T\2\u03cb"\
      "\u03ca\3\2\2\2\u03cb\u03cc\3\2\2\2\u03cc\u03cd\3\2\2\2\u03cd\u03cf"\
      "\5\u0176\u00bc\2\u03ce\u03d0\5\u00a8U\2\u03cf\u03ce\3\2\2\2\u03cf"\
      "\u03d0\3\2\2\2\u03d0\u03d6\3\2\2\2\u03d1\u03d3\5\u012c\u0097\2\u03d2"\
      "\u03d1\3\2\2\2\u03d2\u03d3\3\2\2\2\u03d3\u03d4\3\2\2\2\u03d4\u03d6"\
      "\5\u0174\u00bb\2\u03d5\u03b2\3\2\2\2\u03d5\u03c3\3\2\2\2\u03d5\u03d2"\
      "\3\2\2\2\u03d6\u00a3\3\2\2\2\u03d7\u03da\5\u0192\u00ca\2\u03d8\u03da"\
      "\7P\2\2\u03d9\u03d7\3\2\2\2\u03d9\u03d8\3\2\2\2\u03da\u00a5\3\2\2"\
      "\2\u03db\u03de\5\u0192\u00ca\2\u03dc\u03de\7P\2\2\u03dd\u03db\3\2"\
      "\2\2\u03dd\u03dc\3\2\2\2\u03de\u00a7\3\2\2\2\u03df\u03e0\7\r\2\2\u03e0"\
      "\u03e1\5\u0134\u009b\2\u03e1\u00a9\3\2\2\2\u03e2\u03e4\5\u012c\u0097"\
      "\2\u03e3\u03e2\3\2\2\2\u03e3\u03e4\3\2\2\2\u03e4\u03e5\3\2\2\2\u03e5"\
      "\u03eb\5\u00acW\2\u03e6\u03e8\5\u012c\u0097\2\u03e7\u03e6\3\2\2\2"\
      "\u03e7\u03e8\3\2\2\2\u03e8\u03e9\3\2\2\2\u03e9\u03eb\5\u00bc_\2\u03ea"\
      "\u03e3\3\2\2\2\u03ea\u03e7\3\2\2\2\u03eb\u00ab\3\2\2\2\u03ec\u03ee"\
      "\5\u00b8]\2\u03ed\u03ef\5> \2\u03ee\u03ed\3\2\2\2\u03ee\u03ef\3\2"\
      "\2\2\u03ef\u03f0\3\2\2\2\u03f0\u03f2\7\13\2\2\u03f1\u03f3\5\u00ae"\
      "X\2\u03f2\u03f1\3\2\2\2\u03f2\u03f3\3\2\2\2\u03f3\u03f4\3\2\2\2\u03f4"\
      "\u03f5\7\66\2\2\u03f5\u00ad\3\2\2\2\u03f6\u03f8\5\u00b0Y\2\u03f7\u03f9"\
      "\5\u00aeX\2\u03f8\u03f7\3\2\2\2\u03f8\u03f9\3\2\2\2\u03f9\u00af\3"\
      "\2\2\2\u03fa\u03fd\5T+\2\u03fb\u03fd\5\u00b2Z\2\u03fc\u03fa\3\2\2"\
      "\2\u03fc\u03fb\3\2\2\2\u03fd\u00b1\3\2\2\2\u03fe\u0400\5\u012c\u0097"\
      "\2\u03ff\u03fe\3\2\2\2\u03ff\u0400\3\2\2\2\u0400\u0401\3\2\2\2\u0401"\
      "\u0402\7D\2\2\u0402\u0403\5\u00b4[\2\u0403\u00b3\3\2\2\2\u0404\u040a"\
      "\5\u00b6\\\2\u0405\u0406\5\u00b6\\\2\u0406\u0407\7\27\2\2\u0407\u0408"\
      "\5\u00b4[\2\u0408\u040a\3\2\2\2\u0409\u0404\3\2\2\2\u0409\u0405\3"\
      "\2\2\2\u040a\u00b5\3\2\2\2\u040b\u040d\5\u00ba^\2\u040c\u040e\5\u017c"\
      "\u00bf\2\u040d\u040c\3\2\2\2\u040d\u040e\3\2\2\2\u040e\u00b7\3\2\2"\
      "\2\u040f\u0410\5\u0192\u00ca\2\u0410\u00b9\3\2\2\2\u0411\u0412\5\u0192"\
      "\u00ca\2\u0412\u00bb\3\2\2\2\u0413\u0415\5\u00b8]\2\u0414\u0416\5"\
      "> \2\u0415\u0414\3\2\2\2\u0415\u0416\3\2\2\2\u0416\u0417\3\2\2\2\u0417"\
      "\u0418\7K\2\2\u0418\u0419\5\u0178\u00bd\2\u0419\u041b\7\13\2\2\u041a"\
      "\u041c\5\u00be`\2\u041b\u041a\3\2\2\2\u041b\u041c\3\2\2\2\u041c\u041d"\
      "\3\2\2\2\u041d\u041e\7\66\2\2\u041e\u00bd\3\2\2\2\u041f\u0421\5\u00c0"\
      "a\2\u0420\u0422\5\u00be`\2\u0421\u0420\3\2\2\2\u0421\u0422\3\2\2\2"\
      "\u0422\u00bf\3\2\2\2\u0423\u0426\5T+\2\u0424\u0426\5\u00c2b\2\u0425"\
      "\u0423\3\2\2\2\u0425\u0424\3\2\2\2\u0426\u00c1\3\2\2\2\u0427\u0429"\
      "\5\u012c\u0097\2\u0428\u0427\3\2\2\2\u0428\u0429\3\2\2\2\u0429\u042a"\
      "\3\2\2\2\u042a\u042b\7D\2\2\u042b\u042c\5\u00c4c\2\u042c\u00c3\3\2"\
      "\2\2\u042d\u0433\5\u00c6d\2\u042e\u042f\5\u00c6d\2\u042f\u0430\7\27"\
      "\2\2\u0430\u0431\5\u00c4c\2\u0431\u0433\3\2\2\2\u0432\u042d\3\2\2"\
      "\2\u0432\u042e\3\2\2\2\u0433\u00c5\3\2\2\2\u0434\u0436\5\u00ba^\2"\
      "\u0435\u0437\5\u00c8e\2\u0436\u0435\3\2\2\2\u0436\u0437\3\2\2\2\u0437"\
      "\u00c7\3\2\2\2\u0438\u0439\7\r\2\2\u0439\u043a\5\u019a\u00ce\2\u043a"\
      "\u00c9\3\2\2\2\u043b\u043d\5\u012c\u0097\2\u043c\u043b\3\2\2\2\u043c"\
      "\u043d\3\2\2\2\u043d\u043e\3\2\2\2\u043e\u043f\7)\2\2\u043f\u0441"\
      "\5\u00ccg\2\u0440\u0442\5> \2\u0441\u0440\3\2\2\2\u0441\u0442\3\2"\
      "\2\2\u0442\u0444\3\2\2\2\u0443\u0445\5\u018e\u00c8\2\u0444\u0443\3"\
      "\2\2\2\u0444\u0445\3\2\2\2\u0445\u0446\3\2\2\2\u0446\u0447\5\u00ce"\
      "h\2\u0447\u00cb\3\2\2\2\u0448\u0449\5\u0192\u00ca\2\u0449\u00cd\3"\
      "\2\2\2\u044a\u044c\7\13\2\2\u044b\u044d\5V,\2\u044c\u044b\3\2\2\2"\
      "\u044c\u044d\3\2\2\2\u044d\u044e\3\2\2\2\u044e\u044f\7\66\2\2\u044f"\
      "\u00cf\3\2\2\2\u0450\u0452\5\u012c\u0097\2\u0451\u0450\3\2\2\2\u0451"\
      "\u0452\3\2\2\2\u0452\u0453\3\2\2\2\u0453\u0454\7\63\2\2\u0454\u0456"\
      "\5\u00d2j\2\u0455\u0457\5> \2\u0456\u0455\3\2\2\2\u0456\u0457\3\2"\
      "\2\2\u0457\u0459\3\2\2\2\u0458\u045a\5\u018e\u00c8\2\u0459\u0458\3"\
      "\2\2\2\u0459\u045a\3\2\2\2\u045a\u045b\3\2\2\2\u045b\u045c\5\u00d4"\
      "k\2\u045c\u00d1\3\2\2\2\u045d\u045e\5\u0192\u00ca\2\u045e\u00d3\3"\
      "\2\2\2\u045f\u0461\7\13\2\2\u0460\u0462\5V,\2\u0461\u0460\3\2\2\2"\
      "\u0461\u0462\3\2\2\2\u0462\u0463\3\2\2\2\u0463\u0464\7\66\2\2\u0464"\
      "\u00d5\3\2\2\2\u0465\u0467\5\u012c\u0097\2\u0466\u0465\3\2\2\2\u0466"\
      "\u0467\3\2\2\2\u0467\u0468\3\2\2\2\u0468\u0469\7-\2\2\u0469\u046b"\
      "\5\u00d8m\2\u046a\u046c\5\u018e\u00c8\2\u046b\u046a\3\2\2\2\u046b"\
      "\u046c\3\2\2\2\u046c\u046d\3\2\2\2\u046d\u046e\5\u00dan\2\u046e\u00d7"\
      "\3\2\2\2\u046f\u0470\5\u0192\u00ca\2\u0470\u00d9\3\2\2\2\u0471\u0473"\
      "\7\13\2\2\u0472\u0474\5\u00dep\2\u0473\u0472\3\2\2\2\u0473\u0474\3"\
      "\2\2\2\u0474\u0475\3\2\2\2\u0475\u0476\7\66\2\2\u0476\u00db\3\2\2"\
      "\2\u0477\u047d\5\u00e0q\2\u0478\u047d\5\u00e2r\2\u0479\u047d\5\u00e4"\
      "s\2\u047a\u047d\5\u00e6t\2\u047b\u047d\5\u00e8u\2\u047c\u0477\3\2"\
      "\2\2\u047c\u0478\3\2\2\2\u047c\u0479\3\2\2\2\u047c\u047a\3\2\2\2\u047c"\
      "\u047b\3\2\2\2\u047d\u00dd\3\2\2\2\u047e\u0480\5\u00dco\2\u047f\u0481"\
      "\5\u00dep\2\u0480\u047f\3\2\2\2\u0480\u0481\3\2\2\2\u0481\u00df\3"\
      "\2\2\2\u0482\u0483\5p9\2\u0483\u0484\5r:\2\u0484\u0485\5\u0176\u00bc"\
      "\2\u0485\u0486\5|?\2\u0486\u00e1\3\2\2\2\u0487\u0488\5\u0092J\2\u0488"\
      "\u048a\5\u0094K\2\u0489\u048b\5> \2\u048a\u0489\3\2\2\2\u048a\u048b"\
      "\3\2\2\2\u048b\u048c\3\2\2\2\u048c\u048d\5\u0096L\2\u048d\u00e3\3"\
      "\2\2\2\u048e\u0490\5\u00ecw\2\u048f\u0491\5> \2\u0490\u048f\3\2\2"\
      "\2\u0490\u0491\3\2\2\2\u0491\u0492\3\2\2\2\u0492\u0493\5\u009eP\2"\
      "\u0493\u00e5\3\2\2\2\u0494\u0495\5\u00f8}\2\u0495\u0496\5\u00fa~\2"\
      "\u0496\u0497\5|?\2\u0497\u00e7\3\2\2\2\u0498\u049a\5\u008aF\2\u0499"\
      "\u049b\5\u018e\u00c8\2\u049a\u0499\3\2\2\2\u049a\u049b\3\2\2\2\u049b"\
      "\u049d\3\2\2\2\u049c\u049e\5\u008eH\2\u049d\u049c\3\2\2\2\u049d\u049e"\
      "\3\2\2\2\u049e\u00e9\3\2\2\2\u049f\u04a1\5\u00ecw\2\u04a0\u04a2\5"\
      "> \2\u04a1\u04a0\3\2\2\2\u04a1\u04a2\3\2\2\2\u04a2\u04a3\3\2\2\2\u04a3"\
      "\u04a4\5\u009eP\2\u04a4\u04a5\5\u00eex\2\u04a5\u00eb\3\2\2\2\u04a6"\
      "\u04a8\5\u012c\u0097\2\u04a7\u04a6\3\2\2\2\u04a7\u04a8\3\2\2\2\u04a8"\
      "\u04aa\3\2\2\2\u04a9\u04ab\7G\2\2\u04aa\u04a9\3\2\2\2\u04aa\u04ab"\
      "\3\2\2\2\u04ab\u04ac\3\2\2\2\u04ac\u04ad\7\34\2\2\u04ad\u00ed\3\2"\
      "\2\2\u04ae\u04af\5\\/\2\u04af\u00ef\3\2\2\2\u04b0\u04b2\5\u012c\u0097"\
      "\2\u04b1\u04b0\3\2\2\2\u04b1\u04b2\3\2\2\2\u04b2\u04b3\3\2\2\2\u04b3"\
      "\u04b4\7.\2\2\u04b4\u04b5\5\\/\2\u04b5\u00f1\3\2\2\2\u04b6\u04b7\7"\
      "\36\2\2\u04b7\u04b9\5\u0178\u00bd\2\u04b8\u04ba\5\u018e\u00c8\2\u04b9"\
      "\u04b8\3\2\2\2\u04b9\u04ba\3\2\2\2\u04ba\u04bb\3\2\2\2\u04bb\u04bc"\
      "\5\u00f4{\2\u04bc\u00f3\3\2\2\2\u04bd\u04bf\7\13\2\2\u04be\u04c0\5"\
      "V,\2\u04bf\u04be\3\2\2\2\u04bf\u04c0\3\2\2\2\u04c0\u04c1\3\2\2\2\u04c1"\
      "\u04c2\7\66\2\2\u04c2\u00f5\3\2\2\2\u04c3\u04c4\5\u00f8}\2\u04c4\u04c5"\
      "\5\u00fa~\2\u04c5\u04c6\5\\/\2\u04c6\u04d0\3\2\2\2\u04c7\u04c8\5\u00f8"\
      "}\2\u04c8\u04c9\5\u00fa~\2\u04c9\u04ca\5t;\2\u04ca\u04d0\3\2\2\2\u04cb"\
      "\u04cc\5\u00f8}\2\u04cc\u04cd\5\u00fa~\2\u04cd\u04ce\5|?\2\u04ce\u04d0"\
      "\3\2\2\2\u04cf\u04c3\3\2\2\2\u04cf\u04c7\3\2\2\2\u04cf\u04cb\3\2\2"\
      "\2\u04d0\u00f7\3\2\2\2\u04d1\u04d3\5\u012c\u0097\2\u04d2\u04d1\3\2"\
      "\2\2\u04d2\u04d3\3\2\2\2\u04d3\u04d4\3\2\2\2\u04d4\u04d5\7+\2\2\u04d5"\
      "\u04d6\5\u009eP\2\u04d6\u00f9\3\2\2\2\u04d7\u04d9\7C\2\2\u04d8\u04da"\
      "\5\u012c\u0097\2\u04d9\u04d8\3\2\2\2\u04d9\u04da\3\2\2\2\u04da\u04db"\
      "\3\2\2\2\u04db\u04dc\5\u0174\u00bb\2\u04dc\u00fb\3\2\2\2\u04dd\u04e1"\
      "\5\u00fe\u0080\2\u04de\u04e1\5\u0100\u0081\2\u04df\u04e1\5\u0102\u0082"\
      "\2\u04e0\u04dd\3\2\2\2\u04e0\u04de\3\2\2\2\u04e0\u04df\3\2\2\2\u04e1"\
      "\u00fd\3\2\2\2\u04e2\u04e3\7\7\2\2\u04e3\u04e4\7]\2\2\u04e4\u04e5"\
      "\7\7\2\2\u04e5\u04e6\7\13\2\2\u04e6\u04e7\7\66\2\2\u04e7\u00ff\3\2"\
      "\2\2\u04e8\u04e9\7\7\2\2\u04e9\u04ea\7\20\2\2\u04ea\u04eb\7\7\2\2"\
      "\u04eb\u04ec\7\13\2\2\u04ec\u04ed\7\66\2\2\u04ed\u0101\3\2\2\2\u04ee"\
      "\u04ef\7\7\2\2\u04ef\u04f0\7(\2\2\u04f0\u04f1\7\7\2\2\u04f1\u04f2"\
      "\7\13\2\2\u04f2\u04f3\5\u0104\u0083\2\u04f3\u04f4\7\66\2\2\u04f4\u0103"\
      "\3\2\2\2\u04f5\u04f7\5\u0106\u0084\2\u04f6\u04f5\3\2\2\2\u04f6\u04f7"\
      "\3\2\2\2\u04f7\u04f9\3\2\2\2\u04f8\u04fa\5\u010a\u0086\2\u04f9\u04f8"\
      "\3\2\2\2\u04f9\u04fa\3\2\2\2\u04fa\u0105\3\2\2\2\u04fb\u04fc\7\t\2"\
      "\2\u04fc\u04fd\5\u0108\u0085\2\u04fd\u0107\3\2\2\2\u04fe\u04ff\5\u019c"\
      "\u00cf\2\u04ff\u0109\3\2\2\2\u0500\u0501\7\6\2\2\u0501\u0502\5\u010c"\
      "\u0087\2\u0502\u010b\3\2\2\2\u0503\u0504\t\4\2\2\u0504\u010d\3\2\2"\
      "\2\u0505\u0506\b\u0088\1\2\u0506\u0508\5\u0110\u0089\2\u0507\u0509"\
      "\5\u0176\u00bc\2\u0508\u0507\3\2\2\2\u0508\u0509\3\2\2\2\u0509\u0518"\
      "\3\2\2\2\u050a\u050c\5\u0112\u008a\2\u050b\u050d\5\u0176\u00bc\2\u050c"\
      "\u050b\3\2\2\2\u050c\u050d\3\2\2\2\u050d\u0518\3\2\2\2\u050e\u0518"\
      "\5\u0114\u008b\2\u050f\u0511\5\u0116\u008c\2\u0510\u0512\5\u0176\u00bc"\
      "\2\u0511\u0510\3\2\2\2\u0511\u0512\3\2\2\2\u0512\u0518\3\2\2\2\u0513"\
      "\u0518\5\u011c\u008f\2\u0514\u0515\7=\2\2\u0515\u0518\5\u0174\u00bb"\
      "\2\u0516\u0518\5\u0124\u0093\2\u0517\u0505\3\2\2\2\u0517\u050a\3\2"\
      "\2\2\u0517\u050e\3\2\2\2\u0517\u050f\3\2\2\2\u0517\u0513\3\2\2\2\u0517"\
      "\u0514\3\2\2\2\u0517\u0516\3\2\2\2\u0518\u051e\3\2\2\2\u0519\u051a"\
      "\f\4\2\2\u051a\u051b\7/\2\2\u051b\u051d\5\u0174\u00bb\2\u051c\u0519"\
      "\3\2\2\2\u051d\u0520\3\2\2\2\u051e\u051c\3\2\2\2\u051e\u051f\3\2\2"\
      "\2\u051f\u010f\3\2\2\2\u0520\u051e\3\2\2\2\u0521\u0522\7P\2\2\u0522"\
      "\u0111\3\2\2\2\u0523\u0524\5\u0192\u00ca\2\u0524\u0113\3\2\2\2\u0525"\
      "\u0526\7\33\2\2\u0526\u052a\5\u010e\u0088\2\u0527\u0528\7%\2\2\u0528"\
      "\u052a\5\u010e\u0088\2\u0529\u0525\3\2\2\2\u0529\u0527\3\2\2\2\u052a"\
      "\u0115\3\2\2\2\u052b\u052d\7\25\2\2\u052c\u052e\5\u0118\u008d\2\u052d"\
      "\u052c\3\2\2\2\u052d\u052e\3\2\2\2\u052e\u052f\3\2\2\2\u052f\u0530"\
      "\7Z\2\2\u0530\u0117\3\2\2\2\u0531\u0536\5\u011a\u008e\2\u0532\u0533"\
      "\7\27\2\2\u0533\u0535\5\u011a\u008e\2\u0534\u0532\3\2\2\2\u0535\u0538"\
      "\3\2\2\2\u0536\u0534\3\2\2\2\u0536\u0537\3\2\2\2\u0537\u0119\3\2\2"\
      "\2\u0538\u0536\3\2\2\2\u0539\u053a\5\u010e\u0088\2\u053a\u011b\3\2"\
      "\2\2\u053b\u053d\5\u0178\u00bd\2\u053c\u053b\3\2\2\2\u053c\u053d\3"\
      "\2\2\2\u053d\u053e\3\2\2\2\u053e\u053f\7B\2\2\u053f\u0541\5\u00ba"\
      "^\2\u0540\u0542\5\u0116\u008c\2\u0541\u0540\3\2\2\2\u0541\u0542\3"\
      "\2\2\2\u0542\u011d\3\2\2\2\u0543\u0546\5\u0120\u0091\2\u0544\u0546"\
      "\5\u0122\u0092\2\u0545\u0543\3\2\2\2\u0545\u0544\3\2\2\2\u0546\u011f"\
      "\3\2\2\2\u0547\u0548\7=\2\2\u0548\u0549\5\u0174\u00bb\2\u0549\u0121"\
      "\3\2\2\2\u054a\u054b\5\u010e\u0088\2\u054b\u054c\7/\2\2\u054c\u054d"\
      "\5\u0174\u00bb\2\u054d\u0123\3\2\2\2\u054e\u054f\5\u0134\u009b\2\u054f"\
      "\u0125\3\2\2\2\u0550\u0551\7\"\2\2\u0551\u0553\5\u0128\u0095\2\u0552"\
      "\u0554\5\u012a\u0096\2\u0553\u0552\3\2\2\2\u0553\u0554\3\2\2\2\u0554"\
      "\u0127\3\2\2\2\u0555\u0556\5\u0192\u00ca\2\u0556\u0129\3\2\2\2\u0557"\
      "\u0559\7\25\2\2\u0558\u055a\5\u012e\u0098\2\u0559\u0558\3\2\2\2\u0559"\
      "\u055a\3\2\2\2\u055a\u055b\3\2\2\2\u055b\u055c\7Z\2\2\u055c\u012b"\
      "\3\2\2\2\u055d\u055f\5\u0126\u0094\2\u055e\u055d\3\2\2\2\u055f\u0560"\
      "\3\2\2\2\u0560\u055e\3\2\2\2\u0560\u0561\3\2\2\2\u0561\u012d\3\2\2"\
      "\2\u0562\u0564\5\u0130\u0099\2\u0563\u0562\3\2\2\2\u0564\u0565\3\2"\
      "\2\2\u0565\u0563\3\2\2\2\u0565\u0566\3\2\2\2\u0566\u012f\3\2\2\2\u0567"\
      "\u0569\7\25\2\2\u0568\u056a\5\u012e\u0098\2\u0569\u0568\3\2\2\2\u0569"\
      "\u056a\3\2\2\2\u056a\u056b\3\2\2\2\u056b\u057c\7Z\2\2\u056c\u056e"\
      "\7L\2\2\u056d\u056f\5\u012e\u0098\2\u056e\u056d\3\2\2\2\u056e\u056f"\
      "\3\2\2\2\u056f\u0570\3\2\2\2\u0570\u057c\7 \2\2\u0571\u0573\7\13\2"\
      "\2\u0572\u0574\5\u012e\u0098\2\u0573\u0572\3\2\2\2\u0573\u0574\3\2"\
      "\2\2\u0574\u0575\3\2\2\2\u0575\u057c\7\66\2\2\u0576\u057c\5\u0192"\
      "\u00ca\2\u0577\u057c\5\u0134\u009b\2\u0578\u057c\5\u0196\u00cc\2\u0579"\
      "\u057c\5\u019a\u00ce\2\u057a\u057c\5\u016c\u00b7\2\u057b\u0567\3\2"\
      "\2\2\u057b\u056c\3\2\2\2\u057b\u0571\3\2\2\2\u057b\u0576\3\2\2\2\u057b"\
      "\u0577\3\2\2\2\u057b\u0578\3\2\2\2\u057b\u0579\3\2\2\2\u057b\u057a"\
      "\3\2\2\2\u057c\u0131\3\2\2\2\u057d\u0582\5\u0134\u009b\2\u057e\u057f"\
      "\7\27\2\2\u057f\u0581\5\u0134\u009b\2\u0580\u057e\3\2\2\2\u0581\u0584"\
      "\3\2\2\2\u0582\u0580\3\2\2\2\u0582\u0583\3\2\2\2\u0583\u0133\3\2\2"\
      "\2\u0584\u0582\3\2\2\2\u0585\u0586\b\u009b\1\2\u0586\u0587\5\u0170"\
      "\u00b9\2\u0587\u0588\5\u0134\u009b\23\u0588\u058c\3\2\2\2\u0589\u058c"\
      "\5\u0136\u009c\2\u058a\u058c\5\u0140\u00a1\2\u058b\u0585\3\2\2\2\u058b"\
      "\u0589\3\2\2\2\u058b\u058a\3\2\2\2\u058c\u05bf\3\2\2\2\u058d\u058e"\
      "\f\20\2\2\u058e\u058f\5\u016e\u00b8\2\u058f\u0590\5\u0134\u009b\21"\
      "\u0590\u05be\3\2\2\2\u0591\u0592\f\17\2\2\u0592\u0593\5\u0138\u009d"\
      "\2\u0593\u0594\5\u0134\u009b\20\u0594\u05be\3\2\2\2\u0595\u0596\f"\
      "\16\2\2\u0596\u0597\5\u013a\u009e\2\u0597\u0598\5\u0134\u009b\17\u0598"\
      "\u05be\3\2\2\2\u0599\u059a\f\r\2\2\u059a\u05be\5\u013c\u009f\2\u059b"\
      "\u059c\f\f\2\2\u059c\u05be\5\u0172\u00ba\2\u059d\u059e\f\13\2\2\u059e"\
      "\u05a0\5\u0164\u00b3\2\u059f\u05a1\5\u013e\u00a0\2\u05a0\u059f\3\2"\
      "\2\2\u05a0\u05a1\3\2\2\2\u05a1\u05be\3\2\2\2\u05a2\u05a3\f\n\2\2\u05a3"\
      "\u05a4\7B\2\2\u05a4\u05be\7\34\2\2\u05a5\u05a6\f\t\2\2\u05a6\u05a7"\
      "\7B\2\2\u05a7\u05be\7d\2\2\u05a8\u05a9\f\b\2\2\u05a9\u05aa\7B\2\2"\
      "\u05aa\u05ac\5\u0192\u00ca\2\u05ab\u05ad\5N(\2\u05ac\u05ab\3\2\2\2"\
      "\u05ac\u05ad\3\2\2\2\u05ad\u05be\3\2\2\2\u05ae\u05af\f\7\2\2\u05af"\
      "\u05b0\7B\2\2\u05b0\u05be\7Y\2\2\u05b1\u05b2\f\6\2\2\u05b2\u05b3\7"\
      "B\2\2\u05b3\u05be\7\35\2\2\u05b4\u05b5\f\5\2\2\u05b5\u05b6\7L\2\2"\
      "\u05b6\u05b7\5\u0132\u009a\2\u05b7\u05b8\7 \2\2\u05b8\u05be\3\2\2"\
      "\2\u05b9\u05ba\f\4\2\2\u05ba\u05be\7S\2\2\u05bb\u05bc\f\3\2\2\u05bc"\
      "\u05be\78\2\2\u05bd\u058d\3\2\2\2\u05bd\u0591\3\2\2\2\u05bd\u0595"\
      "\3\2\2\2\u05bd\u0599\3\2\2\2\u05bd\u059b\3\2\2\2\u05bd\u059d\3\2\2"\
      "\2\u05bd\u05a2\3\2\2\2\u05bd\u05a5\3\2\2\2\u05bd\u05a8\3\2\2\2\u05bd"\
      "\u05ae\3\2\2\2\u05bd\u05b1\3\2\2\2\u05bd\u05b4\3\2\2\2\u05bd\u05b9"\
      "\3\2\2\2\u05bd\u05bb\3\2\2\2\u05be\u05c1\3\2\2\2\u05bf\u05bd\3\2\2"\
      "\2\u05bf\u05c0\3\2\2\2\u05c0\u0135\3\2\2\2\u05c1\u05bf\3\2\2\2\u05c2"\
      "\u05c3\7;\2\2\u05c3\u05c4\5\u0192\u00ca\2\u05c4\u0137\3\2\2\2\u05c5"\
      "\u05c6\7\r\2\2\u05c6\u0139\3\2\2\2\u05c7\u05c8\78\2\2\u05c8\u05c9"\
      "\5\u0134\u009b\2\u05c9\u05ca\7K\2\2\u05ca\u013b\3\2\2\2\u05cb\u05cc"\
      "\7=\2\2\u05cc\u05d3\5\u0174\u00bb\2\u05cd\u05cf\7/\2\2\u05ce\u05d0"\
      "\78\2\2\u05cf\u05ce\3\2\2\2\u05cf\u05d0\3\2\2\2\u05d0\u05d1\3\2\2"\
      "\2\u05d1\u05d3\5\u0174\u00bb\2\u05d2\u05cb\3\2\2\2\u05d2\u05cd\3\2"\
      "\2\2\u05d3\u013d\3\2\2\2\u05d4\u05d5\5\u015a\u00ae\2\u05d5\u013f\3"\
      "\2\2\2\u05d6\u05d8\5\u0192\u00ca\2\u05d7\u05d9\5N(\2\u05d8\u05d7\3"\
      "\2\2\2\u05d8\u05d9\3\2\2\2\u05d9\u05e2\3\2\2\2\u05da\u05e2\5\u0142"\
      "\u00a2\2\u05db\u05e2\5\u0150\u00a9\2\u05dc\u05e2\5\u0152\u00aa\2\u05dd"\
      "\u05e2\5\u015a\u00ae\2\u05de\u05e2\5\u0164\u00b3\2\u05df\u05e2\5\u0162"\
      "\u00b2\2\u05e0\u05e2\5\u016a\u00b6\2\u05e1\u05d6\3\2\2\2\u05e1\u05da"\
      "\3\2\2\2\u05e1\u05db\3\2\2\2\u05e1\u05dc\3\2\2\2\u05e1\u05dd\3\2\2"\
      "\2\u05e1\u05de\3\2\2\2\u05e1\u05df\3\2\2\2\u05e1\u05e0\3\2\2\2\u05e2"\
      "\u0141\3\2\2\2\u05e3\u05eb\5\u019a\u00ce\2\u05e4\u05eb\5\u0144\u00a3"\
      "\2\u05e5\u05eb\5\u014a\u00a6\2\u05e6\u05eb\7\32\2\2\u05e7\u05eb\7"\
      "!\2\2\u05e8\u05eb\7H\2\2\u05e9\u05eb\7\22\2\2\u05ea\u05e3\3\2\2\2"\
      "\u05ea\u05e4\3\2\2\2\u05ea\u05e5\3\2\2\2\u05ea\u05e6\3\2\2\2\u05ea"\
      "\u05e7\3\2\2\2\u05ea\u05e8\3\2\2\2\u05ea\u05e9\3\2\2\2\u05eb\u0143"\
      "\3\2\2\2\u05ec\u05ee\7L\2\2\u05ed\u05ef\5\u0146\u00a4\2\u05ee\u05ed"\
      "\3\2\2\2\u05ee\u05ef\3\2\2\2\u05ef\u05f0\3\2\2\2\u05f0\u05f1\7 \2"\
      "\2\u05f1\u0145\3\2\2\2\u05f2\u05f4\5\u0148\u00a5\2\u05f3\u05f5\7\27"\
      "\2\2\u05f4\u05f3\3\2\2\2\u05f4\u05f5\3\2\2\2\u05f5\u05fb\3\2\2\2\u05f6"\
      "\u05f7\5\u0148\u00a5\2\u05f7\u05f8\7\27\2\2\u05f8\u05f9\5\u0146\u00a4"\
      "\2\u05f9\u05fb\3\2\2\2\u05fa\u05f2\3\2\2\2\u05fa\u05f6\3\2\2\2\u05fb"\
      "\u0147\3\2\2\2\u05fc\u05fd\5\u0134\u009b\2\u05fd\u0149\3\2\2\2\u05fe"\
      "\u05ff\7L\2\2\u05ff\u0600\5\u014c\u00a7\2\u0600\u0601\7 \2\2\u0601"\
      "\u0606\3\2\2\2\u0602\u0603\7L\2\2\u0603\u0604\7K\2\2\u0604\u0606\7"\
      " \2\2\u0605\u05fe\3\2\2\2\u0605\u0602\3\2\2\2\u0606\u014b\3\2\2\2"\
      "\u0607\u0609\5\u014e\u00a8\2\u0608\u060a\7\27\2\2\u0609\u0608\3\2"\
      "\2\2\u0609\u060a\3\2\2\2\u060a\u060b\3\2\2\2\u060b\u060c\5\u014e\u00a8"\
      "\2\u060c\u060d\7\27\2\2\u060d\u060e\5\u014c\u00a7\2\u060e\u014d\3"\
      "\2\2\2\u060f\u0610\5\u0134\u009b\2\u0610\u0611\7K\2\2\u0611\u0612"\
      "\5\u0134\u009b\2\u0612\u014f\3\2\2\2\u0613\u0620\7Y\2\2\u0614\u0615"\
      "\7Y\2\2\u0615\u0616\7B\2\2\u0616\u0620\5\u0192\u00ca\2\u0617\u0618"\
      "\7Y\2\2\u0618\u0619\7L\2\2\u0619\u061a\5\u0134\u009b\2\u061a\u061b"\
      "\7 \2\2\u061b\u0620\3\2\2\2\u061c\u061d\7Y\2\2\u061d\u061e\7B\2\2"\
      "\u061e\u0620\7\34\2\2\u061f\u0613\3\2\2\2\u061f\u0614\3\2\2\2\u061f"\
      "\u0617\3\2\2\2\u061f\u061c\3\2\2\2\u0620\u0151\3\2\2\2\u0621\u0626"\
      "\5\u0154\u00ab\2\u0622\u0623\5\u0156\u00ac\2\u0623\u0624\5\u0158\u00ad"\
      "\2\u0624\u0626\3\2\2\2\u0625\u0621\3\2\2\2\u0625\u0622\3\2\2\2\u0626"\
      "\u0153\3\2\2\2\u0627\u0628\7X\2\2\u0628\u0629\7B\2\2\u0629\u062a\5"\
      "\u0192\u00ca\2\u062a\u0155\3\2\2\2\u062b\u062c\7X\2\2\u062c\u062d"\
      "\7L\2\2\u062d\u062e\5\u0134\u009b\2\u062e\u062f\7 \2\2\u062f\u0157"\
      "\3\2\2\2\u0630\u0631\7X\2\2\u0631\u0632\7B\2\2\u0632\u0633\7\34\2"\
      "\2\u0633\u0159\3\2\2\2\u0634\u0636\7\13\2\2\u0635\u0637\5\u015c\u00af"\
      "\2\u0636\u0635\3\2\2\2\u0636\u0637\3\2\2\2\u0637\u0638\3\2\2\2\u0638"\
      "\u0639\5\6\4\2\u0639\u063a\7\66\2\2\u063a\u015b\3\2\2\2\u063b\u063d"\
      "\5\u009eP\2\u063c\u063e\5\u0098M\2\u063d\u063c\3\2\2\2\u063d\u063e"\
      "\3\2\2\2\u063e\u063f\3\2\2\2\u063f\u0640\7W\2\2\u0640\u0659\3\2\2"\
      "\2\u0641\u0643\5\u0198\u00cd\2\u0642\u0644\5\u0098M\2\u0643\u0642"\
      "\3\2\2\2\u0643\u0644\3\2\2\2\u0644\u0645\3\2\2\2\u0645\u0646\7W\2"\
      "\2\u0646\u0659\3\2\2\2\u0647\u0648\5\u015e\u00b0\2\u0648\u064a\5\u009e"\
      "P\2\u0649\u064b\5\u0098M\2\u064a\u0649\3\2\2\2\u064a\u064b\3\2\2\2"\
      "\u064b\u064c\3\2\2\2\u064c\u064d\7W\2\2\u064d\u0659\3\2\2\2\u064e"\
      "\u064f\5\u015e\u00b0\2\u064f\u0651\5\u0198\u00cd\2\u0650\u0652\5\u0098"\
      "M\2\u0651\u0650\3\2\2\2\u0651\u0652\3\2\2\2\u0652\u0653\3\2\2\2\u0653"\
      "\u0654\7W\2\2\u0654\u0659\3\2\2\2\u0655\u0656\5\u015e\u00b0\2\u0656"\
      "\u0657\7W\2\2\u0657\u0659\3\2\2\2\u0658\u063b\3\2\2\2\u0658\u0641"\
      "\3\2\2\2\u0658\u0647\3\2\2\2\u0658\u064e\3\2\2\2\u0658\u0655\3\2\2"\
      "\2\u0659\u015d\3\2\2\2\u065a\u065b\7L\2\2\u065b\u065c\5\u0160\u00b1"\
      "\2\u065c\u065d\5\u0134\u009b\2\u065d\u065e\7 \2\2\u065e\u015f\3\2"\
      "\2\2\u065f\u0660\t\5\2\2\u0660\u0161\3\2\2\2\u0661\u0662\7B\2\2\u0662"\
      "\u0663\5\u0192\u00ca\2\u0663\u0163\3\2\2\2\u0664\u0666\7\25\2\2\u0665"\
      "\u0667\5\u0166\u00b4\2\u0666\u0665\3\2\2\2\u0666\u0667\3\2\2\2\u0667"\
      "\u0668\3\2\2\2\u0668\u0669\7Z\2\2\u0669\u0165\3\2\2\2\u066a\u0670"\
      "\5\u0168\u00b5\2\u066b\u066c\5\u0168\u00b5\2\u066c\u066d\7\27\2\2"\
      "\u066d\u066e\5\u0166\u00b4\2\u066e\u0670\3\2\2\2\u066f\u066a\3\2\2"\
      "\2\u066f\u066b\3\2\2\2\u0670\u0167\3\2\2\2\u0671\u0677\5\u0134\u009b"\
      "\2\u0672\u0673\5\u0192\u00ca\2\u0673\u0674\7K\2\2\u0674\u0675\5\u0134"\
      "\u009b\2\u0675\u0677\3\2\2\2\u0676\u0671\3\2\2\2\u0676\u0672\3\2\2"\
      "\2\u0677\u0169\3\2\2\2\u0678\u0679\7P\2\2\u0679\u016b\3\2\2\2\u067a"\
      "\u067b\t\6\2\2\u067b\u016d\3\2\2\2\u067c\u067d\5\u016c\u00b7\2\u067d"\
      "\u016f\3\2\2\2\u067e\u067f\5\u016c\u00b7\2\u067f\u0171\3\2\2\2\u0680"\
      "\u0681\5\u016c\u00b7\2\u0681\u0173\3\2\2\2\u0682\u0683\b\u00bb\1\2"\
      "\u0683\u0687\5\u0178\u00bd\2\u0684\u0687\5\u017c\u00bf\2\u0685\u0687"\
      "\5\u0186\u00c4\2\u0686\u0682\3\2\2\2\u0686\u0684\3\2\2\2\u0686\u0685"\
      "\3\2\2\2\u0687\u069a\3\2\2\2\u0688\u0689\f\n\2\2\u0689\u068a\7C\2"\
      "\2\u068a\u0699\5\u0174\u00bb\13\u068b\u068c\f\13\2\2\u068c\u068d\7"\
      "L\2\2\u068d\u0699\7 \2\2\u068e\u068f\f\7\2\2\u068f\u0699\78\2\2\u0690"\
      "\u0691\f\6\2\2\u0691\u0699\7S\2\2\u0692\u0693\f\4\2\2\u0693\u0694"\
      "\7B\2\2\u0694\u0699\7@\2\2\u0695\u0696\f\3\2\2\u0696\u0697\7B\2\2"\
      "\u0697\u0699\7*\2\2\u0698\u0688\3\2\2\2\u0698\u068b\3\2\2\2\u0698"\
      "\u068e\3\2\2\2\u0698\u0690\3\2\2\2\u0698\u0692\3\2\2\2\u0698\u0695"\
      "\3\2\2\2\u0699\u069c\3\2\2\2\u069a\u0698\3\2\2\2\u069a\u069b\3\2\2"\
      "\2\u069b\u0175\3\2\2\2\u069c\u069a\3\2\2\2\u069d\u069f\7K\2\2\u069e"\
      "\u06a0\5\u012c\u0097\2\u069f\u069e\3\2\2\2\u069f\u06a0\3\2\2\2\u06a0"\
      "\u06a1\3\2\2\2\u06a1\u06a2\5\u0174\u00bb\2\u06a2\u0177\3\2\2\2\u06a3"\
      "\u06a5\5\u017a\u00be\2\u06a4\u06a6\5N(\2\u06a5\u06a4\3\2\2\2\u06a5"\
      "\u06a6\3\2\2\2\u06a6\u06af\3\2\2\2\u06a7\u06a9\5\u017a\u00be\2\u06a8"\
      "\u06aa\5N(\2\u06a9\u06a8\3\2\2\2\u06a9\u06aa\3\2\2\2\u06aa\u06ab\3"\
      "\2\2\2\u06ab\u06ac\7B\2\2\u06ac\u06ad\5\u0178\u00bd\2\u06ad\u06af"\
      "\3\2\2\2\u06ae\u06a3\3\2\2\2\u06ae\u06a7\3\2\2\2\u06af\u0179\3\2\2"\
      "\2\u06b0\u06b1\5\u0192\u00ca\2\u06b1\u017b\3\2\2\2\u06b2\u06b4\7\25"\
      "\2\2\u06b3\u06b5\5\u017e\u00c0\2\u06b4\u06b3\3\2\2\2\u06b4\u06b5\3"\
      "\2\2\2\u06b5\u06b6\3\2\2\2\u06b6\u06b7\7Z\2\2\u06b7\u017d\3\2\2\2"\
      "\u06b8\u06ba\5\u0180\u00c1\2\u06b9\u06bb\7E\2\2\u06ba\u06b9\3\2\2"\
      "\2\u06ba\u06bb\3\2\2\2\u06bb\u017f\3\2\2\2\u06bc\u06c2\5\u0182\u00c2"\
      "\2\u06bd\u06be\5\u0182\u00c2\2\u06be\u06bf\7\27\2\2\u06bf\u06c0\5"\
      "\u0180\u00c1\2\u06c0\u06c2\3\2\2\2\u06c1\u06bc\3\2\2\2\u06c1\u06bd"\
      "\3\2\2\2\u06c2\u0181\3\2\2\2\u06c3\u06c5\5\u012c\u0097\2\u06c4\u06c3"\
      "\3\2\2\2\u06c4\u06c5\3\2\2\2\u06c5\u06c7\3\2\2\2\u06c6\u06c8\7<\2"\
      "\2\u06c7\u06c6\3\2\2\2\u06c7\u06c8\3\2\2\2\u06c8\u06c9\3\2\2\2\u06c9"\
      "\u06d1\5\u0174\u00bb\2\u06ca\u06cc\7<\2\2\u06cb\u06ca\3\2\2\2\u06cb"\
      "\u06cc\3\2\2\2\u06cc\u06cd\3\2\2\2\u06cd\u06ce\5\u0184\u00c3\2\u06ce"\
      "\u06cf\5\u0176\u00bc\2\u06cf\u06d1\3\2\2\2\u06d0\u06c4\3\2\2\2\u06d0"\
      "\u06cb\3\2\2\2\u06d1\u0183\3\2\2\2\u06d2\u06d3\5\u0192\u00ca\2\u06d3"\
      "\u0185\3\2\2\2\u06d4\u06d5\7-\2\2\u06d5\u06d7\7\37\2\2\u06d6\u06d8"\
      "\5\u0188\u00c5\2\u06d7\u06d6\3\2\2\2\u06d7\u06d8\3\2\2\2\u06d8\u06d9"\
      "\3\2\2\2\u06d9\u06da\7O\2\2\u06da\u0187\3\2\2\2\u06db\u06e1\5\u018a"\
      "\u00c6\2\u06dc\u06dd\5\u018a\u00c6\2\u06dd\u06de\7\27\2\2\u06de\u06df"\
      "\5\u0188\u00c5\2\u06df\u06e1\3\2\2\2\u06e0\u06db\3\2\2\2\u06e0\u06dc"\
      "\3\2\2\2\u06e1\u0189\3\2\2\2\u06e2\u06e3\5\u0178\u00bd\2\u06e3\u018b"\
      "\3\2\2\2\u06e4\u06e5\5\u0174\u00bb\2\u06e5\u06e6\7B\2\2\u06e6\u06e7"\
      "\7@\2\2\u06e7\u06ed\3\2\2\2\u06e8\u06e9\5\u0174\u00bb\2\u06e9\u06ea"\
      "\7B\2\2\u06ea\u06eb\7*\2\2\u06eb\u06ed\3\2\2\2\u06ec\u06e4\3\2\2\2"\
      "\u06ec\u06e8\3\2\2\2\u06ed\u018d\3\2\2\2\u06ee\u06ef\7K\2\2\u06ef"\
      "\u06f0\5\u0190\u00c9\2\u06f0\u018f\3\2\2\2\u06f1\u06f6\5\u0178\u00bd"\
      "\2\u06f2\u06f3\7\27\2\2\u06f3\u06f5\5\u0178\u00bd\2\u06f4\u06f2\3"\
      "\2\2\2\u06f5\u06f8\3\2\2\2\u06f6\u06f4\3\2\2\2\u06f6\u06f7\3\2\2\2"\
      "\u06f7\u0191\3\2\2\2\u06f8\u06f6\3\2\2\2\u06f9\u06fc\7`\2\2\u06fa"\
      "\u06fc\5\u0196\u00cc\2\u06fb\u06f9\3\2\2\2\u06fb\u06fa\3\2\2\2\u06fc"\
      "\u0193\3\2\2\2\u06fd\u06fe\t\7\2\2\u06fe\u0195\3\2\2\2\u06ff\u0700"\
      "\t\b\2\2\u0700\u0197\3\2\2\2\u0701\u0707\5\u0192\u00ca\2\u0702\u0703"\
      "\5\u0192\u00ca\2\u0703\u0704\7\27\2\2\u0704\u0705\5\u0198\u00cd\2"\
      "\u0705\u0707\3\2\2\2\u0706\u0701\3\2\2\2\u0706\u0702\3\2\2\2\u0707"\
      "\u0199\3\2\2\2\u0708\u070c\5\u019c\u00cf\2\u0709\u070c\7f\2\2\u070a"\
      "\u070c\7g\2\2\u070b\u0708\3\2\2\2\u070b\u0709\3\2\2\2\u070b\u070a"\
      "\3\2\2\2\u070c\u019b\3\2\2\2\u070d\u070e\t\t\2\2\u070e\u019d\3\2\2"\
      "\2\u00d1\u01a0\u01a2\u01a9\u01ad\u01b1\u01b5\u01ba\u01bc\u01c1\u01c7"\
      "\u01cb\u01cf\u01d3\u01d8\u01dc\u01e0\u01e3\u01e7\u01f5\u01fe\u0204"\
      "\u0208\u020e\u0214\u021a\u0228\u0230\u0234\u0247\u0252\u0256\u025a"\
      "\u0260\u0265\u026e\u0279\u0283\u0287\u0291\u02a0\u02b3\u02b7\u02bb"\
      "\u02c1\u02c6\u02ca\u02d5\u02d9\u02dc\u02df\u02e9\u02ee\u0309\u030d"\
      "\u0310\u0313\u031c\u0325\u0328\u032e\u0332\u033b\u0344\u0347\u034c"\
      "\u0353\u035c\u035f\u0363\u0368\u036c\u037e\u0384\u0387\u038d\u0391"\
      "\u0395\u039d\u03a4\u03a8\u03af\u03b2\u03b5\u03b8\u03bc\u03c0\u03c3"\
      "\u03c7\u03cb\u03cf\u03d2\u03d5\u03d9\u03dd\u03e3\u03e7\u03ea\u03ee"\
      "\u03f2\u03f8\u03fc\u03ff\u0409\u040d\u0415\u041b\u0421\u0425\u0428"\
      "\u0432\u0436\u043c\u0441\u0444\u044c\u0451\u0456\u0459\u0461\u0466"\
      "\u046b\u0473\u047c\u0480\u048a\u0490\u049a\u049d\u04a1\u04a7\u04aa"\
      "\u04b1\u04b9\u04bf\u04cf\u04d2\u04d9\u04e0\u04f6\u04f9\u0508\u050c"\
      "\u0511\u0517\u051e\u0529\u052d\u0536\u053c\u0541\u0545\u0553\u0559"\
      "\u0560\u0565\u0569\u056e\u0573\u057b\u0582\u058b\u05a0\u05ac\u05bd"\
      "\u05bf\u05cf\u05d2\u05d8\u05e1\u05ea\u05ee\u05f4\u05fa\u0605\u0609"\
      "\u061f\u0625\u0636\u063d\u0643\u064a\u0651\u0658\u0666\u066f\u0676"\
      "\u0686\u0698\u069a\u069f\u06a5\u06a9\u06ae\u06b4\u06ba\u06c1\u06c4"\
      "\u06c7\u06cb\u06d0\u06d7\u06e0\u06ec\u06f6\u06fb\u0706\u070b".chars
      end		

    EOF = Token.EOF
    T__92=1
    T__91=2
    T__90=3
    T__89=4
    T__88=5
    T__87=6
    T__86=7
    T__85=8
    T__84=9
    T__83=10
    T__82=11
    T__81=12
    T__80=13
    T__79=14
    T__78=15
    T__77=16
    T__76=17
    T__75=18
    T__74=19
    T__73=20
    T__72=21
    T__71=22
    T__70=23
    T__69=24
    T__68=25
    T__67=26
    T__66=27
    T__65=28
    T__64=29
    T__63=30
    T__62=31
    T__61=32
    T__60=33
    T__59=34
    T__58=35
    T__57=36
    T__56=37
    T__55=38
    T__54=39
    T__53=40
    T__52=41
    T__51=42
    T__50=43
    T__49=44
    T__48=45
    T__47=46
    T__46=47
    T__45=48
    T__44=49
    T__43=50
    T__42=51
    T__41=52
    T__40=53
    T__39=54
    T__38=55
    T__37=56
    T__36=57
    T__35=58
    T__34=59
    T__33=60
    T__32=61
    T__31=62
    T__30=63
    T__29=64
    T__28=65
    T__27=66
    T__26=67
    T__25=68
    T__24=69
    T__23=70
    T__22=71
    T__21=72
    T__20=73
    T__19=74
    T__18=75
    T__17=76
    T__16=77
    T__15=78
    T__14=79
    T__13=80
    T__12=81
    T__11=82
    T__10=83
    T__9=84
    T__8=85
    T__7=86
    T__6=87
    T__5=88
    T__4=89
    T__3=90
    T__2=91
    T__1=92
    T__0=93
    Identifier=94
    Implicit_parameter_name=95
    Binary_literal=96
    Octal_literal=97
    Decimal_literal=98
    Hexadecimal_literal=99
    Floating_point_literal=100
    String_literal=101
    Escaped_character=102
    WS=103
    Block_comment=104
    Line_comment=105

    RULE_top_level = 0
    RULE_statement = 1
    RULE_statements = 2
    RULE_loop_statement = 3
    RULE_for_statement = 4
    RULE_for_init = 5
    RULE_for_in_statement = 6
    RULE_while_statement = 7
    RULE_while_condition = 8
    RULE_do_while_statement = 9
    RULE_branch_statement = 10
    RULE_if_statement = 11
    RULE_if_condition = 12
    RULE_else_clause = 13
    RULE_switch_statement = 14
    RULE_switch_cases = 15
    RULE_switch_case = 16
    RULE_case_label = 17
    RULE_case_item_list = 18
    RULE_default_label = 19
    RULE_guard_clause = 20
    RULE_guard_expression = 21
    RULE_labeled_statement = 22
    RULE_statement_label = 23
    RULE_label_name = 24
    RULE_control_transfer_statement = 25
    RULE_break_statement = 26
    RULE_continue_statement = 27
    RULE_fallthrough_statement = 28
    RULE_return_statement = 29
    RULE_generic_parameter_clause = 30
    RULE_generic_parameter_list = 31
    RULE_generic_parameter = 32
    RULE_requirement_clause = 33
    RULE_requirement_list = 34
    RULE_requirement = 35
    RULE_conformance_requirement = 36
    RULE_same_type_requirement = 37
    RULE_generic_argument_clause = 38
    RULE_generic_argument_list = 39
    RULE_generic_argument = 40
    RULE_declaration = 41
    RULE_declarations = 42
    RULE_declaration_specifiers = 43
    RULE_declaration_specifier = 44
    RULE_code_block = 45
    RULE_import_declaration = 46
    RULE_import_kind = 47
    RULE_import_path = 48
    RULE_import_path_identifier = 49
    RULE_constant_declaration = 50
    RULE_pattern_initializer_list = 51
    RULE_pattern_initializer = 52
    RULE_initializer = 53
    RULE_variable_declaration = 54
    RULE_variable_declaration_head = 55
    RULE_variable_name = 56
    RULE_getter_setter_block = 57
    RULE_getter_clause = 58
    RULE_setter_clause = 59
    RULE_setter_name = 60
    RULE_getter_setter_keyword_block = 61
    RULE_getter_keyword_clause = 62
    RULE_setter_keyword_clause = 63
    RULE_willSet_didSet_block = 64
    RULE_willSet_clause = 65
    RULE_didSet_clause = 66
    RULE_typealias_declaration = 67
    RULE_typealias_head = 68
    RULE_typealias_name = 69
    RULE_typealias_assignment = 70
    RULE_function_declaration = 71
    RULE_function_head = 72
    RULE_function_name = 73
    RULE_function_signature = 74
    RULE_function_result = 75
    RULE_function_body = 76
    RULE_parameter_clauses = 77
    RULE_parameter_clause = 78
    RULE_parameter_list = 79
    RULE_parameter = 80
    RULE_parameter_name = 81
    RULE_local_parameter_name = 82
    RULE_default_argument_clause = 83
    RULE_enum_declaration = 84
    RULE_union_style_enum = 85
    RULE_union_style_enum_members = 86
    RULE_union_style_enum_member = 87
    RULE_union_style_enum_case_clause = 88
    RULE_union_style_enum_case_list = 89
    RULE_union_style_enum_case = 90
    RULE_enum_name = 91
    RULE_enum_case_name = 92
    RULE_raw_value_style_enum = 93
    RULE_raw_value_style_enum_members = 94
    RULE_raw_value_style_enum_member = 95
    RULE_raw_value_style_enum_case_clause = 96
    RULE_raw_value_style_enum_case_list = 97
    RULE_raw_value_style_enum_case = 98
    RULE_raw_value_assignment = 99
    RULE_struct_declaration = 100
    RULE_struct_name = 101
    RULE_struct_body = 102
    RULE_class_declaration = 103
    RULE_class_name = 104
    RULE_class_body = 105
    RULE_protocol_declaration = 106
    RULE_protocol_name = 107
    RULE_protocol_body = 108
    RULE_protocol_member_declaration = 109
    RULE_protocol_member_declarations = 110
    RULE_protocol_property_declaration = 111
    RULE_protocol_method_declaration = 112
    RULE_protocol_initializer_declaration = 113
    RULE_protocol_subscript_declaration = 114
    RULE_protocol_associated_type_declaration = 115
    RULE_initializer_declaration = 116
    RULE_initializer_head = 117
    RULE_initializer_body = 118
    RULE_deinitializer_declaration = 119
    RULE_extension_declaration = 120
    RULE_extension_body = 121
    RULE_subscript_declaration = 122
    RULE_subscript_head = 123
    RULE_subscript_result = 124
    RULE_operator_declaration = 125
    RULE_prefix_operator_declaration = 126
    RULE_postfix_operator_declaration = 127
    RULE_infix_operator_declaration = 128
    RULE_infix_operator_attributes = 129
    RULE_precedence_clause = 130
    RULE_precedence_level = 131
    RULE_associativity_clause = 132
    RULE_associativity = 133
    RULE_pattern = 134
    RULE_wildcard_pattern = 135
    RULE_identifier_pattern = 136
    RULE_value_binding_pattern = 137
    RULE_tuple_pattern = 138
    RULE_tuple_pattern_element_list = 139
    RULE_tuple_pattern_element = 140
    RULE_enum_case_pattern = 141
    RULE_type_casting_pattern = 142
    RULE_is_pattern = 143
    RULE_as_pattern = 144
    RULE_expression_pattern = 145
    RULE_attribute = 146
    RULE_attribute_name = 147
    RULE_attribute_argument_clause = 148
    RULE_attributes = 149
    RULE_balanced_tokens = 150
    RULE_balanced_token = 151
    RULE_expression_list = 152
    RULE_expression = 153
    RULE_in_out_expression = 154
    RULE_assignment_operator = 155
    RULE_conditional_operator = 156
    RULE_type_casting_operator = 157
    RULE_trailing_closure = 158
    RULE_primary_expression = 159
    RULE_literal_expression = 160
    RULE_array_literal = 161
    RULE_array_literal_items = 162
    RULE_array_literal_item = 163
    RULE_dictionary_literal = 164
    RULE_dictionary_literal_items = 165
    RULE_dictionary_literal_item = 166
    RULE_self_expression = 167
    RULE_superclass_expression = 168
    RULE_superclass_method_expression = 169
    RULE_superclass_subscript_expression = 170
    RULE_superclass_initializer_expression = 171
    RULE_closure_expression = 172
    RULE_closure_signature = 173
    RULE_capture_list = 174
    RULE_capture_specifier = 175
    RULE_implicit_member_expression = 176
    RULE_parenthesized_expression = 177
    RULE_expression_element_list = 178
    RULE_expression_element = 179
    RULE_wildcard_expression = 180
    RULE_operator = 181
    RULE_binary_operator = 182
    RULE_prefix_operator = 183
    RULE_postfix_operator = 184
    RULE_type = 185
    RULE_type_annotation = 186
    RULE_type_identifier = 187
    RULE_type_name = 188
    RULE_tuple_type = 189
    RULE_tuple_type_body = 190
    RULE_tuple_type_element_list = 191
    RULE_tuple_type_element = 192
    RULE_element_name = 193
    RULE_protocol_composition_type = 194
    RULE_protocol_identifier_list = 195
    RULE_protocol_identifier = 196
    RULE_metatype_type = 197
    RULE_type_inheritance_clause = 198
    RULE_type_inheritance_list = 199
    RULE_identifier = 200
    RULE_keyword = 201
    RULE_context_sensitive_keyword = 202
    RULE_identifier_list = 203
    RULE_literal = 204
    RULE_integer_literal = 205

    def initialize(input) # input:TokenStream
        super(input)
        self.checkVersion('4.4')
        self.predicates = nil
        @grammarFileName = 'java-escape'
        @tokenNames = [ "<INVALID>", "'default'", "'func'", "'new'", "'associativity'", 
                        "'operator'", "'set'", "'precedence'", "'willSet'", 
                        "'{'", "'while'", "'='", "'^'", "'for'", "'postfix'", 
                        "'get'", "'__FUNCTION__'", "'override'", "'none'", 
                        "'('", "'do'", "','", "'right'", "'unowned(safe)'", 
                        "'__FILE__'", "'var'", "'init'", "'dynamicType'", 
                        "'extension'", "'<'", "']'", "'__LINE__'", "'@'", 
                        "'unowned'", "'#'", "'let'", "'static'", "'+'", 
                        "'infix'", "'struct'", "'Protocol'", "'subscript'", 
                        "'/'", "'protocol'", "'deinit'", "'as'", "'continue'", 
                        "'Self'", "'return'", "'class'", "'\\'", "';'", 
                        "'}'", "'if'", "'?'", "'enum'", "'break'", "'&'", 
                        "'inout'", "'is'", "'switch'", "'*'", "'Type'", 
                        "'weak'", "'.'", "'->'", "'case'", "'...'", "'left'", 
                        "'convenience'", "'__COLUMN__'", "'unowned(unsafe)'", 
                        "'mutating'", "':'", "'['", "'|'", "'=='", "'>'", 
                        "'_'", "'didSet'", "'fallthrough'", "'!'", "'where'", 
                        "'%'", "'else'", "'in'", "'super'", "'self'", "')'", 
                        "'nonmutating'", "'-'", "'prefix'", "'typealias'", 
                        "'import'", "Identifier", "Implicit_parameter_name", 
                        "Binary_literal", "Octal_literal", "Decimal_literal", 
                        "Hexadecimal_literal", "Floating_point_literal", 
                        "String_literal", "Escaped_character", "WS", "Block_comment", 
                        "Line_comment" ]
        @ruleNames =  [ "top_level", "statement", "statements", "loop_statement", 
                        "for_statement", "for_init", "for_in_statement", 
                        "while_statement", "while_condition", "do_while_statement", 
                        "branch_statement", "if_statement", "if_condition", 
                        "else_clause", "switch_statement", "switch_cases", 
                        "switch_case", "case_label", "case_item_list", "default_label", 
                        "guard_clause", "guard_expression", "labeled_statement", 
                        "statement_label", "label_name", "control_transfer_statement", 
                        "break_statement", "continue_statement", "fallthrough_statement", 
                        "return_statement", "generic_parameter_clause", 
                        "generic_parameter_list", "generic_parameter", "requirement_clause", 
                        "requirement_list", "requirement", "conformance_requirement", 
                        "same_type_requirement", "generic_argument_clause", 
                        "generic_argument_list", "generic_argument", "declaration", 
                        "declarations", "declaration_specifiers", "declaration_specifier", 
                        "code_block", "import_declaration", "import_kind", 
                        "import_path", "import_path_identifier", "constant_declaration", 
                        "pattern_initializer_list", "pattern_initializer", 
                        "initializer", "variable_declaration", "variable_declaration_head", 
                        "variable_name", "getter_setter_block", "getter_clause", 
                        "setter_clause", "setter_name", "getter_setter_keyword_block", 
                        "getter_keyword_clause", "setter_keyword_clause", 
                        "willSet_didSet_block", "willSet_clause", "didSet_clause", 
                        "typealias_declaration", "typealias_head", "typealias_name", 
                        "typealias_assignment", "function_declaration", 
                        "function_head", "function_name", "function_signature", 
                        "function_result", "function_body", "parameter_clauses", 
                        "parameter_clause", "parameter_list", "parameter", 
                        "parameter_name", "local_parameter_name", "default_argument_clause", 
                        "enum_declaration", "union_style_enum", "union_style_enum_members", 
                        "union_style_enum_member", "union_style_enum_case_clause", 
                        "union_style_enum_case_list", "union_style_enum_case", 
                        "enum_name", "enum_case_name", "raw_value_style_enum", 
                        "raw_value_style_enum_members", "raw_value_style_enum_member", 
                        "raw_value_style_enum_case_clause", "raw_value_style_enum_case_list", 
                        "raw_value_style_enum_case", "raw_value_assignment", 
                        "struct_declaration", "struct_name", "struct_body", 
                        "class_declaration", "class_name", "class_body", 
                        "protocol_declaration", "protocol_name", "protocol_body", 
                        "protocol_member_declaration", "protocol_member_declarations", 
                        "protocol_property_declaration", "protocol_method_declaration", 
                        "protocol_initializer_declaration", "protocol_subscript_declaration", 
                        "protocol_associated_type_declaration", "initializer_declaration", 
                        "initializer_head", "initializer_body", "deinitializer_declaration", 
                        "extension_declaration", "extension_body", "subscript_declaration", 
                        "subscript_head", "subscript_result", "operator_declaration", 
                        "prefix_operator_declaration", "postfix_operator_declaration", 
                        "infix_operator_declaration", "infix_operator_attributes", 
                        "precedence_clause", "precedence_level", "associativity_clause", 
                        "associativity", "pattern", "wildcard_pattern", 
                        "identifier_pattern", "value_binding_pattern", "tuple_pattern", 
                        "tuple_pattern_element_list", "tuple_pattern_element", 
                        "enum_case_pattern", "type_casting_pattern", "is_pattern", 
                        "as_pattern", "expression_pattern", "attribute", 
                        "attribute_name", "attribute_argument_clause", "attributes", 
                        "balanced_tokens", "balanced_token", "expression_list", 
                        "expression", "in_out_expression", "assignment_operator", 
                        "conditional_operator", "type_casting_operator", 
                        "trailing_closure", "primary_expression", "literal_expression", 
                        "array_literal", "array_literal_items", "array_literal_item", 
                        "dictionary_literal", "dictionary_literal_items", 
                        "dictionary_literal_item", "self_expression", "superclass_expression", 
                        "superclass_method_expression", "superclass_subscript_expression", 
                        "superclass_initializer_expression", "closure_expression", 
                        "closure_signature", "capture_list", "capture_specifier", 
                        "implicit_member_expression", "parenthesized_expression", 
                        "expression_element_list", "expression_element", 
                        "wildcard_expression", "operator", "binary_operator", 
                        "prefix_operator", "postfix_operator", "type", "type_annotation", 
                        "type_identifier", "type_name", "tuple_type", "tuple_type_body", 
                        "tuple_type_element_list", "tuple_type_element", 
                        "element_name", "protocol_composition_type", "protocol_identifier_list", 
                        "protocol_identifier", "metatype_type", "type_inheritance_clause", 
                        "type_inheritance_list", "identifier", "keyword", 
                        "context_sensitive_keyword", "identifier_list", 
                        "literal", "integer_literal" ]

        @atn = ATNDeserializer.new().deserialize(self.class.serializedATN())
        @decisionsToDFA = @atn.decisionToState.each_with_index.map {|ds,i|  DFA.new(ds,i) }
        @sharedContextCache = PredictionContextCache.new()
        self.interp = ParserATNSimulator.new(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
    end


    # RuleFucntion generator
    class Top_levelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def EOF()
            getToken(SwiftParser::EOF, 0)
        end

        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def statement(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::StatementContext)
            else
                getTypedRuleContext(SwiftParser::StatementContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_top_level
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTop_level(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTop_level(self)
            end
        end
    end


    def top_level()
        localctx = SwiftParser::Top_levelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 0, SwiftParser.RULE_top_level)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 416
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__83) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__80) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__73) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__51) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__47) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__40) | (1 << self.T__37) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__33) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__24 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__13 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.T__1 - 64)) | (1 << (self.T__0 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) do
                self.state = 414
                la_ = self.interp.adaptivePredict(self.input,0,self.ctx)
                if la_ == 1 then
                    self.state = 412 
                    self.statement()

                elsif la_ == 2 then
                    self.state = 413 
                    self.expression(0)

                end
                self.state = 418
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
            self.state = 419
             match(SwiftParser::EOF)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class StatementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def branch_statement() 
            getTypedRuleContext(SwiftParser::Branch_statementContext,0)
        end


        def labeled_statement() 
            getTypedRuleContext(SwiftParser::Labeled_statementContext,0)
        end


        def control_transfer_statement() 
            getTypedRuleContext(SwiftParser::Control_transfer_statementContext,0)
        end


        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def loop_statement() 
            getTypedRuleContext(SwiftParser::Loop_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStatement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStatement(self)
            end
        end
    end


    def statement()
        localctx = SwiftParser::StatementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 2, SwiftParser.RULE_statement)
        _la = 0 # Token type
        begin
            self.state = 442
            la_ = self.interp.adaptivePredict(self.input,7,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 421 
                self.expression(0)
                self.state = 423
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 422
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 425 
                self.declaration()
                self.state = 427
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 426
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 429 
                self.loop_statement()
                self.state = 431
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 430
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 433 
                self.branch_statement()
                self.state = 435
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 434
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 437 
                self.labeled_statement()

            elsif la_ == 6 then
                self.enterOuterAlt(localctx, 6)
                self.state = 438 
                self.control_transfer_statement()
                self.state = 440
                _la = self.input.LA(1)
                if _la==SwiftParser.T__42 then  # Ll1Optional Bloc Single Alt
                    self.state = 439
                     match(SwiftParser::T__42)
                end #LL1OptionalBlockSingleAlt


            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class StatementsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def statement(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::StatementContext)
            else
                getTypedRuleContext(SwiftParser::StatementContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_statements
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStatements(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStatements(self)
            end
        end
    end


    def statements()
        localctx = SwiftParser::StatementsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 4, SwiftParser.RULE_statements)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 445 
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            # Trying to use Rubyism. This will probably break
            begin  # while true do
                self.state = 444 
                self.statement()
                self.state = 447 
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            #    if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__83) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__80) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__73) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__51) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__47) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__40) | (1 << self.T__37) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__33) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__24 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__13 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.T__1 - 64)) | (1 << (self.T__0 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0)) then
            #        break
            #    end
            end until not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__83) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__80) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__73) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__51) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__47) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__40) | (1 << self.T__37) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__33) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__24 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__13 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.T__1 - 64)) | (1 << (self.T__0 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0))
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Loop_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def for_statement() 
            getTypedRuleContext(SwiftParser::For_statementContext,0)
        end


        def while_statement() 
            getTypedRuleContext(SwiftParser::While_statementContext,0)
        end


        def for_in_statement() 
            getTypedRuleContext(SwiftParser::For_in_statementContext,0)
        end


        def do_while_statement() 
            getTypedRuleContext(SwiftParser::Do_while_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_loop_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLoop_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLoop_statement(self)
            end
        end
    end


    def loop_statement()
        localctx = SwiftParser::Loop_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 6, SwiftParser.RULE_loop_statement)
        begin
            self.state = 453
            la_ = self.interp.adaptivePredict(self.input,9,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 449 
                self.for_statement()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 450 
                self.for_in_statement()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 451 
                self.while_statement()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 452 
                self.do_while_statement()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class For_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def for_init() 
            getTypedRuleContext(SwiftParser::For_initContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_for_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFor_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFor_statement(self)
            end
        end
    end


    def for_statement()
        localctx = SwiftParser::For_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 8, SwiftParser.RULE_for_statement)
        _la = 0 # Token type
        begin
            self.state = 481
            la_ = self.interp.adaptivePredict(self.input,16,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 455
                 match(SwiftParser::T__80)
                self.state = 457
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 456 
                    self.for_init()
                end #LL1OptionalBlockSingleAlt

                self.state = 459
                 match(SwiftParser::T__42)
                self.state = 461
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 460 
                    self.expression(0)
                end #LL1OptionalBlockSingleAlt

                self.state = 463
                 match(SwiftParser::T__42)
                self.state = 465
                la_ = self.interp.adaptivePredict(self.input,12,self.ctx)
                if la_ == 1
                    self.state = 464 
                    self.expression(0)

                end
                self.state = 467 
                self.code_block()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 468
                 match(SwiftParser::T__80)

                self.state = 470
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 469 
                    self.for_init()
                end #LL1OptionalBlockSingleAlt

                self.state = 472
                 match(SwiftParser::T__42)
                self.state = 474
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 473 
                    self.expression(0)
                end #LL1OptionalBlockSingleAlt

                self.state = 476
                 match(SwiftParser::T__42)
                self.state = 478
                la_ = self.interp.adaptivePredict(self.input,15,self.ctx)
                if la_ == 1
                    self.state = 477 
                    self.expression(0)

                end
                self.state = 480 
                self.code_block()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class For_initContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression_list() 
            getTypedRuleContext(SwiftParser::Expression_listContext,0)
        end


        def variable_declaration() 
            getTypedRuleContext(SwiftParser::Variable_declarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_for_init
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFor_init(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFor_init(self)
            end
        end
    end


    def for_init()
        localctx = SwiftParser::For_initContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 10, SwiftParser.RULE_for_init)
        begin
            self.state = 485
            la_ = self.interp.adaptivePredict(self.input,17,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 483 
                self.variable_declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 484 
                self.expression_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class For_in_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_for_in_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFor_in_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFor_in_statement(self)
            end
        end
    end


    def for_in_statement()
        localctx = SwiftParser::For_in_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 12, SwiftParser.RULE_for_in_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 487
             match(SwiftParser::T__80)
            self.state = 488 
            self.pattern(0)
            self.state = 489
             match(SwiftParser::T__8)
            self.state = 490 
            self.expression(0)
            self.state = 491 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class While_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def while_condition() 
            getTypedRuleContext(SwiftParser::While_conditionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_while_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWhile_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWhile_statement(self)
            end
        end
    end


    def while_statement()
        localctx = SwiftParser::While_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 14, SwiftParser.RULE_while_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 493
             match(SwiftParser::T__83)
            self.state = 494 
            self.while_condition()
            self.state = 495 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class While_conditionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_while_condition
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWhile_condition(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWhile_condition(self)
            end
        end
    end


    def while_condition()
        localctx = SwiftParser::While_conditionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 16, SwiftParser.RULE_while_condition)
        begin
            self.state = 499
            la_ = self.interp.adaptivePredict(self.input,18,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 497 
                self.expression(0)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 498 
                self.declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Do_while_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def while_condition() 
            getTypedRuleContext(SwiftParser::While_conditionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_do_while_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDo_while_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDo_while_statement(self)
            end
        end
    end


    def do_while_statement()
        localctx = SwiftParser::Do_while_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 18, SwiftParser.RULE_do_while_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 501
             match(SwiftParser::T__73)
            self.state = 502 
            self.code_block()
            self.state = 503
             match(SwiftParser::T__83)
            self.state = 504 
            self.while_condition()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Branch_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def if_statement() 
            getTypedRuleContext(SwiftParser::If_statementContext,0)
        end


        def switch_statement() 
            getTypedRuleContext(SwiftParser::Switch_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_branch_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBranch_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBranch_statement(self)
            end
        end
    end


    def branch_statement()
        localctx = SwiftParser::Branch_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 20, SwiftParser.RULE_branch_statement)
        begin
            self.state = 508
            token = self.input.LA(1)
            if [self.T__40].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 506 
                self.if_statement()

            elsif [self.T__33].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 507 
                self.switch_statement()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class If_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def else_clause() 
            getTypedRuleContext(SwiftParser::Else_clauseContext,0)
        end


        def if_condition() 
            getTypedRuleContext(SwiftParser::If_conditionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_if_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIf_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIf_statement(self)
            end
        end
    end


    def if_statement()
        localctx = SwiftParser::If_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 22, SwiftParser.RULE_if_statement)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 510
             match(SwiftParser::T__40)
            self.state = 511 
            self.if_condition()
            self.state = 512 
            self.code_block()
            self.state = 514
            _la = self.input.LA(1)
            if _la==SwiftParser.T__9 then  # Ll1Optional Bloc Single Alt
                self.state = 513 
                self.else_clause()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class If_conditionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_if_condition
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIf_condition(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIf_condition(self)
            end
        end
    end


    def if_condition()
        localctx = SwiftParser::If_conditionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 24, SwiftParser.RULE_if_condition)
        begin
            self.state = 518
            la_ = self.interp.adaptivePredict(self.input,21,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 516 
                self.expression(0)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 517 
                self.declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Else_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def if_statement() 
            getTypedRuleContext(SwiftParser::If_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_else_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterElse_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitElse_clause(self)
            end
        end
    end


    def else_clause()
        localctx = SwiftParser::Else_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 26, SwiftParser.RULE_else_clause)
        begin
            self.state = 524
            la_ = self.interp.adaptivePredict(self.input,22,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 520
                 match(SwiftParser::T__9)
                self.state = 521 
                self.code_block()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 522
                 match(SwiftParser::T__9)
                self.state = 523 
                self.if_statement()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Switch_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def switch_cases() 
            getTypedRuleContext(SwiftParser::Switch_casesContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_switch_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSwitch_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSwitch_statement(self)
            end
        end
    end


    def switch_statement()
        localctx = SwiftParser::Switch_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 28, SwiftParser.RULE_switch_statement)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 526
             match(SwiftParser::T__33)
            self.state = 527 
            self.expression(0)
            self.state = 528
             match(SwiftParser::T__84)
            self.state = 530
            _la = self.input.LA(1)
            if _la==SwiftParser.T__92 or _la==SwiftParser.T__27 then  # Ll1Optional Bloc Single Alt
                self.state = 529 
                self.switch_cases()
            end #LL1OptionalBlockSingleAlt

            self.state = 532
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Switch_casesContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def switch_case() 
            getTypedRuleContext(SwiftParser::Switch_caseContext,0)
        end


        def switch_cases() 
            getTypedRuleContext(SwiftParser::Switch_casesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_switch_cases
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSwitch_cases(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSwitch_cases(self)
            end
        end
    end


    def switch_cases()
        localctx = SwiftParser::Switch_casesContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 30, SwiftParser.RULE_switch_cases)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 534 
            self.switch_case()
            self.state = 536
            _la = self.input.LA(1)
            if _la==SwiftParser.T__92 or _la==SwiftParser.T__27 then  # Ll1Optional Bloc Single Alt
                self.state = 535 
                self.switch_cases()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Switch_caseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def case_label() 
            getTypedRuleContext(SwiftParser::Case_labelContext,0)
        end


        def statements() 
            getTypedRuleContext(SwiftParser::StatementsContext,0)
        end


        def default_label() 
            getTypedRuleContext(SwiftParser::Default_labelContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_switch_case
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSwitch_case(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSwitch_case(self)
            end
        end
    end


    def switch_case()
        localctx = SwiftParser::Switch_caseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 32, SwiftParser.RULE_switch_case)
        begin
            self.state = 550
            la_ = self.interp.adaptivePredict(self.input,25,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 538 
                self.case_label()
                self.state = 539 
                self.statements()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 541 
                self.default_label()
                self.state = 542 
                self.statements()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 544 
                self.case_label()
                self.state = 545
                 match(SwiftParser::T__42)

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 547 
                self.default_label()
                self.state = 548
                 match(SwiftParser::T__42)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Case_labelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def case_item_list() 
            getTypedRuleContext(SwiftParser::Case_item_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_case_label
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCase_label(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCase_label(self)
            end
        end
    end


    def case_label()
        localctx = SwiftParser::Case_labelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 34, SwiftParser.RULE_case_label)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 552
             match(SwiftParser::T__27)
            self.state = 553 
            self.case_item_list()
            self.state = 554
             match(SwiftParser::T__20)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Case_item_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def case_item_list() 
            getTypedRuleContext(SwiftParser::Case_item_listContext,0)
        end


        def pattern(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::PatternContext)
            else
                getTypedRuleContext(SwiftParser::PatternContext,i)
            end
        end

        def guard_clause(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Guard_clauseContext)
            else
                getTypedRuleContext(SwiftParser::Guard_clauseContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_case_item_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCase_item_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCase_item_list(self)
            end
        end
    end


    def case_item_list()
        localctx = SwiftParser::Case_item_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 36, SwiftParser.RULE_case_item_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 556 
            self.pattern(0)
            self.state = 558
            _la = self.input.LA(1)
            if _la==SwiftParser.T__11 then  # Ll1Optional Bloc Single Alt
                self.state = 557 
                self.guard_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 560 
            self.pattern(0)
            self.state = 562
            _la = self.input.LA(1)
            if _la==SwiftParser.T__11 then  # Ll1Optional Bloc Single Alt
                self.state = 561 
                self.guard_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 564
             match(SwiftParser::T__72)
            self.state = 565 
            self.case_item_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Default_labelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_default_label
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDefault_label(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDefault_label(self)
            end
        end
    end


    def default_label()
        localctx = SwiftParser::Default_labelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 38, SwiftParser.RULE_default_label)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 567
             match(SwiftParser::T__92)
            self.state = 568
             match(SwiftParser::T__20)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Guard_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def guard_expression() 
            getTypedRuleContext(SwiftParser::Guard_expressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_guard_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGuard_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGuard_clause(self)
            end
        end
    end


    def guard_clause()
        localctx = SwiftParser::Guard_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 40, SwiftParser.RULE_guard_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 570
             match(SwiftParser::T__11)
            self.state = 571 
            self.guard_expression()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Guard_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_guard_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGuard_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGuard_expression(self)
            end
        end
    end


    def guard_expression()
        localctx = SwiftParser::Guard_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 42, SwiftParser.RULE_guard_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 573 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Labeled_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def statement_label() 
            getTypedRuleContext(SwiftParser::Statement_labelContext,0)
        end


        def switch_statement() 
            getTypedRuleContext(SwiftParser::Switch_statementContext,0)
        end


        def loop_statement() 
            getTypedRuleContext(SwiftParser::Loop_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_labeled_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLabeled_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLabeled_statement(self)
            end
        end
    end


    def labeled_statement()
        localctx = SwiftParser::Labeled_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 44, SwiftParser.RULE_labeled_statement)
        begin
            self.state = 581
            la_ = self.interp.adaptivePredict(self.input,28,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 575 
                self.statement_label()
                self.state = 576 
                self.loop_statement()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 578 
                self.statement_label()
                self.state = 579 
                self.switch_statement()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Statement_labelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def label_name() 
            getTypedRuleContext(SwiftParser::Label_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_statement_label
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStatement_label(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStatement_label(self)
            end
        end
    end


    def statement_label()
        localctx = SwiftParser::Statement_labelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 46, SwiftParser.RULE_statement_label)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 583 
            self.label_name()
            self.state = 584
             match(SwiftParser::T__20)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Label_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_label_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLabel_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLabel_name(self)
            end
        end
    end


    def label_name()
        localctx = SwiftParser::Label_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 48, SwiftParser.RULE_label_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 586 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Control_transfer_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def return_statement() 
            getTypedRuleContext(SwiftParser::Return_statementContext,0)
        end


        def fallthrough_statement() 
            getTypedRuleContext(SwiftParser::Fallthrough_statementContext,0)
        end


        def break_statement() 
            getTypedRuleContext(SwiftParser::Break_statementContext,0)
        end


        def continue_statement() 
            getTypedRuleContext(SwiftParser::Continue_statementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_control_transfer_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterControl_transfer_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitControl_transfer_statement(self)
            end
        end
    end


    def control_transfer_statement()
        localctx = SwiftParser::Control_transfer_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 50, SwiftParser.RULE_control_transfer_statement)
        begin
            self.state = 592
            token = self.input.LA(1)
            if [self.T__37].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 588 
                self.break_statement()

            elsif [self.T__47].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 589 
                self.continue_statement()

            elsif [self.T__13].member? token then 
                self.enterOuterAlt(localctx, 3)
                self.state = 590 
                self.fallthrough_statement()

            elsif [self.T__45].member? token then 
                self.enterOuterAlt(localctx, 4)
                self.state = 591 
                self.return_statement()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Break_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def label_name() 
            getTypedRuleContext(SwiftParser::Label_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_break_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBreak_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBreak_statement(self)
            end
        end
    end


    def break_statement()
        localctx = SwiftParser::Break_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 52, SwiftParser.RULE_break_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 594
             match(SwiftParser::T__37)
            self.state = 596
            la_ = self.interp.adaptivePredict(self.input,30,self.ctx)
            if la_ == 1
                self.state = 595 
                self.label_name()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Continue_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def label_name() 
            getTypedRuleContext(SwiftParser::Label_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_continue_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterContinue_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitContinue_statement(self)
            end
        end
    end


    def continue_statement()
        localctx = SwiftParser::Continue_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 54, SwiftParser.RULE_continue_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 598
             match(SwiftParser::T__47)
            self.state = 600
            la_ = self.interp.adaptivePredict(self.input,31,self.ctx)
            if la_ == 1
                self.state = 599 
                self.label_name()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Fallthrough_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_fallthrough_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFallthrough_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFallthrough_statement(self)
            end
        end
    end


    def fallthrough_statement()
        localctx = SwiftParser::Fallthrough_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 56, SwiftParser.RULE_fallthrough_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 602
             match(SwiftParser::T__13)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Return_statementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_return_statement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterReturn_statement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitReturn_statement(self)
            end
        end
    end


    def return_statement()
        localctx = SwiftParser::Return_statementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 58, SwiftParser.RULE_return_statement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 604
             match(SwiftParser::T__45)
            self.state = 606
            la_ = self.interp.adaptivePredict(self.input,32,self.ctx)
            if la_ == 1
                self.state = 605 
                self.expression(0)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_parameter_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def requirement_clause() 
            getTypedRuleContext(SwiftParser::Requirement_clauseContext,0)
        end


        def generic_parameter_list() 
            getTypedRuleContext(SwiftParser::Generic_parameter_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_parameter_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_parameter_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_parameter_clause(self)
            end
        end
    end


    def generic_parameter_clause()
        localctx = SwiftParser::Generic_parameter_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 60, SwiftParser.RULE_generic_parameter_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 608
             match(SwiftParser::T__64)
            self.state = 609 
            self.generic_parameter_list()
            self.state = 611
            _la = self.input.LA(1)
            if _la==SwiftParser.T__11 then  # Ll1Optional Bloc Single Alt
                self.state = 610 
                self.requirement_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 613
             match(SwiftParser::T__16)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_parameter_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_parameter_list() 
            getTypedRuleContext(SwiftParser::Generic_parameter_listContext,0)
        end


        def generic_parameter() 
            getTypedRuleContext(SwiftParser::Generic_parameterContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_parameter_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_parameter_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_parameter_list(self)
            end
        end
    end


    def generic_parameter_list()
        localctx = SwiftParser::Generic_parameter_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 62, SwiftParser.RULE_generic_parameter_list)
        begin
            self.state = 620
            la_ = self.interp.adaptivePredict(self.input,34,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 615 
                self.generic_parameter()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 616 
                self.generic_parameter()
                self.state = 617
                 match(SwiftParser::T__72)
                self.state = 618 
                self.generic_parameter_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_parameterContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def protocol_composition_type() 
            getTypedRuleContext(SwiftParser::Protocol_composition_typeContext,0)
        end


        def type_name() 
            getTypedRuleContext(SwiftParser::Type_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_parameter
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_parameter(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_parameter(self)
            end
        end
    end


    def generic_parameter()
        localctx = SwiftParser::Generic_parameterContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 64, SwiftParser.RULE_generic_parameter)
        begin
            self.state = 631
            la_ = self.interp.adaptivePredict(self.input,35,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 622 
                self.type_name()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 623 
                self.type_name()
                self.state = 624
                 match(SwiftParser::T__20)
                self.state = 625 
                self.type_identifier()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 627 
                self.type_name()
                self.state = 628
                 match(SwiftParser::T__20)
                self.state = 629 
                self.protocol_composition_type()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Requirement_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def requirement_list() 
            getTypedRuleContext(SwiftParser::Requirement_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_requirement_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRequirement_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRequirement_clause(self)
            end
        end
    end


    def requirement_clause()
        localctx = SwiftParser::Requirement_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 66, SwiftParser.RULE_requirement_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 633
             match(SwiftParser::T__11)
            self.state = 634 
            self.requirement_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Requirement_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def requirement() 
            getTypedRuleContext(SwiftParser::RequirementContext,0)
        end


        def requirement_list() 
            getTypedRuleContext(SwiftParser::Requirement_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_requirement_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRequirement_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRequirement_list(self)
            end
        end
    end


    def requirement_list()
        localctx = SwiftParser::Requirement_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 68, SwiftParser.RULE_requirement_list)
        begin
            self.state = 641
            la_ = self.interp.adaptivePredict(self.input,36,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 636 
                self.requirement()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 637 
                self.requirement()
                self.state = 638
                 match(SwiftParser::T__72)
                self.state = 639 
                self.requirement_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class RequirementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def conformance_requirement() 
            getTypedRuleContext(SwiftParser::Conformance_requirementContext,0)
        end


        def same_type_requirement() 
            getTypedRuleContext(SwiftParser::Same_type_requirementContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_requirement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRequirement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRequirement(self)
            end
        end
    end


    def requirement()
        localctx = SwiftParser::RequirementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 70, SwiftParser.RULE_requirement)
        begin
            self.state = 645
            la_ = self.interp.adaptivePredict(self.input,37,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 643 
                self.conformance_requirement()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 644 
                self.same_type_requirement()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Conformance_requirementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_composition_type() 
            getTypedRuleContext(SwiftParser::Protocol_composition_typeContext,0)
        end


        def type_identifier(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Type_identifierContext)
            else
                getTypedRuleContext(SwiftParser::Type_identifierContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_conformance_requirement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterConformance_requirement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitConformance_requirement(self)
            end
        end
    end


    def conformance_requirement()
        localctx = SwiftParser::Conformance_requirementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 72, SwiftParser.RULE_conformance_requirement)
        begin
            self.state = 655
            la_ = self.interp.adaptivePredict(self.input,38,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 647 
                self.type_identifier()
                self.state = 648
                 match(SwiftParser::T__20)
                self.state = 649 
                self.type_identifier()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 651 
                self.type_identifier()
                self.state = 652
                 match(SwiftParser::T__20)
                self.state = 653 
                self.protocol_composition_type()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Same_type_requirementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Type_identifierContext)
            else
                getTypedRuleContext(SwiftParser::Type_identifierContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_same_type_requirement
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSame_type_requirement(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSame_type_requirement(self)
            end
        end
    end


    def same_type_requirement()
        localctx = SwiftParser::Same_type_requirementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 74, SwiftParser.RULE_same_type_requirement)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 657 
            self.type_identifier()
            self.state = 658
             match(SwiftParser::T__17)
            self.state = 659 
            self.type_identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_argument_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_argument_list() 
            getTypedRuleContext(SwiftParser::Generic_argument_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_argument_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_argument_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_argument_clause(self)
            end
        end
    end


    def generic_argument_clause()
        localctx = SwiftParser::Generic_argument_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 76, SwiftParser.RULE_generic_argument_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 661
             match(SwiftParser::T__64)
            self.state = 662 
            self.generic_argument_list()
            self.state = 663
             match(SwiftParser::T__16)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_argument_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_argument(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Generic_argumentContext)
            else
                getTypedRuleContext(SwiftParser::Generic_argumentContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_argument_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_argument_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_argument_list(self)
            end
        end
    end


    def generic_argument_list()
        localctx = SwiftParser::Generic_argument_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 78, SwiftParser.RULE_generic_argument_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 665 
            self.generic_argument()
            self.state = 670
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 666
                 match(SwiftParser::T__72)
                self.state = 667 
                self.generic_argument()
                self.state = 672
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Generic_argumentContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_generic_argument
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGeneric_argument(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGeneric_argument(self)
            end
        end
    end


    def generic_argument()
        localctx = SwiftParser::Generic_argumentContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 80, SwiftParser.RULE_generic_argument)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 673 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class DeclarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator_declaration() 
            getTypedRuleContext(SwiftParser::Operator_declarationContext,0)
        end


        def variable_declaration() 
            getTypedRuleContext(SwiftParser::Variable_declarationContext,0)
        end


        def protocol_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_declarationContext,0)
        end


        def constant_declaration() 
            getTypedRuleContext(SwiftParser::Constant_declarationContext,0)
        end


        def typealias_declaration() 
            getTypedRuleContext(SwiftParser::Typealias_declarationContext,0)
        end


        def deinitializer_declaration() 
            getTypedRuleContext(SwiftParser::Deinitializer_declarationContext,0)
        end


        def function_declaration() 
            getTypedRuleContext(SwiftParser::Function_declarationContext,0)
        end


        def subscript_declaration() 
            getTypedRuleContext(SwiftParser::Subscript_declarationContext,0)
        end


        def import_declaration() 
            getTypedRuleContext(SwiftParser::Import_declarationContext,0)
        end


        def enum_declaration() 
            getTypedRuleContext(SwiftParser::Enum_declarationContext,0)
        end


        def extension_declaration() 
            getTypedRuleContext(SwiftParser::Extension_declarationContext,0)
        end


        def class_declaration() 
            getTypedRuleContext(SwiftParser::Class_declarationContext,0)
        end


        def struct_declaration() 
            getTypedRuleContext(SwiftParser::Struct_declarationContext,0)
        end


        def initializer_declaration() 
            getTypedRuleContext(SwiftParser::Initializer_declarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeclaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeclaration(self)
            end
        end
    end


    def declaration()
        localctx = SwiftParser::DeclarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 82, SwiftParser.RULE_declaration)
        begin
            self.state = 689
            la_ = self.interp.adaptivePredict(self.input,40,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 675 
                self.import_declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 676 
                self.constant_declaration()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 677 
                self.variable_declaration()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 678 
                self.typealias_declaration()

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 679 
                self.function_declaration()

            elsif la_ == 6 then
                self.enterOuterAlt(localctx, 6)
                self.state = 680 
                self.enum_declaration()

            elsif la_ == 7 then
                self.enterOuterAlt(localctx, 7)
                self.state = 681 
                self.struct_declaration()

            elsif la_ == 8 then
                self.enterOuterAlt(localctx, 8)
                self.state = 682 
                self.class_declaration()

            elsif la_ == 9 then
                self.enterOuterAlt(localctx, 9)
                self.state = 683 
                self.protocol_declaration()

            elsif la_ == 10 then
                self.enterOuterAlt(localctx, 10)
                self.state = 684 
                self.initializer_declaration()

            elsif la_ == 11 then
                self.enterOuterAlt(localctx, 11)
                self.state = 685 
                self.deinitializer_declaration()

            elsif la_ == 12 then
                self.enterOuterAlt(localctx, 12)
                self.state = 686 
                self.extension_declaration()

            elsif la_ == 13 then
                self.enterOuterAlt(localctx, 13)
                self.state = 687 
                self.subscript_declaration()

            elsif la_ == 14 then
                self.enterOuterAlt(localctx, 14)
                self.state = 688 
                self.operator_declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class DeclarationsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declarations() 
            getTypedRuleContext(SwiftParser::DeclarationsContext,0)
        end


        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_declarations
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeclarations(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeclarations(self)
            end
        end
    end


    def declarations()
        localctx = SwiftParser::DeclarationsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 84, SwiftParser.RULE_declarations)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 691 
            self.declaration()
            self.state = 693
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__24 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.T__1 - 68)) | (1 << (self.T__0 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 692 
                self.declarations()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Declaration_specifiersContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declaration_specifier() 
            getTypedRuleContext(SwiftParser::Declaration_specifierContext,0)
        end


        def declaration_specifiers() 
            getTypedRuleContext(SwiftParser::Declaration_specifiersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_declaration_specifiers
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeclaration_specifiers(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeclaration_specifiers(self)
            end
        end
    end


    def declaration_specifiers()
        localctx = SwiftParser::Declaration_specifiersContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 86, SwiftParser.RULE_declaration_specifiers)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 695 
            self.declaration_specifier()
            self.state = 697
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 696 
                self.declaration_specifiers()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Declaration_specifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_declaration_specifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeclaration_specifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeclaration_specifier(self)
            end
        end
    end


    def declaration_specifier()
        localctx = SwiftParser::Declaration_specifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 88, SwiftParser.RULE_declaration_specifier)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 699
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Code_blockContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def statements() 
            getTypedRuleContext(SwiftParser::StatementsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_code_block
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCode_block(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCode_block(self)
            end
        end
    end


    def code_block()
        localctx = SwiftParser::Code_blockContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 90, SwiftParser.RULE_code_block)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 701
             match(SwiftParser::T__84)
            self.state = 703
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__83) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__80) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__73) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__51) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__47) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__43) | (1 << self.T__40) | (1 << self.T__37) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__33) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__24 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__13 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.T__1 - 64)) | (1 << (self.T__0 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 702 
                self.statements()
            end #LL1OptionalBlockSingleAlt

            self.state = 705
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Import_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def import_kind() 
            getTypedRuleContext(SwiftParser::Import_kindContext,0)
        end


        def import_path() 
            getTypedRuleContext(SwiftParser::Import_pathContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_import_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImport_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImport_declaration(self)
            end
        end
    end


    def import_declaration()
        localctx = SwiftParser::Import_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 92, SwiftParser.RULE_import_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 708
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 707 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 710
             match(SwiftParser::T__0)
            self.state = 712
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__68) | (1 << self.T__54) | (1 << self.T__50) | (1 << self.T__44) | (1 << self.T__38))) != 0) or _la==SwiftParser.T__1 then  # Ll1Optional Bloc Single Alt
                self.state = 711 
                self.import_kind()
            end #LL1OptionalBlockSingleAlt

            self.state = 714 
            self.import_path()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Import_kindContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_import_kind
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImport_kind(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImport_kind(self)
            end
        end
    end


    def import_kind()
        localctx = SwiftParser::Import_kindContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 94, SwiftParser.RULE_import_kind)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 716
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__68) | (1 << self.T__54) | (1 << self.T__50) | (1 << self.T__44) | (1 << self.T__38))) != 0) or _la==SwiftParser.T__1)  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Import_pathContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def import_path_identifier() 
            getTypedRuleContext(SwiftParser::Import_path_identifierContext,0)
        end


        def import_path() 
            getTypedRuleContext(SwiftParser::Import_pathContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_import_path
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImport_path(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImport_path(self)
            end
        end
    end


    def import_path()
        localctx = SwiftParser::Import_pathContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 96, SwiftParser.RULE_import_path)
        begin
            self.state = 723
            la_ = self.interp.adaptivePredict(self.input,46,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 718 
                self.import_path_identifier()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 719 
                self.import_path_identifier()
                self.state = 720
                 match(SwiftParser::T__29)
                self.state = 721 
                self.import_path()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Import_path_identifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_import_path_identifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImport_path_identifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImport_path_identifier(self)
            end
        end
    end


    def import_path_identifier()
        localctx = SwiftParser::Import_path_identifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 98, SwiftParser.RULE_import_path_identifier)
        begin
            self.state = 727
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 725 
                self.identifier()

            elsif [self.T__82, self.T__81, self.T__64, self.T__56, self.T__51, self.T__43, self.T__36, self.T__32, self.T__29, self.T__18, self.T__16, self.T__12, self.T__10, self.T__3].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 726 
                self.operator()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Constant_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def declaration_specifiers() 
            getTypedRuleContext(SwiftParser::Declaration_specifiersContext,0)
        end


        def pattern_initializer_list() 
            getTypedRuleContext(SwiftParser::Pattern_initializer_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_constant_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterConstant_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitConstant_declaration(self)
            end
        end
    end


    def constant_declaration()
        localctx = SwiftParser::Constant_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 100, SwiftParser.RULE_constant_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 730
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 729 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 733
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 732 
                self.declaration_specifiers()
            end #LL1OptionalBlockSingleAlt

            self.state = 735
             match(SwiftParser::T__58)
            self.state = 736 
            self.pattern_initializer_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Pattern_initializer_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern_initializer(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Pattern_initializerContext)
            else
                getTypedRuleContext(SwiftParser::Pattern_initializerContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_pattern_initializer_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPattern_initializer_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPattern_initializer_list(self)
            end
        end
    end


    def pattern_initializer_list()
        localctx = SwiftParser::Pattern_initializer_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 102, SwiftParser.RULE_pattern_initializer_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 738 
            self.pattern_initializer()
            self.state = 743
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 739
                 match(SwiftParser::T__72)
                self.state = 740 
                self.pattern_initializer()
                self.state = 745
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Pattern_initializerContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def initializer() 
            getTypedRuleContext(SwiftParser::InitializerContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_pattern_initializer
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPattern_initializer(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPattern_initializer(self)
            end
        end
    end


    def pattern_initializer()
        localctx = SwiftParser::Pattern_initializerContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 104, SwiftParser.RULE_pattern_initializer)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 746 
            self.pattern(0)
            self.state = 748
            la_ = self.interp.adaptivePredict(self.input,51,self.ctx)
            if la_ == 1
                self.state = 747 
                self.initializer()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class InitializerContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_initializer
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInitializer(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInitializer(self)
            end
        end
    end


    def initializer()
        localctx = SwiftParser::InitializerContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 106, SwiftParser.RULE_initializer)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 750
             match(SwiftParser::T__82)
            self.state = 751 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Variable_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def willSet_didSet_block() 
            getTypedRuleContext(SwiftParser::WillSet_didSet_blockContext,0)
        end


        def variable_declaration_head() 
            getTypedRuleContext(SwiftParser::Variable_declaration_headContext,0)
        end


        def variable_name() 
            getTypedRuleContext(SwiftParser::Variable_nameContext,0)
        end


        def getter_setter_keyword_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_keyword_blockContext,0)
        end


        def pattern_initializer_list() 
            getTypedRuleContext(SwiftParser::Pattern_initializer_listContext,0)
        end


        def getter_setter_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_blockContext,0)
        end


        def initializer() 
            getTypedRuleContext(SwiftParser::InitializerContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_variable_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterVariable_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitVariable_declaration(self)
            end
        end
    end


    def variable_declaration()
        localctx = SwiftParser::Variable_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 108, SwiftParser.RULE_variable_declaration)
        _la = 0 # Token type
        begin
            self.state = 779
            la_ = self.interp.adaptivePredict(self.input,53,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 753 
                self.variable_declaration_head()
                self.state = 754 
                self.pattern_initializer_list()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 756 
                self.variable_declaration_head()
                self.state = 757 
                self.variable_name()
                self.state = 758 
                self.type_annotation()
                self.state = 759 
                self.code_block()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 761 
                self.variable_declaration_head()
                self.state = 762 
                self.variable_name()
                self.state = 763 
                self.type_annotation()
                self.state = 764 
                self.getter_setter_block()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 766 
                self.variable_declaration_head()
                self.state = 767 
                self.variable_name()
                self.state = 768 
                self.type_annotation()
                self.state = 769 
                self.getter_setter_keyword_block()

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 771 
                self.variable_declaration_head()
                self.state = 772 
                self.variable_name()
                self.state = 773 
                self.type_annotation()
                self.state = 775
                _la = self.input.LA(1)
                if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                    self.state = 774 
                    self.initializer()
                end #LL1OptionalBlockSingleAlt

                self.state = 777 
                self.willSet_didSet_block()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Variable_declaration_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def declaration_specifiers() 
            getTypedRuleContext(SwiftParser::Declaration_specifiersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_variable_declaration_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterVariable_declaration_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitVariable_declaration_head(self)
            end
        end
    end


    def variable_declaration_head()
        localctx = SwiftParser::Variable_declaration_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 110, SwiftParser.RULE_variable_declaration_head)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 782
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 781 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 785
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 784 
                self.declaration_specifiers()
            end #LL1OptionalBlockSingleAlt

            self.state = 787
             match(SwiftParser::T__68)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Variable_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_variable_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterVariable_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitVariable_name(self)
            end
        end
    end


    def variable_name()
        localctx = SwiftParser::Variable_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 112, SwiftParser.RULE_variable_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 789 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Getter_setter_blockContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def setter_clause() 
            getTypedRuleContext(SwiftParser::Setter_clauseContext,0)
        end


        def getter_clause() 
            getTypedRuleContext(SwiftParser::Getter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_getter_setter_block
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGetter_setter_block(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGetter_setter_block(self)
            end
        end
    end


    def getter_setter_block()
        localctx = SwiftParser::Getter_setter_blockContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 114, SwiftParser.RULE_getter_setter_block)
        _la = 0 # Token type
        begin
            self.state = 803
            la_ = self.interp.adaptivePredict(self.input,57,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 791
                 match(SwiftParser::T__84)
                self.state = 792 
                self.getter_clause()
                self.state = 794
                _la = self.input.LA(1)
                if _la==SwiftParser.T__87 or _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 793 
                    self.setter_clause()
                end #LL1OptionalBlockSingleAlt

                self.state = 796
                 match(SwiftParser::T__41)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 798
                 match(SwiftParser::T__84)
                self.state = 799 
                self.setter_clause()
                self.state = 800 
                self.getter_clause()
                self.state = 801
                 match(SwiftParser::T__41)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Getter_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_getter_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGetter_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGetter_clause(self)
            end
        end
    end


    def getter_clause()
        localctx = SwiftParser::Getter_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 116, SwiftParser.RULE_getter_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 806
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 805 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 808
             match(SwiftParser::T__78)
            self.state = 809 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Setter_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def setter_name() 
            getTypedRuleContext(SwiftParser::Setter_nameContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_setter_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSetter_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSetter_clause(self)
            end
        end
    end


    def setter_clause()
        localctx = SwiftParser::Setter_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 118, SwiftParser.RULE_setter_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 811 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 814
             match(SwiftParser::T__87)
            self.state = 816
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 815 
                self.setter_name()
            end #LL1OptionalBlockSingleAlt

            self.state = 818 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Setter_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_setter_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSetter_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSetter_name(self)
            end
        end
    end


    def setter_name()
        localctx = SwiftParser::Setter_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 120, SwiftParser.RULE_setter_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 820 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Getter_setter_keyword_blockContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def getter_keyword_clause() 
            getTypedRuleContext(SwiftParser::Getter_keyword_clauseContext,0)
        end


        def setter_keyword_clause() 
            getTypedRuleContext(SwiftParser::Setter_keyword_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_getter_setter_keyword_block
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGetter_setter_keyword_block(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGetter_setter_keyword_block(self)
            end
        end
    end


    def getter_setter_keyword_block()
        localctx = SwiftParser::Getter_setter_keyword_blockContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 122, SwiftParser.RULE_getter_setter_keyword_block)
        _la = 0 # Token type
        begin
            self.state = 834
            la_ = self.interp.adaptivePredict(self.input,62,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 822
                 match(SwiftParser::T__84)
                self.state = 823 
                self.getter_keyword_clause()
                self.state = 825
                _la = self.input.LA(1)
                if _la==SwiftParser.T__87 or _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 824 
                    self.setter_keyword_clause()
                end #LL1OptionalBlockSingleAlt

                self.state = 827
                 match(SwiftParser::T__41)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 829
                 match(SwiftParser::T__84)
                self.state = 830 
                self.setter_keyword_clause()
                self.state = 831 
                self.getter_keyword_clause()
                self.state = 832
                 match(SwiftParser::T__41)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Getter_keyword_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_getter_keyword_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterGetter_keyword_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitGetter_keyword_clause(self)
            end
        end
    end


    def getter_keyword_clause()
        localctx = SwiftParser::Getter_keyword_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 124, SwiftParser.RULE_getter_keyword_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 837
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 836 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 839
             match(SwiftParser::T__78)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Setter_keyword_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_setter_keyword_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSetter_keyword_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSetter_keyword_clause(self)
            end
        end
    end


    def setter_keyword_clause()
        localctx = SwiftParser::Setter_keyword_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 126, SwiftParser.RULE_setter_keyword_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 842
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 841 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 844
             match(SwiftParser::T__87)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class WillSet_didSet_blockContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def willSet_clause() 
            getTypedRuleContext(SwiftParser::WillSet_clauseContext,0)
        end


        def didSet_clause() 
            getTypedRuleContext(SwiftParser::DidSet_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_willSet_didSet_block
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWillSet_didSet_block(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWillSet_didSet_block(self)
            end
        end
    end


    def willSet_didSet_block()
        localctx = SwiftParser::WillSet_didSet_blockContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 128, SwiftParser.RULE_willSet_didSet_block)
        _la = 0 # Token type
        begin
            self.state = 858
            la_ = self.interp.adaptivePredict(self.input,66,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 846
                 match(SwiftParser::T__84)
                self.state = 847 
                self.willSet_clause()
                self.state = 849
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 or _la==SwiftParser.T__14 then  # Ll1Optional Bloc Single Alt
                    self.state = 848 
                    self.didSet_clause()
                end #LL1OptionalBlockSingleAlt

                self.state = 851
                 match(SwiftParser::T__41)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 853
                 match(SwiftParser::T__84)
                self.state = 854 
                self.didSet_clause()
                self.state = 855 
                self.willSet_clause()
                self.state = 856
                 match(SwiftParser::T__41)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class WillSet_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def setter_name() 
            getTypedRuleContext(SwiftParser::Setter_nameContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_willSet_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWillSet_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWillSet_clause(self)
            end
        end
    end


    def willSet_clause()
        localctx = SwiftParser::WillSet_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 130, SwiftParser.RULE_willSet_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 861
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 860 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 863
             match(SwiftParser::T__85)
            self.state = 865
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 864 
                self.setter_name()
            end #LL1OptionalBlockSingleAlt

            self.state = 867 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class DidSet_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def setter_name() 
            getTypedRuleContext(SwiftParser::Setter_nameContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_didSet_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDidSet_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDidSet_clause(self)
            end
        end
    end


    def didSet_clause()
        localctx = SwiftParser::DidSet_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 132, SwiftParser.RULE_didSet_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 870
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 869 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 872
             match(SwiftParser::T__14)
            self.state = 874
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 873 
                self.setter_name()
            end #LL1OptionalBlockSingleAlt

            self.state = 876 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Typealias_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def typealias_head() 
            getTypedRuleContext(SwiftParser::Typealias_headContext,0)
        end


        def typealias_assignment() 
            getTypedRuleContext(SwiftParser::Typealias_assignmentContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_typealias_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTypealias_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTypealias_declaration(self)
            end
        end
    end


    def typealias_declaration()
        localctx = SwiftParser::Typealias_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 134, SwiftParser.RULE_typealias_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 878 
            self.typealias_head()
            self.state = 879 
            self.typealias_assignment()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Typealias_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def typealias_name() 
            getTypedRuleContext(SwiftParser::Typealias_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_typealias_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTypealias_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTypealias_head(self)
            end
        end
    end


    def typealias_head()
        localctx = SwiftParser::Typealias_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 136, SwiftParser.RULE_typealias_head)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 881
             match(SwiftParser::T__1)
            self.state = 882 
            self.typealias_name()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Typealias_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_typealias_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTypealias_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTypealias_name(self)
            end
        end
    end


    def typealias_name()
        localctx = SwiftParser::Typealias_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 138, SwiftParser.RULE_typealias_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 884 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Typealias_assignmentContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_typealias_assignment
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTypealias_assignment(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTypealias_assignment(self)
            end
        end
    end


    def typealias_assignment()
        localctx = SwiftParser::Typealias_assignmentContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 140, SwiftParser.RULE_typealias_assignment)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 886
             match(SwiftParser::T__82)
            self.state = 887 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def function_body() 
            getTypedRuleContext(SwiftParser::Function_bodyContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def function_head() 
            getTypedRuleContext(SwiftParser::Function_headContext,0)
        end


        def function_name() 
            getTypedRuleContext(SwiftParser::Function_nameContext,0)
        end


        def function_signature() 
            getTypedRuleContext(SwiftParser::Function_signatureContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_declaration(self)
            end
        end
    end


    def function_declaration()
        localctx = SwiftParser::Function_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 142, SwiftParser.RULE_function_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 889 
            self.function_head()
            self.state = 890 
            self.function_name()
            self.state = 892
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 891 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 894 
            self.function_signature()
            self.state = 895 
            self.function_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def declaration_specifiers() 
            getTypedRuleContext(SwiftParser::Declaration_specifiersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_head(self)
            end
        end
    end


    def function_head()
        localctx = SwiftParser::Function_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 144, SwiftParser.RULE_function_head)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 898
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 897 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 901
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__76) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 71)) & ~0x3f) == 0  and ((1 << (_la - 71)) & ((1 << (self.T__22 - 71)) | (1 << (self.T__21 - 71)) | (1 << (self.T__4 - 71)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 900 
                self.declaration_specifiers()
            end #LL1OptionalBlockSingleAlt

            self.state = 903
             match(SwiftParser::T__91)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_name(self)
            end
        end
    end


    def function_name()
        localctx = SwiftParser::Function_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 146, SwiftParser.RULE_function_name)
        begin
            self.state = 907
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 905 
                self.identifier()

            elsif [self.T__82, self.T__81, self.T__64, self.T__56, self.T__51, self.T__43, self.T__36, self.T__32, self.T__29, self.T__18, self.T__16, self.T__12, self.T__10, self.T__3].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 906 
                self.operator()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_signatureContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def parameter_clauses() 
            getTypedRuleContext(SwiftParser::Parameter_clausesContext,0)
        end


        def function_result() 
            getTypedRuleContext(SwiftParser::Function_resultContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_signature
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_signature(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_signature(self)
            end
        end
    end


    def function_signature()
        localctx = SwiftParser::Function_signatureContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 148, SwiftParser.RULE_function_signature)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 909 
            self.parameter_clauses()
            self.state = 911
            _la = self.input.LA(1)
            if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                self.state = 910 
                self.function_result()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_resultContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_result
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_result(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_result(self)
            end
        end
    end


    def function_result()
        localctx = SwiftParser::Function_resultContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 150, SwiftParser.RULE_function_result)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 913
             match(SwiftParser::T__28)
            self.state = 915
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 914 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 917 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Function_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_function_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterFunction_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitFunction_body(self)
            end
        end
    end


    def function_body()
        localctx = SwiftParser::Function_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 152, SwiftParser.RULE_function_body)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 919 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parameter_clausesContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def parameter_clauses() 
            getTypedRuleContext(SwiftParser::Parameter_clausesContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter_clauses
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter_clauses(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter_clauses(self)
            end
        end
    end


    def parameter_clauses()
        localctx = SwiftParser::Parameter_clausesContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 154, SwiftParser.RULE_parameter_clauses)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 921 
            self.parameter_clause()
            self.state = 923
            _la = self.input.LA(1)
            if _la==SwiftParser.T__74 then  # Ll1Optional Bloc Single Alt
                self.state = 922 
                self.parameter_clauses()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parameter_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def parameter_list() 
            getTypedRuleContext(SwiftParser::Parameter_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter_clause(self)
            end
        end
    end


    def parameter_clause()
        localctx = SwiftParser::Parameter_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 156, SwiftParser.RULE_parameter_clause)
        _la = 0 # Token type
        begin
            self.state = 934
            la_ = self.interp.adaptivePredict(self.input,79,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 925
                 match(SwiftParser::T__74)
                self.state = 926
                 match(SwiftParser::T__5)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 927
                 match(SwiftParser::T__74)
                self.state = 928 
                self.parameter_list()
                self.state = 930
                _la = self.input.LA(1)
                if _la==SwiftParser.T__26 then  # Ll1Optional Bloc Single Alt
                    self.state = 929
                     match(SwiftParser::T__26)
                end #LL1OptionalBlockSingleAlt

                self.state = 932
                 match(SwiftParser::T__5)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parameter_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def parameter() 
            getTypedRuleContext(SwiftParser::ParameterContext,0)
        end


        def parameter_list() 
            getTypedRuleContext(SwiftParser::Parameter_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter_list(self)
            end
        end
    end


    def parameter_list()
        localctx = SwiftParser::Parameter_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 158, SwiftParser.RULE_parameter_list)
        begin
            self.state = 941
            la_ = self.interp.adaptivePredict(self.input,80,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 936 
                self.parameter()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 937 
                self.parameter()
                self.state = 938
                 match(SwiftParser::T__72)
                self.state = 939 
                self.parameter_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class ParameterContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def default_argument_clause() 
            getTypedRuleContext(SwiftParser::Default_argument_clauseContext,0)
        end


        def local_parameter_name() 
            getTypedRuleContext(SwiftParser::Local_parameter_nameContext,0)
        end


        def parameter_name() 
            getTypedRuleContext(SwiftParser::Parameter_nameContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter(self)
            end
        end
    end


    def parameter()
        localctx = SwiftParser::ParameterContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 160, SwiftParser.RULE_parameter)
        _la = 0 # Token type
        begin
            self.state = 979
            la_ = self.interp.adaptivePredict(self.input,91,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 944
                la_ = self.interp.adaptivePredict(self.input,81,self.ctx)
                if la_ == 1
                    self.state = 943
                     match(SwiftParser::T__35)

                end
                self.state = 947
                _la = self.input.LA(1)
                if _la==SwiftParser.T__58 then  # Ll1Optional Bloc Single Alt
                    self.state = 946
                     match(SwiftParser::T__58)
                end #LL1OptionalBlockSingleAlt

                self.state = 950
                _la = self.input.LA(1)
                if _la==SwiftParser.T__59 then  # Ll1Optional Bloc Single Alt
                    self.state = 949
                     match(SwiftParser::T__59)
                end #LL1OptionalBlockSingleAlt

                self.state = 952 
                self.parameter_name()
                self.state = 954
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__15 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 953 
                    self.local_parameter_name()
                end #LL1OptionalBlockSingleAlt

                self.state = 956 
                self.type_annotation()
                self.state = 958
                _la = self.input.LA(1)
                if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                    self.state = 957 
                    self.default_argument_clause()
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 961
                _la = self.input.LA(1)
                if _la==SwiftParser.T__35 then  # Ll1Optional Bloc Single Alt
                    self.state = 960
                     match(SwiftParser::T__35)
                end #LL1OptionalBlockSingleAlt

                self.state = 963
                 match(SwiftParser::T__68)
                self.state = 965
                _la = self.input.LA(1)
                if _la==SwiftParser.T__59 then  # Ll1Optional Bloc Single Alt
                    self.state = 964
                     match(SwiftParser::T__59)
                end #LL1OptionalBlockSingleAlt

                self.state = 967 
                self.parameter_name()
                self.state = 969
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__15 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 968 
                    self.local_parameter_name()
                end #LL1OptionalBlockSingleAlt

                self.state = 971 
                self.type_annotation()
                self.state = 973
                _la = self.input.LA(1)
                if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                    self.state = 972 
                    self.default_argument_clause()
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 976
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 975 
                    self.attributes()
                end #LL1OptionalBlockSingleAlt

                self.state = 978 
                self.type(0)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parameter_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parameter_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParameter_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParameter_name(self)
            end
        end
    end


    def parameter_name()
        localctx = SwiftParser::Parameter_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 162, SwiftParser.RULE_parameter_name)
        begin
            self.state = 983
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 981 
                self.identifier()

            elsif [self.T__15].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 982
                 match(SwiftParser::T__15)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Local_parameter_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_local_parameter_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLocal_parameter_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLocal_parameter_name(self)
            end
        end
    end


    def local_parameter_name()
        localctx = SwiftParser::Local_parameter_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 164, SwiftParser.RULE_local_parameter_name)
        begin
            self.state = 987
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 985 
                self.identifier()

            elsif [self.T__15].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 986
                 match(SwiftParser::T__15)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Default_argument_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_default_argument_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDefault_argument_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDefault_argument_clause(self)
            end
        end
    end


    def default_argument_clause()
        localctx = SwiftParser::Default_argument_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 166, SwiftParser.RULE_default_argument_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 989
             match(SwiftParser::T__82)
            self.state = 990 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Enum_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def union_style_enum() 
            getTypedRuleContext(SwiftParser::Union_style_enumContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def raw_value_style_enum() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enumContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_enum_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterEnum_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitEnum_declaration(self)
            end
        end
    end


    def enum_declaration()
        localctx = SwiftParser::Enum_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 168, SwiftParser.RULE_enum_declaration)
        _la = 0 # Token type
        begin
            self.state = 1000
            la_ = self.interp.adaptivePredict(self.input,96,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 993
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 992 
                    self.attributes()
                end #LL1OptionalBlockSingleAlt

                self.state = 995 
                self.union_style_enum()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 997
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 996 
                    self.attributes()
                end #LL1OptionalBlockSingleAlt

                self.state = 999 
                self.raw_value_style_enum()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enumContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def union_style_enum_members() 
            getTypedRuleContext(SwiftParser::Union_style_enum_membersContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def enum_name() 
            getTypedRuleContext(SwiftParser::Enum_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum(self)
            end
        end
    end


    def union_style_enum()
        localctx = SwiftParser::Union_style_enumContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 170, SwiftParser.RULE_union_style_enum)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1002 
            self.enum_name()
            self.state = 1004
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1003 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1006
             match(SwiftParser::T__84)
            self.state = 1008
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__25 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__22 - 66)) | (1 << (self.T__21 - 66)) | (1 << (self.T__14 - 66)) | (1 << (self.T__4 - 66)) | (1 << (self.T__2 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)) | (1 << (self.Identifier - 66)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1007 
                self.union_style_enum_members()
            end #LL1OptionalBlockSingleAlt

            self.state = 1010
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_membersContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def union_style_enum_member() 
            getTypedRuleContext(SwiftParser::Union_style_enum_memberContext,0)
        end


        def union_style_enum_members() 
            getTypedRuleContext(SwiftParser::Union_style_enum_membersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_members
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_members(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_members(self)
            end
        end
    end


    def union_style_enum_members()
        localctx = SwiftParser::Union_style_enum_membersContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 172, SwiftParser.RULE_union_style_enum_members)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1012 
            self.union_style_enum_member()
            self.state = 1014
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__25 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__22 - 66)) | (1 << (self.T__21 - 66)) | (1 << (self.T__14 - 66)) | (1 << (self.T__4 - 66)) | (1 << (self.T__2 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)) | (1 << (self.Identifier - 66)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1013 
                self.union_style_enum_members()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_memberContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def union_style_enum_case_clause() 
            getTypedRuleContext(SwiftParser::Union_style_enum_case_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_member
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_member(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_member(self)
            end
        end
    end


    def union_style_enum_member()
        localctx = SwiftParser::Union_style_enum_memberContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 174, SwiftParser.RULE_union_style_enum_member)
        begin
            self.state = 1018
            la_ = self.interp.adaptivePredict(self.input,100,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1016 
                self.declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1017 
                self.union_style_enum_case_clause()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_case_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def union_style_enum_case_list() 
            getTypedRuleContext(SwiftParser::Union_style_enum_case_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_case_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_case_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_case_clause(self)
            end
        end
    end


    def union_style_enum_case_clause()
        localctx = SwiftParser::Union_style_enum_case_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 176, SwiftParser.RULE_union_style_enum_case_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1021
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1020 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1023
             match(SwiftParser::T__27)
            self.state = 1024 
            self.union_style_enum_case_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_case_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def union_style_enum_case_list() 
            getTypedRuleContext(SwiftParser::Union_style_enum_case_listContext,0)
        end


        def union_style_enum_case() 
            getTypedRuleContext(SwiftParser::Union_style_enum_caseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_case_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_case_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_case_list(self)
            end
        end
    end


    def union_style_enum_case_list()
        localctx = SwiftParser::Union_style_enum_case_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 178, SwiftParser.RULE_union_style_enum_case_list)
        begin
            self.state = 1031
            la_ = self.interp.adaptivePredict(self.input,102,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1026 
                self.union_style_enum_case()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1027 
                self.union_style_enum_case()
                self.state = 1028
                 match(SwiftParser::T__72)
                self.state = 1029 
                self.union_style_enum_case_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Union_style_enum_caseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_type() 
            getTypedRuleContext(SwiftParser::Tuple_typeContext,0)
        end


        def enum_case_name() 
            getTypedRuleContext(SwiftParser::Enum_case_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_union_style_enum_case
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterUnion_style_enum_case(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitUnion_style_enum_case(self)
            end
        end
    end


    def union_style_enum_case()
        localctx = SwiftParser::Union_style_enum_caseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 180, SwiftParser.RULE_union_style_enum_case)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1033 
            self.enum_case_name()
            self.state = 1035
            _la = self.input.LA(1)
            if _la==SwiftParser.T__74 then  # Ll1Optional Bloc Single Alt
                self.state = 1034 
                self.tuple_type()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Enum_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_enum_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterEnum_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitEnum_name(self)
            end
        end
    end


    def enum_name()
        localctx = SwiftParser::Enum_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 182, SwiftParser.RULE_enum_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1037 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Enum_case_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_enum_case_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterEnum_case_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitEnum_case_name(self)
            end
        end
    end


    def enum_case_name()
        localctx = SwiftParser::Enum_case_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 184, SwiftParser.RULE_enum_case_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1039 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enumContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def enum_name() 
            getTypedRuleContext(SwiftParser::Enum_nameContext,0)
        end


        def raw_value_style_enum_members() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_membersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum(self)
            end
        end
    end


    def raw_value_style_enum()
        localctx = SwiftParser::Raw_value_style_enumContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 186, SwiftParser.RULE_raw_value_style_enum)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1041 
            self.enum_name()
            self.state = 1043
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1042 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1045
             match(SwiftParser::T__20)
            self.state = 1046 
            self.type_identifier()
            self.state = 1047
             match(SwiftParser::T__84)
            self.state = 1049
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__25 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__22 - 66)) | (1 << (self.T__21 - 66)) | (1 << (self.T__14 - 66)) | (1 << (self.T__4 - 66)) | (1 << (self.T__2 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)) | (1 << (self.Identifier - 66)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1048 
                self.raw_value_style_enum_members()
            end #LL1OptionalBlockSingleAlt

            self.state = 1051
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_membersContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def raw_value_style_enum_member() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_memberContext,0)
        end


        def raw_value_style_enum_members() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_membersContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_members
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_members(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_members(self)
            end
        end
    end


    def raw_value_style_enum_members()
        localctx = SwiftParser::Raw_value_style_enum_membersContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 188, SwiftParser.RULE_raw_value_style_enum_members)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1053 
            self.raw_value_style_enum_member()
            self.state = 1055
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__25 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__22 - 66)) | (1 << (self.T__21 - 66)) | (1 << (self.T__14 - 66)) | (1 << (self.T__4 - 66)) | (1 << (self.T__2 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)) | (1 << (self.Identifier - 66)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1054 
                self.raw_value_style_enum_members()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_memberContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def raw_value_style_enum_case_clause() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_case_clauseContext,0)
        end


        def declaration() 
            getTypedRuleContext(SwiftParser::DeclarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_member
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_member(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_member(self)
            end
        end
    end


    def raw_value_style_enum_member()
        localctx = SwiftParser::Raw_value_style_enum_memberContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 190, SwiftParser.RULE_raw_value_style_enum_member)
        begin
            self.state = 1059
            la_ = self.interp.adaptivePredict(self.input,107,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1057 
                self.declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1058 
                self.raw_value_style_enum_case_clause()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_case_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def raw_value_style_enum_case_list() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_case_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_case_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_case_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_case_clause(self)
            end
        end
    end


    def raw_value_style_enum_case_clause()
        localctx = SwiftParser::Raw_value_style_enum_case_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 192, SwiftParser.RULE_raw_value_style_enum_case_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1062
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1061 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1064
             match(SwiftParser::T__27)
            self.state = 1065 
            self.raw_value_style_enum_case_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_case_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def raw_value_style_enum_case() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_caseContext,0)
        end


        def raw_value_style_enum_case_list() 
            getTypedRuleContext(SwiftParser::Raw_value_style_enum_case_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_case_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_case_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_case_list(self)
            end
        end
    end


    def raw_value_style_enum_case_list()
        localctx = SwiftParser::Raw_value_style_enum_case_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 194, SwiftParser.RULE_raw_value_style_enum_case_list)
        begin
            self.state = 1072
            la_ = self.interp.adaptivePredict(self.input,109,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1067 
                self.raw_value_style_enum_case()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1068 
                self.raw_value_style_enum_case()
                self.state = 1069
                 match(SwiftParser::T__72)
                self.state = 1070 
                self.raw_value_style_enum_case_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_style_enum_caseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def raw_value_assignment() 
            getTypedRuleContext(SwiftParser::Raw_value_assignmentContext,0)
        end


        def enum_case_name() 
            getTypedRuleContext(SwiftParser::Enum_case_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_style_enum_case
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_style_enum_case(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_style_enum_case(self)
            end
        end
    end


    def raw_value_style_enum_case()
        localctx = SwiftParser::Raw_value_style_enum_caseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 196, SwiftParser.RULE_raw_value_style_enum_case)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1074 
            self.enum_case_name()
            self.state = 1076
            _la = self.input.LA(1)
            if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                self.state = 1075 
                self.raw_value_assignment()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Raw_value_assignmentContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def literal() 
            getTypedRuleContext(SwiftParser::LiteralContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_raw_value_assignment
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterRaw_value_assignment(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitRaw_value_assignment(self)
            end
        end
    end


    def raw_value_assignment()
        localctx = SwiftParser::Raw_value_assignmentContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 198, SwiftParser.RULE_raw_value_assignment)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1078
             match(SwiftParser::T__82)
            self.state = 1079 
            self.literal()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Struct_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def struct_name() 
            getTypedRuleContext(SwiftParser::Struct_nameContext,0)
        end


        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def struct_body() 
            getTypedRuleContext(SwiftParser::Struct_bodyContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_struct_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStruct_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStruct_declaration(self)
            end
        end
    end


    def struct_declaration()
        localctx = SwiftParser::Struct_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 200, SwiftParser.RULE_struct_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1082
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1081 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1084
             match(SwiftParser::T__54)
            self.state = 1085 
            self.struct_name()
            self.state = 1087
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1086 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1090
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1089 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1092 
            self.struct_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Struct_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_struct_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStruct_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStruct_name(self)
            end
        end
    end


    def struct_name()
        localctx = SwiftParser::Struct_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 202, SwiftParser.RULE_struct_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1094 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Struct_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declarations() 
            getTypedRuleContext(SwiftParser::DeclarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_struct_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterStruct_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitStruct_body(self)
            end
        end
    end


    def struct_body()
        localctx = SwiftParser::Struct_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 204, SwiftParser.RULE_struct_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1096
             match(SwiftParser::T__84)
            self.state = 1098
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__24 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.T__1 - 68)) | (1 << (self.T__0 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1097 
                self.declarations()
            end #LL1OptionalBlockSingleAlt

            self.state = 1100
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Class_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def class_body() 
            getTypedRuleContext(SwiftParser::Class_bodyContext,0)
        end


        def class_name() 
            getTypedRuleContext(SwiftParser::Class_nameContext,0)
        end


        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_class_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClass_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClass_declaration(self)
            end
        end
    end


    def class_declaration()
        localctx = SwiftParser::Class_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 206, SwiftParser.RULE_class_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1103
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1102 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1105
             match(SwiftParser::T__44)
            self.state = 1106 
            self.class_name()
            self.state = 1108
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1107 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1111
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1110 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1113 
            self.class_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Class_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_class_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClass_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClass_name(self)
            end
        end
    end


    def class_name()
        localctx = SwiftParser::Class_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 208, SwiftParser.RULE_class_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1115 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Class_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declarations() 
            getTypedRuleContext(SwiftParser::DeclarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_class_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClass_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClass_body(self)
            end
        end
    end


    def class_body()
        localctx = SwiftParser::Class_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 210, SwiftParser.RULE_class_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1117
             match(SwiftParser::T__84)
            self.state = 1119
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__24 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.T__1 - 68)) | (1 << (self.T__0 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1118 
                self.declarations()
            end #LL1OptionalBlockSingleAlt

            self.state = 1121
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def protocol_name() 
            getTypedRuleContext(SwiftParser::Protocol_nameContext,0)
        end


        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def protocol_body() 
            getTypedRuleContext(SwiftParser::Protocol_bodyContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_declaration(self)
            end
        end
    end


    def protocol_declaration()
        localctx = SwiftParser::Protocol_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 212, SwiftParser.RULE_protocol_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1124
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1123 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1126
             match(SwiftParser::T__50)
            self.state = 1127 
            self.protocol_name()
            self.state = 1129
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1128 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1131 
            self.protocol_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_name(self)
            end
        end
    end


    def protocol_name()
        localctx = SwiftParser::Protocol_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 214, SwiftParser.RULE_protocol_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1133 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_member_declarations() 
            getTypedRuleContext(SwiftParser::Protocol_member_declarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_body(self)
            end
        end
    end


    def protocol_body()
        localctx = SwiftParser::Protocol_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 216, SwiftParser.RULE_protocol_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1135
             match(SwiftParser::T__84)
            self.state = 1137
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__76) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__52) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 69)) & ~0x3f) == 0  and ((1 << (_la - 69)) & ((1 << (self.T__24 - 69)) | (1 << (self.T__22 - 69)) | (1 << (self.T__21 - 69)) | (1 << (self.T__4 - 69)) | (1 << (self.T__1 - 69)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1136 
                self.protocol_member_declarations()
            end #LL1OptionalBlockSingleAlt

            self.state = 1139
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_member_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_subscript_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_subscript_declarationContext,0)
        end


        def protocol_method_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_method_declarationContext,0)
        end


        def protocol_property_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_property_declarationContext,0)
        end


        def protocol_initializer_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_initializer_declarationContext,0)
        end


        def protocol_associated_type_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_associated_type_declarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_member_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_member_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_member_declaration(self)
            end
        end
    end


    def protocol_member_declaration()
        localctx = SwiftParser::Protocol_member_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 218, SwiftParser.RULE_protocol_member_declaration)
        begin
            self.state = 1146
            la_ = self.interp.adaptivePredict(self.input,122,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1141 
                self.protocol_property_declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1142 
                self.protocol_method_declaration()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1143 
                self.protocol_initializer_declaration()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1144 
                self.protocol_subscript_declaration()

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 1145 
                self.protocol_associated_type_declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_member_declarationsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_member_declaration() 
            getTypedRuleContext(SwiftParser::Protocol_member_declarationContext,0)
        end


        def protocol_member_declarations() 
            getTypedRuleContext(SwiftParser::Protocol_member_declarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_member_declarations
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_member_declarations(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_member_declarations(self)
            end
        end
    end


    def protocol_member_declarations()
        localctx = SwiftParser::Protocol_member_declarationsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 220, SwiftParser.RULE_protocol_member_declarations)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1148 
            self.protocol_member_declaration()
            self.state = 1150
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__76) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__57) | (1 << self.T__52) | (1 << self.T__44) | (1 << self.T__30))) != 0) or ((((_la - 69)) & ~0x3f) == 0  and ((1 << (_la - 69)) & ((1 << (self.T__24 - 69)) | (1 << (self.T__22 - 69)) | (1 << (self.T__21 - 69)) | (1 << (self.T__4 - 69)) | (1 << (self.T__1 - 69)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1149 
                self.protocol_member_declarations()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_property_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def variable_declaration_head() 
            getTypedRuleContext(SwiftParser::Variable_declaration_headContext,0)
        end


        def variable_name() 
            getTypedRuleContext(SwiftParser::Variable_nameContext,0)
        end


        def getter_setter_keyword_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_keyword_blockContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_property_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_property_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_property_declaration(self)
            end
        end
    end


    def protocol_property_declaration()
        localctx = SwiftParser::Protocol_property_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 222, SwiftParser.RULE_protocol_property_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1152 
            self.variable_declaration_head()
            self.state = 1153 
            self.variable_name()
            self.state = 1154 
            self.type_annotation()
            self.state = 1155 
            self.getter_setter_keyword_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_method_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def function_head() 
            getTypedRuleContext(SwiftParser::Function_headContext,0)
        end


        def function_name() 
            getTypedRuleContext(SwiftParser::Function_nameContext,0)
        end


        def function_signature() 
            getTypedRuleContext(SwiftParser::Function_signatureContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_method_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_method_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_method_declaration(self)
            end
        end
    end


    def protocol_method_declaration()
        localctx = SwiftParser::Protocol_method_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 224, SwiftParser.RULE_protocol_method_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1157 
            self.function_head()
            self.state = 1158 
            self.function_name()
            self.state = 1160
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1159 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1162 
            self.function_signature()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_initializer_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def initializer_head() 
            getTypedRuleContext(SwiftParser::Initializer_headContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_initializer_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_initializer_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_initializer_declaration(self)
            end
        end
    end


    def protocol_initializer_declaration()
        localctx = SwiftParser::Protocol_initializer_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 226, SwiftParser.RULE_protocol_initializer_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1164 
            self.initializer_head()
            self.state = 1166
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1165 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1168 
            self.parameter_clause()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_subscript_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def subscript_result() 
            getTypedRuleContext(SwiftParser::Subscript_resultContext,0)
        end


        def getter_setter_keyword_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_keyword_blockContext,0)
        end


        def subscript_head() 
            getTypedRuleContext(SwiftParser::Subscript_headContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_subscript_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_subscript_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_subscript_declaration(self)
            end
        end
    end


    def protocol_subscript_declaration()
        localctx = SwiftParser::Protocol_subscript_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 228, SwiftParser.RULE_protocol_subscript_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1170 
            self.subscript_head()
            self.state = 1171 
            self.subscript_result()
            self.state = 1172 
            self.getter_setter_keyword_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_associated_type_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def typealias_head() 
            getTypedRuleContext(SwiftParser::Typealias_headContext,0)
        end


        def typealias_assignment() 
            getTypedRuleContext(SwiftParser::Typealias_assignmentContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_associated_type_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_associated_type_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_associated_type_declaration(self)
            end
        end
    end


    def protocol_associated_type_declaration()
        localctx = SwiftParser::Protocol_associated_type_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 230, SwiftParser.RULE_protocol_associated_type_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1174 
            self.typealias_head()
            self.state = 1176
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1175 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1179
            _la = self.input.LA(1)
            if _la==SwiftParser.T__82 then  # Ll1Optional Bloc Single Alt
                self.state = 1178 
                self.typealias_assignment()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Initializer_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def generic_parameter_clause() 
            getTypedRuleContext(SwiftParser::Generic_parameter_clauseContext,0)
        end


        def initializer_head() 
            getTypedRuleContext(SwiftParser::Initializer_headContext,0)
        end


        def initializer_body() 
            getTypedRuleContext(SwiftParser::Initializer_bodyContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_initializer_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInitializer_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInitializer_declaration(self)
            end
        end
    end


    def initializer_declaration()
        localctx = SwiftParser::Initializer_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 232, SwiftParser.RULE_initializer_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1181 
            self.initializer_head()
            self.state = 1183
            _la = self.input.LA(1)
            if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                self.state = 1182 
                self.generic_parameter_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1185 
            self.parameter_clause()
            self.state = 1186 
            self.initializer_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Initializer_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_initializer_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInitializer_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInitializer_head(self)
            end
        end
    end


    def initializer_head()
        localctx = SwiftParser::Initializer_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 234, SwiftParser.RULE_initializer_head)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1189
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1188 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1192
            _la = self.input.LA(1)
            if _la==SwiftParser.T__24 then  # Ll1Optional Bloc Single Alt
                self.state = 1191
                 match(SwiftParser::T__24)
            end #LL1OptionalBlockSingleAlt

            self.state = 1194
             match(SwiftParser::T__67)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Initializer_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_initializer_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInitializer_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInitializer_body(self)
            end
        end
    end


    def initializer_body()
        localctx = SwiftParser::Initializer_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 236, SwiftParser.RULE_initializer_body)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1196 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Deinitializer_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_deinitializer_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDeinitializer_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDeinitializer_declaration(self)
            end
        end
    end


    def deinitializer_declaration()
        localctx = SwiftParser::Deinitializer_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 238, SwiftParser.RULE_deinitializer_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1199
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1198 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1201
             match(SwiftParser::T__49)
            self.state = 1202 
            self.code_block()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Extension_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def extension_body() 
            getTypedRuleContext(SwiftParser::Extension_bodyContext,0)
        end


        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def type_inheritance_clause() 
            getTypedRuleContext(SwiftParser::Type_inheritance_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_extension_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExtension_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExtension_declaration(self)
            end
        end
    end


    def extension_declaration()
        localctx = SwiftParser::Extension_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 240, SwiftParser.RULE_extension_declaration)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1204
             match(SwiftParser::T__65)
            self.state = 1205 
            self.type_identifier()
            self.state = 1207
            _la = self.input.LA(1)
            if _la==SwiftParser.T__20 then  # Ll1Optional Bloc Single Alt
                self.state = 1206 
                self.type_inheritance_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1209 
            self.extension_body()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Extension_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def declarations() 
            getTypedRuleContext(SwiftParser::DeclarationsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_extension_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExtension_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExtension_body(self)
            end
        end
    end


    def extension_body()
        localctx = SwiftParser::Extension_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 242, SwiftParser.RULE_extension_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1211
             match(SwiftParser::T__84)
            self.state = 1213
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__91) | (1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__65) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__55) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__44) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__24 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.T__1 - 68)) | (1 << (self.T__0 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1212 
                self.declarations()
            end #LL1OptionalBlockSingleAlt

            self.state = 1215
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Subscript_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def subscript_result() 
            getTypedRuleContext(SwiftParser::Subscript_resultContext,0)
        end


        def code_block() 
            getTypedRuleContext(SwiftParser::Code_blockContext,0)
        end


        def getter_setter_keyword_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_keyword_blockContext,0)
        end


        def subscript_head() 
            getTypedRuleContext(SwiftParser::Subscript_headContext,0)
        end


        def getter_setter_block() 
            getTypedRuleContext(SwiftParser::Getter_setter_blockContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_subscript_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSubscript_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSubscript_declaration(self)
            end
        end
    end


    def subscript_declaration()
        localctx = SwiftParser::Subscript_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 244, SwiftParser.RULE_subscript_declaration)
        begin
            self.state = 1229
            la_ = self.interp.adaptivePredict(self.input,134,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1217 
                self.subscript_head()
                self.state = 1218 
                self.subscript_result()
                self.state = 1219 
                self.code_block()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1221 
                self.subscript_head()
                self.state = 1222 
                self.subscript_result()
                self.state = 1223 
                self.getter_setter_block()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1225 
                self.subscript_head()
                self.state = 1226 
                self.subscript_result()
                self.state = 1227 
                self.getter_setter_keyword_block()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Subscript_headContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_subscript_head
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSubscript_head(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSubscript_head(self)
            end
        end
    end


    def subscript_head()
        localctx = SwiftParser::Subscript_headContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 246, SwiftParser.RULE_subscript_head)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1232
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1231 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1234
             match(SwiftParser::T__52)
            self.state = 1235 
            self.parameter_clause()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Subscript_resultContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_subscript_result
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSubscript_result(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSubscript_result(self)
            end
        end
    end


    def subscript_result()
        localctx = SwiftParser::Subscript_resultContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 248, SwiftParser.RULE_subscript_result)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1237
             match(SwiftParser::T__28)
            self.state = 1239
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1238 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1241 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Operator_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def postfix_operator_declaration() 
            getTypedRuleContext(SwiftParser::Postfix_operator_declarationContext,0)
        end


        def infix_operator_declaration() 
            getTypedRuleContext(SwiftParser::Infix_operator_declarationContext,0)
        end


        def prefix_operator_declaration() 
            getTypedRuleContext(SwiftParser::Prefix_operator_declarationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_operator_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterOperator_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitOperator_declaration(self)
            end
        end
    end


    def operator_declaration()
        localctx = SwiftParser::Operator_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 250, SwiftParser.RULE_operator_declaration)
        begin
            self.state = 1246
            la_ = self.interp.adaptivePredict(self.input,137,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1243 
                self.prefix_operator_declaration()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1244 
                self.postfix_operator_declaration()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1245 
                self.infix_operator_declaration()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Prefix_operator_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_prefix_operator_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrefix_operator_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrefix_operator_declaration(self)
            end
        end
    end


    def prefix_operator_declaration()
        localctx = SwiftParser::Prefix_operator_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 252, SwiftParser.RULE_prefix_operator_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1248
             match(SwiftParser::T__88)
            self.state = 1249
             match(SwiftParser::T__2)
            self.state = 1250
             match(SwiftParser::T__88)
            self.state = 1251
             match(SwiftParser::T__84)
            self.state = 1252
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Postfix_operator_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_postfix_operator_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPostfix_operator_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPostfix_operator_declaration(self)
            end
        end
    end


    def postfix_operator_declaration()
        localctx = SwiftParser::Postfix_operator_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 254, SwiftParser.RULE_postfix_operator_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1254
             match(SwiftParser::T__88)
            self.state = 1255
             match(SwiftParser::T__79)
            self.state = 1256
             match(SwiftParser::T__88)
            self.state = 1257
             match(SwiftParser::T__84)
            self.state = 1258
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Infix_operator_declarationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def infix_operator_attributes() 
            getTypedRuleContext(SwiftParser::Infix_operator_attributesContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_infix_operator_declaration
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInfix_operator_declaration(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInfix_operator_declaration(self)
            end
        end
    end


    def infix_operator_declaration()
        localctx = SwiftParser::Infix_operator_declarationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 256, SwiftParser.RULE_infix_operator_declaration)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1260
             match(SwiftParser::T__88)
            self.state = 1261
             match(SwiftParser::T__55)
            self.state = 1262
             match(SwiftParser::T__88)
            self.state = 1263
             match(SwiftParser::T__84)
            self.state = 1264 
            self.infix_operator_attributes()
            self.state = 1265
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Infix_operator_attributesContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def precedence_clause() 
            getTypedRuleContext(SwiftParser::Precedence_clauseContext,0)
        end


        def associativity_clause() 
            getTypedRuleContext(SwiftParser::Associativity_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_infix_operator_attributes
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInfix_operator_attributes(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInfix_operator_attributes(self)
            end
        end
    end


    def infix_operator_attributes()
        localctx = SwiftParser::Infix_operator_attributesContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 258, SwiftParser.RULE_infix_operator_attributes)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1268
            _la = self.input.LA(1)
            if _la==SwiftParser.T__86 then  # Ll1Optional Bloc Single Alt
                self.state = 1267 
                self.precedence_clause()
            end #LL1OptionalBlockSingleAlt

            self.state = 1271
            _la = self.input.LA(1)
            if _la==SwiftParser.T__89 then  # Ll1Optional Bloc Single Alt
                self.state = 1270 
                self.associativity_clause()
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Precedence_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def precedence_level() 
            getTypedRuleContext(SwiftParser::Precedence_levelContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_precedence_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrecedence_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrecedence_clause(self)
            end
        end
    end


    def precedence_clause()
        localctx = SwiftParser::Precedence_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 260, SwiftParser.RULE_precedence_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1273
             match(SwiftParser::T__86)
            self.state = 1274 
            self.precedence_level()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Precedence_levelContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def integer_literal() 
            getTypedRuleContext(SwiftParser::Integer_literalContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_precedence_level
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrecedence_level(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrecedence_level(self)
            end
        end
    end


    def precedence_level()
        localctx = SwiftParser::Precedence_levelContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 262, SwiftParser.RULE_precedence_level)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1276 
            self.integer_literal()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Associativity_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def associativity() 
            getTypedRuleContext(SwiftParser::AssociativityContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_associativity_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAssociativity_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAssociativity_clause(self)
            end
        end
    end


    def associativity_clause()
        localctx = SwiftParser::Associativity_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 264, SwiftParser.RULE_associativity_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1278
             match(SwiftParser::T__89)
            self.state = 1279 
            self.associativity()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class AssociativityContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_associativity
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAssociativity(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAssociativity(self)
            end
        end
    end


    def associativity()
        localctx = SwiftParser::AssociativityContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 266, SwiftParser.RULE_associativity)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1281
            _la = self.input.LA(1)
            if not (((((_la - 18)) & ~0x3f) == 0  and ((1 << (_la - 18)) & ((1 << (self.T__75 - 18)) | (1 << (self.T__71 - 18)) | (1 << (self.T__25 - 18)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator

    class PatternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def enum_case_pattern() 
            getTypedRuleContext(SwiftParser::Enum_case_patternContext,0)
        end


        def expression_pattern() 
            getTypedRuleContext(SwiftParser::Expression_patternContext,0)
        end


        def tuple_pattern() 
            getTypedRuleContext(SwiftParser::Tuple_patternContext,0)
        end


        def value_binding_pattern() 
            getTypedRuleContext(SwiftParser::Value_binding_patternContext,0)
        end


        def wildcard_pattern() 
            getTypedRuleContext(SwiftParser::Wildcard_patternContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def identifier_pattern() 
            getTypedRuleContext(SwiftParser::Identifier_patternContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPattern(self)
            end
        end
    end

    def pattern(_p=0)
        _parentctx = self.ctx
        _parentState = self.state
        localctx = SwiftParser::PatternContext.new(self, self.ctx, _parentState)
        _prevctx = localctx
        _startState = 268
        self.enterRecursionRule(localctx, 268, SwiftParser.RULE_pattern, _p)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1301
            la_ = self.interp.adaptivePredict(self.input,143,self.ctx)
            if la_ == 1 then
                self.state = 1284 
                self.wildcard_pattern()
                self.state = 1286
                la_ = self.interp.adaptivePredict(self.input,140,self.ctx)
                if la_ == 1
                    self.state = 1285 
                    self.type_annotation()

                end

            elsif la_ == 2 then
                self.state = 1288 
                self.identifier_pattern()
                self.state = 1290
                la_ = self.interp.adaptivePredict(self.input,141,self.ctx)
                if la_ == 1
                    self.state = 1289 
                    self.type_annotation()

                end

            elsif la_ == 3 then
                self.state = 1292 
                self.value_binding_pattern()

            elsif la_ == 4 then
                self.state = 1293 
                self.tuple_pattern()
                self.state = 1295
                la_ = self.interp.adaptivePredict(self.input,142,self.ctx)
                if la_ == 1
                    self.state = 1294 
                    self.type_annotation()

                end

            elsif la_ == 5 then
                self.state = 1297 
                self.enum_case_pattern()

            elsif la_ == 6 then
                self.state = 1298
                 match(SwiftParser::T__34)
                self.state = 1299 
                self.type(0)

            elsif la_ == 7 then
                self.state = 1300 
                self.expression_pattern()

            end
            self.ctx.stop = self.input.LT(-1)
            self.state = 1308
            self.errHandler.sync(self)
            _alt = self.interp.adaptivePredict(self.input,144,self.ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER do
                if _alt==1 then
                    if self.parseListeners  then 
                        self.triggerExitRuleEvent()
                    end
                    _prevctx = localctx
                    localctx = SwiftParser::PatternContext.new(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_pattern)
                    self.state = 1303
                    if not (self.precpred(self.ctx, 2)) then
                        raise FailedPredicateException.new(self, "self.precpred(self.ctx, 2)")
                    end
                    self.state = 1304
                     match(SwiftParser::T__48)
                    self.state = 1305 
                    self.type(0) 
                end
                self.state = 1310
                self.errHandler.sync(self)
                _alt = self.interp.adaptivePredict(self.input,144,self.ctx)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure
            self.unrollRecursionContexts(_parentctx)
        end
        return localctx
    end
    # RuleFucntion generator
    class Wildcard_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_wildcard_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWildcard_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWildcard_pattern(self)
            end
        end
    end


    def wildcard_pattern()
        localctx = SwiftParser::Wildcard_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 270, SwiftParser.RULE_wildcard_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1311
             match(SwiftParser::T__15)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Identifier_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_identifier_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIdentifier_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIdentifier_pattern(self)
            end
        end
    end


    def identifier_pattern()
        localctx = SwiftParser::Identifier_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 272, SwiftParser.RULE_identifier_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1313 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Value_binding_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_value_binding_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterValue_binding_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitValue_binding_pattern(self)
            end
        end
    end


    def value_binding_pattern()
        localctx = SwiftParser::Value_binding_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 274, SwiftParser.RULE_value_binding_pattern)
        begin
            self.state = 1319
            token = self.input.LA(1)
            if [self.T__68].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1315
                 match(SwiftParser::T__68)
                self.state = 1316 
                self.pattern(0)

            elsif [self.T__58].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1317
                 match(SwiftParser::T__58)
                self.state = 1318 
                self.pattern(0)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_pattern_element_list() 
            getTypedRuleContext(SwiftParser::Tuple_pattern_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_pattern(self)
            end
        end
    end


    def tuple_pattern()
        localctx = SwiftParser::Tuple_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 276, SwiftParser.RULE_tuple_pattern)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1321
             match(SwiftParser::T__74)
            self.state = 1323
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__68) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__58) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__34) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1322 
                self.tuple_pattern_element_list()
            end #LL1OptionalBlockSingleAlt

            self.state = 1325
             match(SwiftParser::T__5)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_pattern_element_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_pattern_element(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Tuple_pattern_elementContext)
            else
                getTypedRuleContext(SwiftParser::Tuple_pattern_elementContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_pattern_element_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_pattern_element_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_pattern_element_list(self)
            end
        end
    end


    def tuple_pattern_element_list()
        localctx = SwiftParser::Tuple_pattern_element_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 278, SwiftParser.RULE_tuple_pattern_element_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1327 
            self.tuple_pattern_element()
            self.state = 1332
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 1328
                 match(SwiftParser::T__72)
                self.state = 1329 
                self.tuple_pattern_element()
                self.state = 1334
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_pattern_elementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_pattern_element
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_pattern_element(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_pattern_element(self)
            end
        end
    end


    def tuple_pattern_element()
        localctx = SwiftParser::Tuple_pattern_elementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 280, SwiftParser.RULE_tuple_pattern_element)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1335 
            self.pattern(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Enum_case_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def tuple_pattern() 
            getTypedRuleContext(SwiftParser::Tuple_patternContext,0)
        end


        def enum_case_name() 
            getTypedRuleContext(SwiftParser::Enum_case_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_enum_case_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterEnum_case_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitEnum_case_pattern(self)
            end
        end
    end


    def enum_case_pattern()
        localctx = SwiftParser::Enum_case_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 282, SwiftParser.RULE_enum_case_pattern)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1338
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1337 
                self.type_identifier()
            end #LL1OptionalBlockSingleAlt

            self.state = 1340
             match(SwiftParser::T__29)
            self.state = 1341 
            self.enum_case_name()
            self.state = 1343
            la_ = self.interp.adaptivePredict(self.input,149,self.ctx)
            if la_ == 1
                self.state = 1342 
                self.tuple_pattern()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_casting_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def is_pattern() 
            getTypedRuleContext(SwiftParser::Is_patternContext,0)
        end


        def as_pattern() 
            getTypedRuleContext(SwiftParser::As_patternContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_casting_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_casting_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_casting_pattern(self)
            end
        end
    end


    def type_casting_pattern()
        localctx = SwiftParser::Type_casting_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 284, SwiftParser.RULE_type_casting_pattern)
        begin
            self.state = 1347
            la_ = self.interp.adaptivePredict(self.input,150,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1345 
                self.is_pattern()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1346 
                self.as_pattern()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Is_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_is_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIs_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIs_pattern(self)
            end
        end
    end


    def is_pattern()
        localctx = SwiftParser::Is_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 286, SwiftParser.RULE_is_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1349
             match(SwiftParser::T__34)
            self.state = 1350 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class As_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def pattern() 
            getTypedRuleContext(SwiftParser::PatternContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_as_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAs_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAs_pattern(self)
            end
        end
    end


    def as_pattern()
        localctx = SwiftParser::As_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 288, SwiftParser.RULE_as_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1352 
            self.pattern(0)
            self.state = 1353
             match(SwiftParser::T__48)
            self.state = 1354 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Expression_patternContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression_pattern
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression_pattern(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression_pattern(self)
            end
        end
    end


    def expression_pattern()
        localctx = SwiftParser::Expression_patternContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 290, SwiftParser.RULE_expression_pattern)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1356 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class AttributeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attribute_argument_clause() 
            getTypedRuleContext(SwiftParser::Attribute_argument_clauseContext,0)
        end


        def attribute_name() 
            getTypedRuleContext(SwiftParser::Attribute_nameContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_attribute
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAttribute(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAttribute(self)
            end
        end
    end


    def attribute()
        localctx = SwiftParser::AttributeContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 292, SwiftParser.RULE_attribute)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1358
             match(SwiftParser::T__61)
            self.state = 1359 
            self.attribute_name()
            self.state = 1361
            la_ = self.interp.adaptivePredict(self.input,151,self.ctx)
            if la_ == 1
                self.state = 1360 
                self.attribute_argument_clause()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Attribute_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_attribute_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAttribute_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAttribute_name(self)
            end
        end
    end


    def attribute_name()
        localctx = SwiftParser::Attribute_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 294, SwiftParser.RULE_attribute_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1363 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Attribute_argument_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def balanced_tokens() 
            getTypedRuleContext(SwiftParser::Balanced_tokensContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_attribute_argument_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAttribute_argument_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAttribute_argument_clause(self)
            end
        end
    end


    def attribute_argument_clause()
        localctx = SwiftParser::Attribute_argument_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 296, SwiftParser.RULE_attribute_argument_clause)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1365
             match(SwiftParser::T__74)
            self.state = 1367
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1366 
                self.balanced_tokens()
            end #LL1OptionalBlockSingleAlt

            self.state = 1369
             match(SwiftParser::T__5)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class AttributesContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attribute(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::AttributeContext)
            else
                getTypedRuleContext(SwiftParser::AttributeContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_attributes
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAttributes(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAttributes(self)
            end
        end
    end


    def attributes()
        localctx = SwiftParser::AttributesContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 298, SwiftParser.RULE_attributes)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1372 
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            # Trying to use Rubyism. This will probably break
            begin  # while true do
                self.state = 1371 
                self.attribute()
                self.state = 1374 
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            #    if not (_la==SwiftParser.T__61) then
            #        break
            #    end
            end until not (_la==SwiftParser.T__61)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Balanced_tokensContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def balanced_token(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Balanced_tokenContext)
            else
                getTypedRuleContext(SwiftParser::Balanced_tokenContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_balanced_tokens
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBalanced_tokens(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBalanced_tokens(self)
            end
        end
    end


    def balanced_tokens()
        localctx = SwiftParser::Balanced_tokensContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 300, SwiftParser.RULE_balanced_tokens)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1377 
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            # Trying to use Rubyism. This will probably break
            begin  # while true do
                self.state = 1376 
                self.balanced_token()
                self.state = 1379 
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            #    if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0)) then
            #        break
            #    end
            end until not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0))
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Balanced_tokenContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def balanced_tokens() 
            getTypedRuleContext(SwiftParser::Balanced_tokensContext,0)
        end


        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def literal() 
            getTypedRuleContext(SwiftParser::LiteralContext,0)
        end


        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def context_sensitive_keyword() 
            getTypedRuleContext(SwiftParser::Context_sensitive_keywordContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_balanced_token
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBalanced_token(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBalanced_token(self)
            end
        end
    end


    def balanced_token()
        localctx = SwiftParser::Balanced_tokenContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 302, SwiftParser.RULE_balanced_token)
        _la = 0 # Token type
        begin
            self.state = 1401
            la_ = self.interp.adaptivePredict(self.input,158,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1381
                 match(SwiftParser::T__74)
                self.state = 1383
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 1382 
                    self.balanced_tokens()
                end #LL1OptionalBlockSingleAlt

                self.state = 1385
                 match(SwiftParser::T__5)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1386
                 match(SwiftParser::T__19)
                self.state = 1388
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 1387 
                    self.balanced_tokens()
                end #LL1OptionalBlockSingleAlt

                self.state = 1390
                 match(SwiftParser::T__63)

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1391
                 match(SwiftParser::T__84)
                self.state = 1393
                _la = self.input.LA(1)
                if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                    self.state = 1392 
                    self.balanced_tokens()
                end #LL1OptionalBlockSingleAlt

                self.state = 1395
                 match(SwiftParser::T__41)

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1396 
                self.identifier()

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 1397 
                self.expression(0)

            elsif la_ == 6 then
                self.enterOuterAlt(localctx, 6)
                self.state = 1398 
                self.context_sensitive_keyword()

            elsif la_ == 7 then
                self.enterOuterAlt(localctx, 7)
                self.state = 1399 
                self.literal()

            elsif la_ == 8 then
                self.enterOuterAlt(localctx, 8)
                self.state = 1400 
                self.operator()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Expression_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression_list(self)
            end
        end
    end


    def expression_list()
        localctx = SwiftParser::Expression_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 304, SwiftParser.RULE_expression_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1403 
            self.expression(0)
            self.state = 1408
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 1404
                 match(SwiftParser::T__72)
                self.state = 1405 
                self.expression(0)
                self.state = 1410
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator

    class ExpressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def postfix_operator() 
            getTypedRuleContext(SwiftParser::Postfix_operatorContext,0)
        end


        def expression_list() 
            getTypedRuleContext(SwiftParser::Expression_listContext,0)
        end


        def type_casting_operator() 
            getTypedRuleContext(SwiftParser::Type_casting_operatorContext,0)
        end


        def primary_expression() 
            getTypedRuleContext(SwiftParser::Primary_expressionContext,0)
        end


        def assignment_operator() 
            getTypedRuleContext(SwiftParser::Assignment_operatorContext,0)
        end


        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def in_out_expression() 
            getTypedRuleContext(SwiftParser::In_out_expressionContext,0)
        end


        def trailing_closure() 
            getTypedRuleContext(SwiftParser::Trailing_closureContext,0)
        end


        def prefix_operator() 
            getTypedRuleContext(SwiftParser::Prefix_operatorContext,0)
        end


        def binary_operator() 
            getTypedRuleContext(SwiftParser::Binary_operatorContext,0)
        end


        def parenthesized_expression() 
            getTypedRuleContext(SwiftParser::Parenthesized_expressionContext,0)
        end


        def generic_argument_clause() 
            getTypedRuleContext(SwiftParser::Generic_argument_clauseContext,0)
        end


        def conditional_operator() 
            getTypedRuleContext(SwiftParser::Conditional_operatorContext,0)
        end


        def Decimal_literal()
            getToken(SwiftParser::Decimal_literal, 0)
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression(self)
            end
        end
    end

    def expression(_p=0)
        _parentctx = self.ctx
        _parentState = self.state
        localctx = SwiftParser::ExpressionContext.new(self, self.ctx, _parentState)
        _prevctx = localctx
        _startState = 306
        self.enterRecursionRule(localctx, 306, SwiftParser.RULE_expression, _p)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1417
            la_ = self.interp.adaptivePredict(self.input,160,self.ctx)
            if la_ == 1 then
                self.state = 1412 
                self.prefix_operator()
                self.state = 1413 
                self.expression(17)

            elsif la_ == 2 then
                self.state = 1415 
                self.in_out_expression()

            elsif la_ == 3 then
                self.state = 1416 
                self.primary_expression()

            end
            self.ctx.stop = self.input.LT(-1)
            self.state = 1469
            self.errHandler.sync(self)
            _alt = self.interp.adaptivePredict(self.input,164,self.ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER do
                if _alt==1 then
                    if self.parseListeners  then 
                        self.triggerExitRuleEvent()
                    end
                    _prevctx = localctx
                    self.state = 1467
                    la_ = self.interp.adaptivePredict(self.input,163,self.ctx)
                    if la_ == 1 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1419
                        if not (self.precpred(self.ctx, 14)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 14)")
                        end
                        self.state = 1420 
                        self.binary_operator()
                        self.state = 1421 
                        self.expression(15)

                    elsif la_ == 2 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1423
                        if not (self.precpred(self.ctx, 13)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 13)")
                        end
                        self.state = 1424 
                        self.assignment_operator()
                        self.state = 1425 
                        self.expression(14)

                    elsif la_ == 3 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1427
                        if not (self.precpred(self.ctx, 12)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 12)")
                        end
                        self.state = 1428 
                        self.conditional_operator()
                        self.state = 1429 
                        self.expression(13)

                    elsif la_ == 4 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1431
                        if not (self.precpred(self.ctx, 11)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 11)")
                        end
                        self.state = 1432 
                        self.type_casting_operator()

                    elsif la_ == 5 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1433
                        if not (self.precpred(self.ctx, 10)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 10)")
                        end
                        self.state = 1434 
                        self.postfix_operator()

                    elsif la_ == 6 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1435
                        if not (self.precpred(self.ctx, 9)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 9)")
                        end
                        self.state = 1436 
                        self.parenthesized_expression()
                        self.state = 1438
                        la_ = self.interp.adaptivePredict(self.input,161,self.ctx)
                        if la_ == 1
                            self.state = 1437 
                            self.trailing_closure()

                        end

                    elsif la_ == 7 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1440
                        if not (self.precpred(self.ctx, 8)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 8)")
                        end
                        self.state = 1441
                         match(SwiftParser::T__29)
                        self.state = 1442
                         match(SwiftParser::T__67)

                    elsif la_ == 8 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1443
                        if not (self.precpred(self.ctx, 7)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 7)")
                        end
                        self.state = 1444
                         match(SwiftParser::T__29)
                        self.state = 1445
                         match(SwiftParser::Decimal_literal)

                    elsif la_ == 9 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1446
                        if not (self.precpred(self.ctx, 6)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 6)")
                        end
                        self.state = 1447
                         match(SwiftParser::T__29)
                        self.state = 1448 
                        self.identifier()
                        self.state = 1450
                        la_ = self.interp.adaptivePredict(self.input,162,self.ctx)
                        if la_ == 1
                            self.state = 1449 
                            self.generic_argument_clause()

                        end

                    elsif la_ == 10 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1452
                        if not (self.precpred(self.ctx, 5)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 5)")
                        end
                        self.state = 1453
                         match(SwiftParser::T__29)
                        self.state = 1454
                         match(SwiftParser::T__6)

                    elsif la_ == 11 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1455
                        if not (self.precpred(self.ctx, 4)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 4)")
                        end
                        self.state = 1456
                         match(SwiftParser::T__29)
                        self.state = 1457
                         match(SwiftParser::T__66)

                    elsif la_ == 12 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1458
                        if not (self.precpred(self.ctx, 3)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 3)")
                        end
                        self.state = 1459
                         match(SwiftParser::T__19)
                        self.state = 1460 
                        self.expression_list()
                        self.state = 1461
                         match(SwiftParser::T__63)

                    elsif la_ == 13 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1463
                        if not (self.precpred(self.ctx, 2)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 2)")
                        end
                        self.state = 1464
                         match(SwiftParser::T__12)

                    elsif la_ == 14 then
                        localctx = SwiftParser::ExpressionContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_expression)
                        self.state = 1465
                        if not (self.precpred(self.ctx, 1)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 1)")
                        end
                        self.state = 1466
                         match(SwiftParser::T__39)

                    end 
                end
                self.state = 1471
                self.errHandler.sync(self)
                _alt = self.interp.adaptivePredict(self.input,164,self.ctx)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure
            self.unrollRecursionContexts(_parentctx)
        end
        return localctx
    end
    # RuleFucntion generator
    class In_out_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_in_out_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIn_out_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIn_out_expression(self)
            end
        end
    end


    def in_out_expression()
        localctx = SwiftParser::In_out_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 308, SwiftParser.RULE_in_out_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1472
             match(SwiftParser::T__36)
            self.state = 1473 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Assignment_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_assignment_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterAssignment_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitAssignment_operator(self)
            end
        end
    end


    def assignment_operator()
        localctx = SwiftParser::Assignment_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 310, SwiftParser.RULE_assignment_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1475
             match(SwiftParser::T__82)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Conditional_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_conditional_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterConditional_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitConditional_operator(self)
            end
        end
    end


    def conditional_operator()
        localctx = SwiftParser::Conditional_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 312, SwiftParser.RULE_conditional_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1477
             match(SwiftParser::T__39)
            self.state = 1478 
            self.expression(0)
            self.state = 1479
             match(SwiftParser::T__20)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_casting_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_casting_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_casting_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_casting_operator(self)
            end
        end
    end


    def type_casting_operator()
        localctx = SwiftParser::Type_casting_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 314, SwiftParser.RULE_type_casting_operator)
        _la = 0 # Token type
        begin
            self.state = 1488
            token = self.input.LA(1)
            if [self.T__34].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1481
                 match(SwiftParser::T__34)
                self.state = 1482 
                self.type(0)

            elsif [self.T__48].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1483
                 match(SwiftParser::T__48)
                self.state = 1485
                _la = self.input.LA(1)
                if _la==SwiftParser.T__39 then  # Ll1Optional Bloc Single Alt
                    self.state = 1484
                     match(SwiftParser::T__39)
                end #LL1OptionalBlockSingleAlt

                self.state = 1487 
                self.type(0)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Trailing_closureContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def closure_expression() 
            getTypedRuleContext(SwiftParser::Closure_expressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_trailing_closure
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTrailing_closure(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTrailing_closure(self)
            end
        end
    end


    def trailing_closure()
        localctx = SwiftParser::Trailing_closureContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 316, SwiftParser.RULE_trailing_closure)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1490 
            self.closure_expression()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Primary_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def self_expression() 
            getTypedRuleContext(SwiftParser::Self_expressionContext,0)
        end


        def superclass_expression() 
            getTypedRuleContext(SwiftParser::Superclass_expressionContext,0)
        end


        def parenthesized_expression() 
            getTypedRuleContext(SwiftParser::Parenthesized_expressionContext,0)
        end


        def wildcard_expression() 
            getTypedRuleContext(SwiftParser::Wildcard_expressionContext,0)
        end


        def generic_argument_clause() 
            getTypedRuleContext(SwiftParser::Generic_argument_clauseContext,0)
        end


        def closure_expression() 
            getTypedRuleContext(SwiftParser::Closure_expressionContext,0)
        end


        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def implicit_member_expression() 
            getTypedRuleContext(SwiftParser::Implicit_member_expressionContext,0)
        end


        def literal_expression() 
            getTypedRuleContext(SwiftParser::Literal_expressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_primary_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrimary_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrimary_expression(self)
            end
        end
    end


    def primary_expression()
        localctx = SwiftParser::Primary_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 318, SwiftParser.RULE_primary_expression)
        begin
            self.state = 1503
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1492 
                self.identifier()
                self.state = 1494
                la_ = self.interp.adaptivePredict(self.input,167,self.ctx)
                if la_ == 1
                    self.state = 1493 
                    self.generic_argument_clause()

                end

            elsif [self.T__77, self.T__69, self.T__62, self.T__23, self.T__19, self.Binary_literal, self.Octal_literal, self.Decimal_literal, self.Hexadecimal_literal, self.Floating_point_literal, self.String_literal].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1496 
                self.literal_expression()

            elsif [self.T__6].member? token then 
                self.enterOuterAlt(localctx, 3)
                self.state = 1497 
                self.self_expression()

            elsif [self.T__7].member? token then 
                self.enterOuterAlt(localctx, 4)
                self.state = 1498 
                self.superclass_expression()

            elsif [self.T__84].member? token then 
                self.enterOuterAlt(localctx, 5)
                self.state = 1499 
                self.closure_expression()

            elsif [self.T__74].member? token then 
                self.enterOuterAlt(localctx, 6)
                self.state = 1500 
                self.parenthesized_expression()

            elsif [self.T__29].member? token then 
                self.enterOuterAlt(localctx, 7)
                self.state = 1501 
                self.implicit_member_expression()

            elsif [self.T__15].member? token then 
                self.enterOuterAlt(localctx, 8)
                self.state = 1502 
                self.wildcard_expression()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Literal_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def array_literal() 
            getTypedRuleContext(SwiftParser::Array_literalContext,0)
        end


        def literal() 
            getTypedRuleContext(SwiftParser::LiteralContext,0)
        end


        def dictionary_literal() 
            getTypedRuleContext(SwiftParser::Dictionary_literalContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_literal_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLiteral_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLiteral_expression(self)
            end
        end
    end


    def literal_expression()
        localctx = SwiftParser::Literal_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 320, SwiftParser.RULE_literal_expression)
        begin
            self.state = 1512
            la_ = self.interp.adaptivePredict(self.input,169,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1505 
                self.literal()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1506 
                self.array_literal()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1507 
                self.dictionary_literal()

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1508
                 match(SwiftParser::T__69)

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 1509
                 match(SwiftParser::T__62)

            elsif la_ == 6 then
                self.enterOuterAlt(localctx, 6)
                self.state = 1510
                 match(SwiftParser::T__23)

            elsif la_ == 7 then
                self.enterOuterAlt(localctx, 7)
                self.state = 1511
                 match(SwiftParser::T__77)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Array_literalContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def array_literal_items() 
            getTypedRuleContext(SwiftParser::Array_literal_itemsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_array_literal
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterArray_literal(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitArray_literal(self)
            end
        end
    end


    def array_literal()
        localctx = SwiftParser::Array_literalContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 322, SwiftParser.RULE_array_literal)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1514
             match(SwiftParser::T__19)
            self.state = 1516
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1515 
                self.array_literal_items()
            end #LL1OptionalBlockSingleAlt

            self.state = 1518
             match(SwiftParser::T__63)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Array_literal_itemsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def array_literal_items() 
            getTypedRuleContext(SwiftParser::Array_literal_itemsContext,0)
        end


        def array_literal_item() 
            getTypedRuleContext(SwiftParser::Array_literal_itemContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_array_literal_items
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterArray_literal_items(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitArray_literal_items(self)
            end
        end
    end


    def array_literal_items()
        localctx = SwiftParser::Array_literal_itemsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 324, SwiftParser.RULE_array_literal_items)
        _la = 0 # Token type
        begin
            self.state = 1528
            la_ = self.interp.adaptivePredict(self.input,172,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1520 
                self.array_literal_item()
                self.state = 1522
                _la = self.input.LA(1)
                if _la==SwiftParser.T__72 then  # Ll1Optional Bloc Single Alt
                    self.state = 1521
                     match(SwiftParser::T__72)
                end #LL1OptionalBlockSingleAlt


            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1524 
                self.array_literal_item()
                self.state = 1525
                 match(SwiftParser::T__72)
                self.state = 1526 
                self.array_literal_items()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Array_literal_itemContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_array_literal_item
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterArray_literal_item(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitArray_literal_item(self)
            end
        end
    end


    def array_literal_item()
        localctx = SwiftParser::Array_literal_itemContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 326, SwiftParser.RULE_array_literal_item)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1530 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Dictionary_literalContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def dictionary_literal_items() 
            getTypedRuleContext(SwiftParser::Dictionary_literal_itemsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_dictionary_literal
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDictionary_literal(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDictionary_literal(self)
            end
        end
    end


    def dictionary_literal()
        localctx = SwiftParser::Dictionary_literalContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 328, SwiftParser.RULE_dictionary_literal)
        begin
            self.state = 1539
            la_ = self.interp.adaptivePredict(self.input,173,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1532
                 match(SwiftParser::T__19)
                self.state = 1533 
                self.dictionary_literal_items()
                self.state = 1534
                 match(SwiftParser::T__63)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1536
                 match(SwiftParser::T__19)
                self.state = 1537
                 match(SwiftParser::T__20)
                self.state = 1538
                 match(SwiftParser::T__63)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Dictionary_literal_itemsContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def dictionary_literal_item(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Dictionary_literal_itemContext)
            else
                getTypedRuleContext(SwiftParser::Dictionary_literal_itemContext,i)
            end
        end

        def dictionary_literal_items() 
            getTypedRuleContext(SwiftParser::Dictionary_literal_itemsContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_dictionary_literal_items
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDictionary_literal_items(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDictionary_literal_items(self)
            end
        end
    end


    def dictionary_literal_items()
        localctx = SwiftParser::Dictionary_literal_itemsContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 330, SwiftParser.RULE_dictionary_literal_items)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1541 
            self.dictionary_literal_item()
            self.state = 1543
            _la = self.input.LA(1)
            if _la==SwiftParser.T__72 then  # Ll1Optional Bloc Single Alt
                self.state = 1542
                 match(SwiftParser::T__72)
            end #LL1OptionalBlockSingleAlt

            self.state = 1545 
            self.dictionary_literal_item()
            self.state = 1546
             match(SwiftParser::T__72)
            self.state = 1547 
            self.dictionary_literal_items()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Dictionary_literal_itemContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::ExpressionContext)
            else
                getTypedRuleContext(SwiftParser::ExpressionContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_dictionary_literal_item
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterDictionary_literal_item(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitDictionary_literal_item(self)
            end
        end
    end


    def dictionary_literal_item()
        localctx = SwiftParser::Dictionary_literal_itemContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 332, SwiftParser.RULE_dictionary_literal_item)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1549 
            self.expression(0)
            self.state = 1550
             match(SwiftParser::T__20)
            self.state = 1551 
            self.expression(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Self_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_self_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSelf_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSelf_expression(self)
            end
        end
    end


    def self_expression()
        localctx = SwiftParser::Self_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 334, SwiftParser.RULE_self_expression)
        begin
            self.state = 1565
            la_ = self.interp.adaptivePredict(self.input,175,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1553
                 match(SwiftParser::T__6)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1554
                 match(SwiftParser::T__6)
                self.state = 1555
                 match(SwiftParser::T__29)
                self.state = 1556 
                self.identifier()

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1557
                 match(SwiftParser::T__6)
                self.state = 1558
                 match(SwiftParser::T__19)
                self.state = 1559 
                self.expression(0)
                self.state = 1560
                 match(SwiftParser::T__63)

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1562
                 match(SwiftParser::T__6)
                self.state = 1563
                 match(SwiftParser::T__29)
                self.state = 1564
                 match(SwiftParser::T__67)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Superclass_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def superclass_subscript_expression() 
            getTypedRuleContext(SwiftParser::Superclass_subscript_expressionContext,0)
        end


        def superclass_initializer_expression() 
            getTypedRuleContext(SwiftParser::Superclass_initializer_expressionContext,0)
        end


        def superclass_method_expression() 
            getTypedRuleContext(SwiftParser::Superclass_method_expressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_superclass_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSuperclass_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSuperclass_expression(self)
            end
        end
    end


    def superclass_expression()
        localctx = SwiftParser::Superclass_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 336, SwiftParser.RULE_superclass_expression)
        begin
            self.state = 1571
            la_ = self.interp.adaptivePredict(self.input,176,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1567 
                self.superclass_method_expression()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1568 
                self.superclass_subscript_expression()
                self.state = 1569 
                self.superclass_initializer_expression()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Superclass_method_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_superclass_method_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSuperclass_method_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSuperclass_method_expression(self)
            end
        end
    end


    def superclass_method_expression()
        localctx = SwiftParser::Superclass_method_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 338, SwiftParser.RULE_superclass_method_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1573
             match(SwiftParser::T__7)
            self.state = 1574
             match(SwiftParser::T__29)
            self.state = 1575 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Superclass_subscript_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_superclass_subscript_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSuperclass_subscript_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSuperclass_subscript_expression(self)
            end
        end
    end


    def superclass_subscript_expression()
        localctx = SwiftParser::Superclass_subscript_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 340, SwiftParser.RULE_superclass_subscript_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1577
             match(SwiftParser::T__7)
            self.state = 1578
             match(SwiftParser::T__19)
            self.state = 1579 
            self.expression(0)
            self.state = 1580
             match(SwiftParser::T__63)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Superclass_initializer_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_superclass_initializer_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterSuperclass_initializer_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitSuperclass_initializer_expression(self)
            end
        end
    end


    def superclass_initializer_expression()
        localctx = SwiftParser::Superclass_initializer_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 342, SwiftParser.RULE_superclass_initializer_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1582
             match(SwiftParser::T__7)
            self.state = 1583
             match(SwiftParser::T__29)
            self.state = 1584
             match(SwiftParser::T__67)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Closure_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def statements() 
            getTypedRuleContext(SwiftParser::StatementsContext,0)
        end


        def closure_signature() 
            getTypedRuleContext(SwiftParser::Closure_signatureContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_closure_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClosure_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClosure_expression(self)
            end
        end
    end


    def closure_expression()
        localctx = SwiftParser::Closure_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 344, SwiftParser.RULE_closure_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1586
             match(SwiftParser::T__84)
            self.state = 1588
            la_ = self.interp.adaptivePredict(self.input,177,self.ctx)
            if la_ == 1
                self.state = 1587 
                self.closure_signature()

            end
            self.state = 1590 
            self.statements()
            self.state = 1591
             match(SwiftParser::T__41)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Closure_signatureContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def capture_list() 
            getTypedRuleContext(SwiftParser::Capture_listContext,0)
        end


        def parameter_clause() 
            getTypedRuleContext(SwiftParser::Parameter_clauseContext,0)
        end


        def function_result() 
            getTypedRuleContext(SwiftParser::Function_resultContext,0)
        end


        def identifier_list() 
            getTypedRuleContext(SwiftParser::Identifier_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_closure_signature
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterClosure_signature(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitClosure_signature(self)
            end
        end
    end


    def closure_signature()
        localctx = SwiftParser::Closure_signatureContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 346, SwiftParser.RULE_closure_signature)
        _la = 0 # Token type
        begin
            self.state = 1622
            la_ = self.interp.adaptivePredict(self.input,182,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1593 
                self.parameter_clause()
                self.state = 1595
                _la = self.input.LA(1)
                if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                    self.state = 1594 
                    self.function_result()
                end #LL1OptionalBlockSingleAlt

                self.state = 1597
                 match(SwiftParser::T__8)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1599 
                self.identifier_list()
                self.state = 1601
                _la = self.input.LA(1)
                if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                    self.state = 1600 
                    self.function_result()
                end #LL1OptionalBlockSingleAlt

                self.state = 1603
                 match(SwiftParser::T__8)

            elsif la_ == 3 then
                self.enterOuterAlt(localctx, 3)
                self.state = 1605 
                self.capture_list()
                self.state = 1606 
                self.parameter_clause()
                self.state = 1608
                _la = self.input.LA(1)
                if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                    self.state = 1607 
                    self.function_result()
                end #LL1OptionalBlockSingleAlt

                self.state = 1610
                 match(SwiftParser::T__8)

            elsif la_ == 4 then
                self.enterOuterAlt(localctx, 4)
                self.state = 1612 
                self.capture_list()
                self.state = 1613 
                self.identifier_list()
                self.state = 1615
                _la = self.input.LA(1)
                if _la==SwiftParser.T__28 then  # Ll1Optional Bloc Single Alt
                    self.state = 1614 
                    self.function_result()
                end #LL1OptionalBlockSingleAlt

                self.state = 1617
                 match(SwiftParser::T__8)

            elsif la_ == 5 then
                self.enterOuterAlt(localctx, 5)
                self.state = 1619 
                self.capture_list()
                self.state = 1620
                 match(SwiftParser::T__8)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Capture_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def capture_specifier() 
            getTypedRuleContext(SwiftParser::Capture_specifierContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_capture_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCapture_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCapture_list(self)
            end
        end
    end


    def capture_list()
        localctx = SwiftParser::Capture_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 348, SwiftParser.RULE_capture_list)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1624
             match(SwiftParser::T__19)
            self.state = 1625 
            self.capture_specifier()
            self.state = 1626 
            self.expression(0)
            self.state = 1627
             match(SwiftParser::T__63)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Capture_specifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_capture_specifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterCapture_specifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitCapture_specifier(self)
            end
        end
    end


    def capture_specifier()
        localctx = SwiftParser::Capture_specifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 350, SwiftParser.RULE_capture_specifier)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1629
            _la = self.input.LA(1)
            if not (((((_la - 23)) & ~0x3f) == 0  and ((1 << (_la - 23)) & ((1 << (self.T__70 - 23)) | (1 << (self.T__60 - 23)) | (1 << (self.T__30 - 23)) | (1 << (self.T__22 - 23)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Implicit_member_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_implicit_member_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterImplicit_member_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitImplicit_member_expression(self)
            end
        end
    end


    def implicit_member_expression()
        localctx = SwiftParser::Implicit_member_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 352, SwiftParser.RULE_implicit_member_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1631
             match(SwiftParser::T__29)
            self.state = 1632 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Parenthesized_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression_element_list() 
            getTypedRuleContext(SwiftParser::Expression_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_parenthesized_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterParenthesized_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitParenthesized_expression(self)
            end
        end
    end


    def parenthesized_expression()
        localctx = SwiftParser::Parenthesized_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 354, SwiftParser.RULE_parenthesized_expression)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1634
             match(SwiftParser::T__74)
            self.state = 1636
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__84) | (1 << self.T__82) | (1 << self.T__81) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__77) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__69) | (1 << self.T__64) | (1 << self.T__62) | (1 << self.T__60) | (1 << self.T__56) | (1 << self.T__55) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__35) | (1 << self.T__32) | (1 << self.T__30))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__25 - 64)) | (1 << (self.T__23 - 64)) | (1 << (self.T__22 - 64)) | (1 << (self.T__21 - 64)) | (1 << (self.T__19 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__15 - 64)) | (1 << (self.T__14 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__7 - 64)) | (1 << (self.T__6 - 64)) | (1 << (self.T__4 - 64)) | (1 << (self.T__3 - 64)) | (1 << (self.T__2 - 64)) | (1 << (self.Identifier - 64)) | (1 << (self.Binary_literal - 64)) | (1 << (self.Octal_literal - 64)) | (1 << (self.Decimal_literal - 64)) | (1 << (self.Hexadecimal_literal - 64)) | (1 << (self.Floating_point_literal - 64)) | (1 << (self.String_literal - 64)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1635 
                self.expression_element_list()
            end #LL1OptionalBlockSingleAlt

            self.state = 1638
             match(SwiftParser::T__5)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Expression_element_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def expression_element() 
            getTypedRuleContext(SwiftParser::Expression_elementContext,0)
        end


        def expression_element_list() 
            getTypedRuleContext(SwiftParser::Expression_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression_element_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression_element_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression_element_list(self)
            end
        end
    end


    def expression_element_list()
        localctx = SwiftParser::Expression_element_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 356, SwiftParser.RULE_expression_element_list)
        begin
            self.state = 1645
            la_ = self.interp.adaptivePredict(self.input,184,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1640 
                self.expression_element()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1641 
                self.expression_element()
                self.state = 1642
                 match(SwiftParser::T__72)
                self.state = 1643 
                self.expression_element_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Expression_elementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def expression() 
            getTypedRuleContext(SwiftParser::ExpressionContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_expression_element
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterExpression_element(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitExpression_element(self)
            end
        end
    end


    def expression_element()
        localctx = SwiftParser::Expression_elementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 358, SwiftParser.RULE_expression_element)
        begin
            self.state = 1652
            la_ = self.interp.adaptivePredict(self.input,185,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1647 
                self.expression(0)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1648 
                self.identifier()
                self.state = 1649
                 match(SwiftParser::T__20)
                self.state = 1650 
                self.expression(0)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Wildcard_expressionContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_wildcard_expression
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterWildcard_expression(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitWildcard_expression(self)
            end
        end
    end


    def wildcard_expression()
        localctx = SwiftParser::Wildcard_expressionContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 360, SwiftParser.RULE_wildcard_expression)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1654
             match(SwiftParser::T__15)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class OperatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterOperator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitOperator(self)
            end
        end
    end


    def operator()
        localctx = SwiftParser::OperatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 362, SwiftParser.RULE_operator)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1656
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__82) | (1 << self.T__81) | (1 << self.T__64) | (1 << self.T__56) | (1 << self.T__51) | (1 << self.T__43) | (1 << self.T__36) | (1 << self.T__32))) != 0) or ((((_la - 64)) & ~0x3f) == 0  and ((1 << (_la - 64)) & ((1 << (self.T__29 - 64)) | (1 << (self.T__18 - 64)) | (1 << (self.T__16 - 64)) | (1 << (self.T__12 - 64)) | (1 << (self.T__10 - 64)) | (1 << (self.T__3 - 64)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Binary_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_binary_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterBinary_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitBinary_operator(self)
            end
        end
    end


    def binary_operator()
        localctx = SwiftParser::Binary_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 364, SwiftParser.RULE_binary_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1658 
            self.operator()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Prefix_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_prefix_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPrefix_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPrefix_operator(self)
            end
        end
    end


    def prefix_operator()
        localctx = SwiftParser::Prefix_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 366, SwiftParser.RULE_prefix_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1660 
            self.operator()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Postfix_operatorContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def operator() 
            getTypedRuleContext(SwiftParser::OperatorContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_postfix_operator
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterPostfix_operator(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitPostfix_operator(self)
            end
        end
    end


    def postfix_operator()
        localctx = SwiftParser::Postfix_operatorContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 368, SwiftParser.RULE_postfix_operator)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1662 
            self.operator()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator

    class TypeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def tuple_type() 
            getTypedRuleContext(SwiftParser::Tuple_typeContext,0)
        end


        def type(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::TypeContext)
            else
                getTypedRuleContext(SwiftParser::TypeContext,i)
            end
        end

        def protocol_composition_type() 
            getTypedRuleContext(SwiftParser::Protocol_composition_typeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType(self)
            end
        end
    end

    def type(_p=0)
        _parentctx = self.ctx
        _parentState = self.state
        localctx = SwiftParser::TypeContext.new(self, self.ctx, _parentState)
        _prevctx = localctx
        _startState = 370
        self.enterRecursionRule(localctx, 370, SwiftParser.RULE_type, _p)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1668
            token = self.input.LA(1)
            if [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2, self.Identifier].member? token then 
                self.state = 1665 
                self.type_identifier()

            elsif [self.T__74].member? token then 
                self.state = 1666 
                self.tuple_type()

            elsif [self.T__50].member? token then 
                self.state = 1667 
                self.protocol_composition_type()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

            self.ctx.stop = self.input.LT(-1)
            self.state = 1688
            self.errHandler.sync(self)
            _alt = self.interp.adaptivePredict(self.input,188,self.ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER do
                if _alt==1 then
                    if self.parseListeners  then 
                        self.triggerExitRuleEvent()
                    end
                    _prevctx = localctx
                    self.state = 1686
                    la_ = self.interp.adaptivePredict(self.input,187,self.ctx)
                    if la_ == 1 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1670
                        if not (self.precpred(self.ctx, 8)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 8)")
                        end
                        self.state = 1671
                         match(SwiftParser::T__28)
                        self.state = 1672 
                        self.type(9)

                    elsif la_ == 2 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1673
                        if not (self.precpred(self.ctx, 9)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 9)")
                        end
                        self.state = 1674
                         match(SwiftParser::T__19)
                        self.state = 1675
                         match(SwiftParser::T__63)

                    elsif la_ == 3 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1676
                        if not (self.precpred(self.ctx, 5)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 5)")
                        end
                        self.state = 1677
                         match(SwiftParser::T__39)

                    elsif la_ == 4 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1678
                        if not (self.precpred(self.ctx, 4)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 4)")
                        end
                        self.state = 1679
                         match(SwiftParser::T__12)

                    elsif la_ == 5 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1680
                        if not (self.precpred(self.ctx, 2)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 2)")
                        end
                        self.state = 1681
                         match(SwiftParser::T__29)
                        self.state = 1682
                         match(SwiftParser::T__31)

                    elsif la_ == 6 then
                        localctx = SwiftParser::TypeContext.new(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, SwiftParser.RULE_type)
                        self.state = 1683
                        if not (self.precpred(self.ctx, 1)) then
                            raise FailedPredicateException.new(self, "self.precpred(self.ctx, 1)")
                        end
                        self.state = 1684
                         match(SwiftParser::T__29)
                        self.state = 1685
                         match(SwiftParser::T__53)

                    end 
                end
                self.state = 1690
                self.errHandler.sync(self)
                _alt = self.interp.adaptivePredict(self.input,188,self.ctx)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure
            self.unrollRecursionContexts(_parentctx)
        end
        return localctx
    end
    # RuleFucntion generator
    class Type_annotationContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_annotation
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_annotation(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_annotation(self)
            end
        end
    end


    def type_annotation()
        localctx = SwiftParser::Type_annotationContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 372, SwiftParser.RULE_type_annotation)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1691
             match(SwiftParser::T__20)
            self.state = 1693
            _la = self.input.LA(1)
            if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                self.state = 1692 
                self.attributes()
            end #LL1OptionalBlockSingleAlt

            self.state = 1695 
            self.type(0)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_identifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def type_name() 
            getTypedRuleContext(SwiftParser::Type_nameContext,0)
        end


        def generic_argument_clause() 
            getTypedRuleContext(SwiftParser::Generic_argument_clauseContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_identifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_identifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_identifier(self)
            end
        end
    end


    def type_identifier()
        localctx = SwiftParser::Type_identifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 374, SwiftParser.RULE_type_identifier)
        _la = 0 # Token type
        begin
            self.state = 1708
            la_ = self.interp.adaptivePredict(self.input,192,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1697 
                self.type_name()
                self.state = 1699
                la_ = self.interp.adaptivePredict(self.input,190,self.ctx)
                if la_ == 1
                    self.state = 1698 
                    self.generic_argument_clause()

                end

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1701 
                self.type_name()
                self.state = 1703
                _la = self.input.LA(1)
                if _la==SwiftParser.T__64 then  # Ll1Optional Bloc Single Alt
                    self.state = 1702 
                    self.generic_argument_clause()
                end #LL1OptionalBlockSingleAlt

                self.state = 1705
                 match(SwiftParser::T__29)
                self.state = 1706 
                self.type_identifier()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_name(self)
            end
        end
    end


    def type_name()
        localctx = SwiftParser::Type_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 376, SwiftParser.RULE_type_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1710 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_typeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_type_body() 
            getTypedRuleContext(SwiftParser::Tuple_type_bodyContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_type
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_type(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_type(self)
            end
        end
    end


    def tuple_type()
        localctx = SwiftParser::Tuple_typeContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 378, SwiftParser.RULE_tuple_type)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1712
             match(SwiftParser::T__74)
            self.state = 1714
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__74) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__61) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__50) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1713 
                self.tuple_type_body()
            end #LL1OptionalBlockSingleAlt

            self.state = 1716
             match(SwiftParser::T__5)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_type_bodyContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_type_element_list() 
            getTypedRuleContext(SwiftParser::Tuple_type_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_type_body
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_type_body(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_type_body(self)
            end
        end
    end


    def tuple_type_body()
        localctx = SwiftParser::Tuple_type_bodyContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 380, SwiftParser.RULE_tuple_type_body)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1718 
            self.tuple_type_element_list()
            self.state = 1720
            _la = self.input.LA(1)
            if _la==SwiftParser.T__26 then  # Ll1Optional Bloc Single Alt
                self.state = 1719
                 match(SwiftParser::T__26)
            end #LL1OptionalBlockSingleAlt

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_type_element_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def tuple_type_element() 
            getTypedRuleContext(SwiftParser::Tuple_type_elementContext,0)
        end


        def tuple_type_element_list() 
            getTypedRuleContext(SwiftParser::Tuple_type_element_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_type_element_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_type_element_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_type_element_list(self)
            end
        end
    end


    def tuple_type_element_list()
        localctx = SwiftParser::Tuple_type_element_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 382, SwiftParser.RULE_tuple_type_element_list)
        begin
            self.state = 1727
            la_ = self.interp.adaptivePredict(self.input,195,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1722 
                self.tuple_type_element()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1723 
                self.tuple_type_element()
                self.state = 1724
                 match(SwiftParser::T__72)
                self.state = 1725 
                self.tuple_type_element_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Tuple_type_elementContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def attributes() 
            getTypedRuleContext(SwiftParser::AttributesContext,0)
        end


        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def element_name() 
            getTypedRuleContext(SwiftParser::Element_nameContext,0)
        end


        def type_annotation() 
            getTypedRuleContext(SwiftParser::Type_annotationContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_tuple_type_element
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterTuple_type_element(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitTuple_type_element(self)
            end
        end
    end


    def tuple_type_element()
        localctx = SwiftParser::Tuple_type_elementContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 384, SwiftParser.RULE_tuple_type_element)
        _la = 0 # Token type
        begin
            self.state = 1742
            la_ = self.interp.adaptivePredict(self.input,199,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1730
                _la = self.input.LA(1)
                if _la==SwiftParser.T__61 then  # Ll1Optional Bloc Single Alt
                    self.state = 1729 
                    self.attributes()
                end #LL1OptionalBlockSingleAlt

                self.state = 1733
                la_ = self.interp.adaptivePredict(self.input,197,self.ctx)
                if la_ == 1
                    self.state = 1732
                     match(SwiftParser::T__35)

                end
                self.state = 1735 
                self.type(0)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1737
                la_ = self.interp.adaptivePredict(self.input,198,self.ctx)
                if la_ == 1
                    self.state = 1736
                     match(SwiftParser::T__35)

                end
                self.state = 1739 
                self.element_name()
                self.state = 1740 
                self.type_annotation()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Element_nameContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_element_name
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterElement_name(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitElement_name(self)
            end
        end
    end


    def element_name()
        localctx = SwiftParser::Element_nameContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 386, SwiftParser.RULE_element_name)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1744 
            self.identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_composition_typeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_identifier_list() 
            getTypedRuleContext(SwiftParser::Protocol_identifier_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_composition_type
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_composition_type(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_composition_type(self)
            end
        end
    end


    def protocol_composition_type()
        localctx = SwiftParser::Protocol_composition_typeContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 388, SwiftParser.RULE_protocol_composition_type)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1746
             match(SwiftParser::T__50)
            self.state = 1747
             match(SwiftParser::T__64)
            self.state = 1749
            _la = self.input.LA(1)
            if (((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)) | (1 << (self.Identifier - 68)))) != 0) then  # Ll1Optional Bloc Single Alt
                self.state = 1748 
                self.protocol_identifier_list()
            end #LL1OptionalBlockSingleAlt

            self.state = 1751
             match(SwiftParser::T__16)
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_identifier_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def protocol_identifier() 
            getTypedRuleContext(SwiftParser::Protocol_identifierContext,0)
        end


        def protocol_identifier_list() 
            getTypedRuleContext(SwiftParser::Protocol_identifier_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_identifier_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_identifier_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_identifier_list(self)
            end
        end
    end


    def protocol_identifier_list()
        localctx = SwiftParser::Protocol_identifier_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 390, SwiftParser.RULE_protocol_identifier_list)
        begin
            self.state = 1758
            la_ = self.interp.adaptivePredict(self.input,201,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1753 
                self.protocol_identifier()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1754 
                self.protocol_identifier()
                self.state = 1755
                 match(SwiftParser::T__72)
                self.state = 1756 
                self.protocol_identifier_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Protocol_identifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier() 
            getTypedRuleContext(SwiftParser::Type_identifierContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_protocol_identifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterProtocol_identifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitProtocol_identifier(self)
            end
        end
    end


    def protocol_identifier()
        localctx = SwiftParser::Protocol_identifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 392, SwiftParser.RULE_protocol_identifier)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1760 
            self.type_identifier()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Metatype_typeContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type() 
            getTypedRuleContext(SwiftParser::TypeContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_metatype_type
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterMetatype_type(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitMetatype_type(self)
            end
        end
    end


    def metatype_type()
        localctx = SwiftParser::Metatype_typeContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 394, SwiftParser.RULE_metatype_type)
        begin
            self.state = 1770
            la_ = self.interp.adaptivePredict(self.input,202,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1762 
                self.type(0)
                self.state = 1763
                 match(SwiftParser::T__29)
                self.state = 1764
                 match(SwiftParser::T__31)

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1766 
                self.type(0)
                self.state = 1767
                 match(SwiftParser::T__29)
                self.state = 1768
                 match(SwiftParser::T__53)

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_inheritance_clauseContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_inheritance_list() 
            getTypedRuleContext(SwiftParser::Type_inheritance_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_inheritance_clause
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_inheritance_clause(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_inheritance_clause(self)
            end
        end
    end


    def type_inheritance_clause()
        localctx = SwiftParser::Type_inheritance_clauseContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 396, SwiftParser.RULE_type_inheritance_clause)
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1772
             match(SwiftParser::T__20)
            self.state = 1773 
            self.type_inheritance_list()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Type_inheritance_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def type_identifier(i=nil) 
            if i.nil? 
                getTypedRuleContexts(SwiftParser::Type_identifierContext)
            else
                getTypedRuleContext(SwiftParser::Type_identifierContext,i)
            end
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_type_inheritance_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterType_inheritance_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitType_inheritance_list(self)
            end
        end
    end


    def type_inheritance_list()
        localctx = SwiftParser::Type_inheritance_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 398, SwiftParser.RULE_type_inheritance_list)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1775 
            self.type_identifier()
            self.state = 1780
            self.errHandler.sync(self)
            _la = self.input.LA(1)
            while _la==SwiftParser.T__72 do
                self.state = 1776
                 match(SwiftParser::T__72)
                self.state = 1777 
                self.type_identifier()
                self.state = 1782
                self.errHandler.sync(self)
                _la = self.input.LA(1)
            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class IdentifierContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def Identifier()
            getToken(SwiftParser::Identifier, 0)
        end

        def context_sensitive_keyword() 
            getTypedRuleContext(SwiftParser::Context_sensitive_keywordContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_identifier
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIdentifier(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIdentifier(self)
            end
        end
    end


    def identifier()
        localctx = SwiftParser::IdentifierContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 400, SwiftParser.RULE_identifier)
        begin
            self.state = 1785
            token = self.input.LA(1)
            if [self.Identifier].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1783
                 match(SwiftParser::Identifier)

            elsif [self.T__89, self.T__88, self.T__87, self.T__86, self.T__85, self.T__79, self.T__78, self.T__76, self.T__75, self.T__71, self.T__70, self.T__60, self.T__55, self.T__35, self.T__30, self.T__25, self.T__22, self.T__21, self.T__14, self.T__4, self.T__2].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1784 
                self.context_sensitive_keyword()

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class KeywordContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_keyword
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterKeyword(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitKeyword(self)
            end
        end
    end


    def keyword()
        localctx = SwiftParser::KeywordContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 402, SwiftParser.RULE_keyword)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1787
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__92) | (1 << self.T__91) | (1 << self.T__90) | (1 << self.T__83) | (1 << self.T__80) | (1 << self.T__73) | (1 << self.T__68) | (1 << self.T__67) | (1 << self.T__66) | (1 << self.T__65) | (1 << self.T__58) | (1 << self.T__57) | (1 << self.T__54) | (1 << self.T__52) | (1 << self.T__50) | (1 << self.T__49) | (1 << self.T__48) | (1 << self.T__47) | (1 << self.T__46) | (1 << self.T__45) | (1 << self.T__44) | (1 << self.T__40) | (1 << self.T__38) | (1 << self.T__37) | (1 << self.T__34) | (1 << self.T__33) | (1 << self.T__31))) != 0) or ((((_la - 66)) & ~0x3f) == 0  and ((1 << (_la - 66)) & ((1 << (self.T__27 - 66)) | (1 << (self.T__24 - 66)) | (1 << (self.T__13 - 66)) | (1 << (self.T__11 - 66)) | (1 << (self.T__9 - 66)) | (1 << (self.T__8 - 66)) | (1 << (self.T__7 - 66)) | (1 << (self.T__6 - 66)) | (1 << (self.T__1 - 66)) | (1 << (self.T__0 - 66)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Context_sensitive_keywordContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_context_sensitive_keyword
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterContext_sensitive_keyword(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitContext_sensitive_keyword(self)
            end
        end
    end


    def context_sensitive_keyword()
        localctx = SwiftParser::Context_sensitive_keywordContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 404, SwiftParser.RULE_context_sensitive_keyword)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1789
            _la = self.input.LA(1)
            if not ((((_la) & ~0x3f) == 0  and ((1 << _la) & ((1 << self.T__89) | (1 << self.T__88) | (1 << self.T__87) | (1 << self.T__86) | (1 << self.T__85) | (1 << self.T__79) | (1 << self.T__78) | (1 << self.T__76) | (1 << self.T__75) | (1 << self.T__71) | (1 << self.T__70) | (1 << self.T__60) | (1 << self.T__55) | (1 << self.T__35) | (1 << self.T__30))) != 0) or ((((_la - 68)) & ~0x3f) == 0  and ((1 << (_la - 68)) & ((1 << (self.T__25 - 68)) | (1 << (self.T__22 - 68)) | (1 << (self.T__21 - 68)) | (1 << (self.T__14 - 68)) | (1 << (self.T__4 - 68)) | (1 << (self.T__2 - 68)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Identifier_listContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def identifier() 
            getTypedRuleContext(SwiftParser::IdentifierContext,0)
        end


        def identifier_list() 
            getTypedRuleContext(SwiftParser::Identifier_listContext,0)
        end


        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_identifier_list
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterIdentifier_list(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitIdentifier_list(self)
            end
        end
    end


    def identifier_list()
        localctx = SwiftParser::Identifier_listContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 406, SwiftParser.RULE_identifier_list)
        begin
            self.state = 1796
            la_ = self.interp.adaptivePredict(self.input,205,self.ctx)
            if la_ == 1 then
                self.enterOuterAlt(localctx, 1)
                self.state = 1791 
                self.identifier()

            elsif la_ == 2 then
                self.enterOuterAlt(localctx, 2)
                self.state = 1792 
                self.identifier()
                self.state = 1793
                 match(SwiftParser::T__72)
                self.state = 1794 
                self.identifier_list()

            end
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class LiteralContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def integer_literal() 
            getTypedRuleContext(SwiftParser::Integer_literalContext,0)
        end


        def Floating_point_literal()
            getToken(SwiftParser::Floating_point_literal, 0)
        end

        def String_literal()
            getToken(SwiftParser::String_literal, 0)
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_literal
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterLiteral(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitLiteral(self)
            end
        end
    end


    def literal()
        localctx = SwiftParser::LiteralContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 408, SwiftParser.RULE_literal)
        begin
            self.state = 1801
            token = self.input.LA(1)
            if [self.Binary_literal, self.Octal_literal, self.Decimal_literal, self.Hexadecimal_literal].member? token then 
                self.enterOuterAlt(localctx, 1)
                self.state = 1798 
                self.integer_literal()

            elsif [self.Floating_point_literal].member? token then 
                self.enterOuterAlt(localctx, 2)
                self.state = 1799
                 match(SwiftParser::Floating_point_literal)

            elsif [self.String_literal].member? token then 
                self.enterOuterAlt(localctx, 3)
                self.state = 1800
                 match(SwiftParser::String_literal)

            else
                raise NoViableAltException.new(self)
            end #LL1AltBlock

        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator
    # RuleFucntion generator
    class Integer_literalContext < ParserRuleContext
        attr_accessor :parser 
        def initialize(parser, parent=nil, invoking_state=-1 )
            super(parent, invoking_state)
            self.parser = parser
        end

        def Hexadecimal_literal()
            getToken(SwiftParser::Hexadecimal_literal, 0)
        end

        def Binary_literal()
            getToken(SwiftParser::Binary_literal, 0)
        end

        def Octal_literal()
            getToken(SwiftParser::Octal_literal, 0)
        end

        def Decimal_literal()
            getToken(SwiftParser::Decimal_literal, 0)
        end

        def ruleIndex # getRuleIndex()
            SwiftParser.RULE_integer_literal
        end	

        def enterRule(listener)
            if listener.kind_of? SwiftListener then
                listener.enterInteger_literal(self)
            end
        end
        def exitRule(listener)
            if listener.kind_of? SwiftListener then
                listener.exitInteger_literal(self)
            end
        end
    end


    def integer_literal()
        localctx = SwiftParser::Integer_literalContext.new(self, self.ctx, self.state)
        self.enterRule(localctx, 410, SwiftParser.RULE_integer_literal)
        _la = 0 # Token type
        begin
            self.enterOuterAlt(localctx, 1)
            self.state = 1803
            _la = self.input.LA(1)
            if not (((((_la - 96)) & ~0x3f) == 0  and ((1 << (_la - 96)) & ((1 << (self.Binary_literal - 96)) | (1 << (self.Octal_literal - 96)) | (1 << (self.Decimal_literal - 96)) | (1 << (self.Hexadecimal_literal - 96)))) != 0))  then 
                self.errHandler.recoverInline(self)
            end
            self.consume()
        rescue RecognitionException => re
            localctx.exception = re
            self.errHandler.reportError(self, re)
            self.errHandler.recover(self, re)
        ensure 
            self.exitRule()
        end
        return localctx
    end
    # end Rule Generator


    def sempred(localctx, ruleIndex, predIndex)
        if self.predicates.nil? then
            self.predicates = Hash.new
        end
        self.predicates[134] = self.pattern_sempred
        self.predicates[153] = self.expression_sempred
        self.predicates[185] = self.type_sempred
        pred = self.predicates[ruleIndex] 
        if pred.nil? then
            raise Exception.new("No predicate with index: #{ruleIndex}")
        else
            return pred(localctx, predIndex)
        end
    end
    def expression_sempred(localctx, predIndex)
            if predIndex == 1 then
                return self.precpred(self.ctx, 14)
         
            end

            if predIndex == 2 then
                return self.precpred(self.ctx, 13)
         
            end

            if predIndex == 3 then
                return self.precpred(self.ctx, 12)
         
            end

            if predIndex == 4 then
                return self.precpred(self.ctx, 11)
         
            end

            if predIndex == 5 then
                return self.precpred(self.ctx, 10)
         
            end

            if predIndex == 6 then
                return self.precpred(self.ctx, 9)
         
            end

            if predIndex == 7 then
                return self.precpred(self.ctx, 8)
         
            end

            if predIndex == 8 then
                return self.precpred(self.ctx, 7)
         
            end

            if predIndex == 9 then
                return self.precpred(self.ctx, 6)
         
            end

            if predIndex == 10 then
                return self.precpred(self.ctx, 5)
         
            end

            if predIndex == 11 then
                return self.precpred(self.ctx, 4)
         
            end

            if predIndex == 12 then
                return self.precpred(self.ctx, 3)
         
            end

            if predIndex == 13 then
                return self.precpred(self.ctx, 2)
         
            end

            if predIndex == 14 then
                return self.precpred(self.ctx, 1)
         
            end

    end
    def pattern_sempred(localctx, predIndex)
            if predIndex == 0 then
                return self.precpred(self.ctx, 2)
         
            end

    end
    def type_sempred(localctx, predIndex)
            if predIndex == 16 then
                return self.precpred(self.ctx, 9)
         
            end

            if predIndex == 17 then
                return self.precpred(self.ctx, 5)
         
            end

            if predIndex == 18 then
                return self.precpred(self.ctx, 4)
         
            end

            if predIndex == 19 then
                return self.precpred(self.ctx, 2)
         
            end

            if predIndex == 20 then
                return self.precpred(self.ctx, 1)
         
            end

            if predIndex == 15 then
                return self.precpred(self.ctx, 8)
         
            end

    end


end # class SwiftParser 
# footer?