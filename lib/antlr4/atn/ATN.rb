
class ATN
    include JavaSymbols
    INVALID_ALT_NUMBER = 0

    # Used for runtime deserialization of ATNs from strings#/
    attr_accessor :grammarType, :maxTokenType, :states, :decisionToState
    attr_accessor :ruleToStartState, :ruleToStopState, :modeNameToStartState 
    attr_accessor :ruleToTokenType, :lexerActions, :modeToStartState 
    def initialize(grammarType, maxTokenType)
        # The type of the ATN.
        @grammarType = grammarType
        # The maximum value for any symbol recognized by a transition in the ATN.
        @maxTokenType = maxTokenType
        @states = Array.new
        # Each subrule/rule is a decision point and we must track them so we
        #  can go back later and build DFA predictors for them.  This includes
        #  all the rules, subrules, optional blocks, ()+, ()* etc...
        @decisionToState = Array.new
        # Maps from rule index to starting state number.
        @ruleToStartState = Array.new
        # Maps from rule index to stop state number.
        @ruleToStopState = nil
        @modeNameToStartState = Hash.new
        # For lexer ATNs, this maps the rule index to the resulting token type.
        # For parser ATNs, this maps the rule index to the generated bypass token
        # type if the
        # {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}
        # deserialization option was specified; otherwise, this is {@code null}.
        @ruleToTokenType = nil
        # For lexer ATNs, this is an array of {@link LexerAction} objects which may
        # be referenced by action transitions in the ATN.
        @lexerActions = nil
        @modeToStartState = Array.new
    end
    # Compute the set of valid tokens that can occur starting in state {@code s}.
    #  If {@code ctx} is null, the set of tokens will not include what can follow
    #  the rule surrounding {@code s}. In other words, the set will be
    #  restricted to tokens reachable staying within {@code s}'s rule.
    def nextTokensInContext(s, ctx)
        require 'antlr4/LL1Analyzer'
        anal = LL1Analyzer.new(self)
        return anal.LOOK(s, ctx=ctx)
    end

    # Compute the set of valid tokens that can occur starting in {@code s} and
    # staying in same rule. {@link Token#EPSILON} is in set if we reach end of
    # rule.
    def nextTokensNoContext(s)
        if not s.nextTokenWithinRule.nil? 
          return s.nextTokenWithinRule 
        end
        s.nextTokenWithinRule = self.nextTokensInContext(s,nil )
        s.nextTokenWithinRule.readonly = true
        return s.nextTokenWithinRule
    end
    def nextTokens(s, ctx= nil) 
        if ctx.nil? 
            return self.nextTokensNoContext(s)
        else
            return self.nextTokensInContext(s, ctx)
        end
    end
    def addState(state)
        if not state.nil? 
            state.atn = self
            state.stateNumber = self.states.length()
        end
        self.states.push(state)
    end

    def removeState(state)
        self.states[state.stateNumber] = nil 
    end
    def defineDecisionState(s)
        self.decisionToState.push(s)
        s.decision = self.decisionToState.length()-1
        return s.decision
    end
    def getDecisionState(decision)
        if self.decisionToState.length==0
            return  nil
        else
            return self.decisionToState[decision]
        end
    end
    # Computes the set of input symbols which could follow ATN state number
    # {@code stateNumber} in the specified full {@code context}. This method
    # considers the complete parser context, but does not evaluate semantic
    # predicates (i.e. all predicates encountered during the calculation are
    # assumed true). If a path in the ATN exists from the starting state to the
    # {@link RuleStopState} of the outermost context without matching any
    # symbols, {@link Token#EOF} is added to the returned set.
    #
    # <p>If {@code context} is {@code null}, it is treated as
    # {@link ParserRuleContext#EMPTY}.</p>
    #
    # @param stateNumber the ATN state number
    # @param context the full parse context
    # @return The set of potentially valid input symbols which could follow the
    # specified state in the specified context.
    # @throws IllegalArgumentException if the ATN does not contain a state with
    # number {@code stateNumber}
    #/
    def getExpectedTokens(stateNumber, ctx)
        if stateNumber < 0 or stateNumber >= self.states.length
            raise Exception.new("Invalid state number.")
        end
        s = self.states[stateNumber]
        following = self.nextTokens(s)
        if not following.member? Token.EPSILON 
            return following
        end
        expected = IntervalSet.new()
        expected.addSet(following)
        #puts expected.to_s
        expected.remove(Token.EPSILON)
        #puts expected.to_s
        while ( ctx and ctx.invokingState >= 0 and following.member?(Token.EPSILON) ) do
            invokingState = self.states[ctx.invokingState]
            rt = invokingState.transitions[0]
            following = self.nextTokens(rt.followState)
            expected.addSet(following)
            expected.remove(Token.EPSILON)
            ctx = ctx.parentCtx
        end
        if following.member?(Token.EPSILON) then
            expected.addOne(Token::EOF)
        end
        return expected
    end
end
